   1              		.file	"main_house3d_rotate_hdmi.c"
   2              		.option nopic
   3              		.attribute arch, "rv32i2p0_m2p0"
   4              		.attribute unaligned_access, 0
   5              		.attribute stack_align, 16
   6              	# GNU C17 (GCC) version 11.1.0 (riscv32-unknown-elf)
   7              	#	compiled by GNU C version 9.3.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl ve
   8              	# warning: GMP header version 6.2.0 differs from library version 6.3.0.
   9              	# warning: MPFR header version 4.0.2 differs from library version 4.2.1.
  10              	# warning: MPC header version 1.1.0 differs from library version 1.3.1.
  11              	# GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
  12              	# options passed: -march=rv32im -mabi=ilp32 -mtune=rocket -march=rv32im -Os -fno-pic -fno-stack-pro
  13              		.text
  14              		.align	2
  15              		.globl	dma_action
  17              	dma_action:
  18              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
  19 0000 B7070030 		li	a5,805306368		# tmp77,
  20 0004 23A6A702 		sw	a0,44(a5)	# src, MEM[(volatile uint32_t *)805306412B]
  21              	# kianv_stdlib.h:52:   *( (volatile uint32_t*) DMA_DST  ) = dst;
  22 0008 23A8B702 		sw	a1,48(a5)	# dst, MEM[(volatile uint32_t *)805306416B]
  23              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
  24 000c 23AAC702 		sw	a2,52(a5)	# len, MEM[(volatile uint32_t *)805306420B]
  25              	# kianv_stdlib.h:54:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
  26 0010 23ACD702 		sw	a3,56(a5)	# ctrl, MEM[(volatile uint32_t *)805306424B]
  27              	# kianv_stdlib.h:55: }
  28 0014 67800000 		ret	
  30              		.align	2
  31              		.globl	_sendCmd
  33              	_sendCmd:
  34              	# kianv_stdlib.h:62:     *((volatile uint32_t *) VIDEO_RAW) = ((0x00) << 8) | c;
  35 0018 B7070030 		li	a5,805306368		# tmp75,
  36 001c 23A6A700 		sw	a0,12(a5)	# c, MEM[(volatile uint32_t *)805306380B]
  37              	# kianv_stdlib.h:64: }
  38 0020 67800000 		ret	
  40              		.align	2
  41              		.globl	_sendData
  43              	_sendData:
  44              	# kianv_stdlib.h:71:     *((volatile uint32_t *) VIDEO_RAW) = ((0x01) << 8) | c;
  45 0024 13650510 		ori	a0,a0,256	#, _3, tmp78
  46              	# kianv_stdlib.h:71:     *((volatile uint32_t *) VIDEO_RAW) = ((0x01) << 8) | c;
  47 0028 B7070030 		li	a5,805306368		# tmp77,
  48 002c 23A6A700 		sw	a0,12(a5)	# _3, MEM[(volatile uint32_t *)805306380B]
  49              	# kianv_stdlib.h:73: }
  50 0030 67800000 		ret	
  52              		.align	2
  53              		.globl	init_oled1331
  55              	init_oled1331:
  56              	# kianv_stdlib.h:62:     *((volatile uint32_t *) VIDEO_RAW) = ((0x00) << 8) | c;
  57 0034 B7070030 		li	a5,805306368		# tmp73,
  58 0038 1307E00A 		li	a4,174		# tmp74,
  59 003c 23A6E700 		sw	a4,12(a5)	# tmp74, MEM[(volatile uint32_t *)805306380B]
  60 0040 13071008 		li	a4,129		# tmp77,
  61 0044 23A6E700 		sw	a4,12(a5)	# tmp77, MEM[(volatile uint32_t *)805306380B]
  62 0048 13071009 		li	a4,145		# tmp80,
  63 004c 23A6E700 		sw	a4,12(a5)	# tmp80, MEM[(volatile uint32_t *)805306380B]
  64 0050 13072008 		li	a4,130		# tmp83,
  65 0054 23A6E700 		sw	a4,12(a5)	# tmp83, MEM[(volatile uint32_t *)805306380B]
  66 0058 13070008 		li	a4,128		# tmp86,
  67 005c 23A6E700 		sw	a4,12(a5)	# tmp86, MEM[(volatile uint32_t *)805306380B]
  68 0060 13073008 		li	a4,131		# tmp89,
  69 0064 23A6E700 		sw	a4,12(a5)	# tmp89, MEM[(volatile uint32_t *)805306380B]
  70 0068 1307D007 		li	a4,125		# tmp92,
  71 006c 23A6E700 		sw	a4,12(a5)	# tmp92, MEM[(volatile uint32_t *)805306380B]
  72 0070 13077008 		li	a4,135		# tmp95,
  73 0074 23A6E700 		sw	a4,12(a5)	# tmp95, MEM[(volatile uint32_t *)805306380B]
  74 0078 13076000 		li	a4,6		# tmp98,
  75 007c 23A6E700 		sw	a4,12(a5)	# tmp98, MEM[(volatile uint32_t *)805306380B]
  76 0080 1307A008 		li	a4,138		# tmp101,
  77 0084 23A6E700 		sw	a4,12(a5)	# tmp101, MEM[(volatile uint32_t *)805306380B]
  78 0088 13074006 		li	a4,100		# tmp104,
  79 008c 23A6E700 		sw	a4,12(a5)	# tmp104, MEM[(volatile uint32_t *)805306380B]
  80 0090 9306B008 		li	a3,139		# tmp107,
  81 0094 23A6D700 		sw	a3,12(a5)	# tmp107, MEM[(volatile uint32_t *)805306380B]
  82 0098 93068007 		li	a3,120		# tmp110,
  83 009c 23A6D700 		sw	a3,12(a5)	# tmp110, MEM[(volatile uint32_t *)805306380B]
  84 00a0 9306C008 		li	a3,140		# tmp113,
  85 00a4 23A6D700 		sw	a3,12(a5)	# tmp113, MEM[(volatile uint32_t *)805306380B]
  86 00a8 23A6E700 		sw	a4,12(a5)	# tmp104, MEM[(volatile uint32_t *)805306380B]
  87 00ac 1307000A 		li	a4,160		# tmp119,
  88 00b0 23A6E700 		sw	a4,12(a5)	# tmp119, MEM[(volatile uint32_t *)805306380B]
  89 00b4 13072007 		li	a4,114		# tmp122,
  90 00b8 23A6E700 		sw	a4,12(a5)	# tmp122, MEM[(volatile uint32_t *)805306380B]
  91 00bc 1307100A 		li	a4,161		# tmp125,
  92 00c0 23A6E700 		sw	a4,12(a5)	# tmp125, MEM[(volatile uint32_t *)805306380B]
  93 00c4 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
  94 00c8 1307200A 		li	a4,162		# tmp130,
  95 00cc 23A6E700 		sw	a4,12(a5)	# tmp130, MEM[(volatile uint32_t *)805306380B]
  96 00d0 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
  97 00d4 1307400A 		li	a4,164		# tmp135,
  98 00d8 23A6E700 		sw	a4,12(a5)	# tmp135, MEM[(volatile uint32_t *)805306380B]
  99 00dc 1307800A 		li	a4,168		# tmp138,
 100 00e0 23A6E700 		sw	a4,12(a5)	# tmp138, MEM[(volatile uint32_t *)805306380B]
 101 00e4 1307F003 		li	a4,63		# tmp141,
 102 00e8 23A6E700 		sw	a4,12(a5)	# tmp141, MEM[(volatile uint32_t *)805306380B]
 103 00ec 1307D00A 		li	a4,173		# tmp144,
 104 00f0 23A6E700 		sw	a4,12(a5)	# tmp144, MEM[(volatile uint32_t *)805306380B]
 105 00f4 1307E008 		li	a4,142		# tmp147,
 106 00f8 23A6E700 		sw	a4,12(a5)	# tmp147, MEM[(volatile uint32_t *)805306380B]
 107 00fc 1307000B 		li	a4,176		# tmp150,
 108 0100 23A6E700 		sw	a4,12(a5)	# tmp150, MEM[(volatile uint32_t *)805306380B]
 109 0104 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
 110 0108 1307100B 		li	a4,177		# tmp155,
 111 010c 23A6E700 		sw	a4,12(a5)	# tmp155, MEM[(volatile uint32_t *)805306380B]
 112 0110 13071003 		li	a4,49		# tmp158,
 113 0114 23A6E700 		sw	a4,12(a5)	# tmp158, MEM[(volatile uint32_t *)805306380B]
 114 0118 1307300B 		li	a4,179		# tmp161,
 115 011c 23A6E700 		sw	a4,12(a5)	# tmp161, MEM[(volatile uint32_t *)805306380B]
 116 0120 1307000F 		li	a4,240		# tmp164,
 117 0124 23A6E700 		sw	a4,12(a5)	# tmp164, MEM[(volatile uint32_t *)805306380B]
 118 0128 1307B00B 		li	a4,187		# tmp167,
 119 012c 23A6E700 		sw	a4,12(a5)	# tmp167, MEM[(volatile uint32_t *)805306380B]
 120 0130 1307A003 		li	a4,58		# tmp170,
 121 0134 23A6E700 		sw	a4,12(a5)	# tmp170, MEM[(volatile uint32_t *)805306380B]
 122 0138 1307E00B 		li	a4,190		# tmp173,
 123 013c 23A6E700 		sw	a4,12(a5)	# tmp173, MEM[(volatile uint32_t *)805306380B]
 124 0140 1307E003 		li	a4,62		# tmp176,
 125 0144 23A6E700 		sw	a4,12(a5)	# tmp176, MEM[(volatile uint32_t *)805306380B]
 126 0148 1307E002 		li	a4,46		# tmp179,
 127 014c 23A6E700 		sw	a4,12(a5)	# tmp179, MEM[(volatile uint32_t *)805306380B]
 128 0150 1307F00A 		li	a4,175		# tmp182,
 129 0154 23A6E700 		sw	a4,12(a5)	# tmp182, MEM[(volatile uint32_t *)805306380B]
 130              	# kianv_stdlib.h:120: }
 131 0158 67800000 		ret	
 133              		.align	2
 134              		.globl	set_reg
 136              	set_reg:
 137              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 138 015c 93071000 		li	a5,1		# tmp85,
 139 0160 B395B700 		sll	a1,a5,a1	# tmp88, _12, tmp85
 140              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 141 0164 83270500 		lw	a5,0(a0)		# _1,* p
 142              	# kianv_stdlib.h:124:     if (bit) {
 143 0168 63080600 		beq	a2,zero,.L6	#, tmp89,,
 144              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 145 016c B3E5F500 		or	a1,a1,a5	# _1, _5, _12
 146              	.L8:
 147              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 148 0170 2320B500 		sw	a1,0(a0)	# _18,* p
 149              	# kianv_stdlib.h:129: }
 150 0174 67800000 		ret	
 151              	.L6:
 152              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 153 0178 93C5F5FF 		not	a1,a1	# tmp86, _12
 154              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 155 017c B3F5F500 		and	a1,a1,a5	# _13, _18, tmp86
 156 0180 6FF01FFF 		j	.L8		#
 158              		.align	2
 159              		.globl	gpio_set_value
 161              	gpio_set_value:
 162              	# kianv_stdlib.h:131: void gpio_set_value(int gpio, int bit) {
 163 0184 13860500 		mv	a2,a1	# tmp76, bit
 164              	# kianv_stdlib.h:132:     set_reg(GPIO_OUTPUT, gpio, bit);
 165 0188 93050500 		mv	a1,a0	#, tmp75
 166 018c 37050030 		li	a0,805306368		# tmp74,
 167 0190 1305C501 		addi	a0,a0,28	#,, tmp74
 168 0194 17030000 		tail	set_reg		#
 168      67000300 
 170              		.align	2
 171              		.globl	gpio_get_input_value
 173              	gpio_get_input_value:
 174              	# kianv_stdlib.h:136:   uint32_t read = IO_IN(GPIO_INPUT);
 175 019c B7070030 		li	a5,805306368		# tmp77,
 176 01a0 83A70702 		lw	a5,32(a5)		# read, MEM[(volatile uint32_t *)805306400B]
 177              	# kianv_stdlib.h:139:   return ((read >> gpio) & 0x01);
 178 01a4 33D5A700 		srl	a0,a5,a0	# tmp80, tmp79, read
 179              	# kianv_stdlib.h:140: }
 180 01a8 13751500 		andi	a0,a0,1	#,, tmp79
 181 01ac 67800000 		ret	
 183              		.align	2
 184              		.globl	gpio_set_direction
 186              	gpio_set_direction:
 187              	# kianv_stdlib.h:142: void gpio_set_direction(int gpio, int bit) {
 188 01b0 13860500 		mv	a2,a1	# tmp76, bit
 189              	# kianv_stdlib.h:143:     set_reg(GPIO_DIR, gpio, bit);
 190 01b4 93050500 		mv	a1,a0	#, tmp75
 191 01b8 37050030 		li	a0,805306368		# tmp74,
 192 01bc 13054501 		addi	a0,a0,20	#,, tmp74
 193 01c0 17030000 		tail	set_reg		#
 193      67000300 
 195              		.align	2
 196              		.globl	get_cycles
 198              	get_cycles:
 199 01c8 130101FF 		addi	sp,sp,-16	#,,
 200              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 201              	 #APP
 202              	# 150 "kianv_stdlib.h" 1
   1              	#include <stdint.h>
   2              	#include <math.h>
   3              	#include "SSD1331.h"
   4              	
   5              	/* kian hardware register */
   6              	#define IO_BASE 0x30000000
   7              	#define UART_TX             (volatile uint32_t *) (IO_BASE + 0x0000)
   8              	#define UART_READY          (volatile uint32_t *) (IO_BASE + 0x0000)
   9              	#define VIDEOENABLE         (volatile uint32_t *) (IO_BASE + 0x0008)
  10              	#define VIDEO               (volatile uint32_t *) (IO_BASE + 0x0008)
  11              	#define VIDEO_RAW           (volatile uint32_t *) (IO_BASE + 0x000C)
  12              	#define CPU_FREQ            (volatile uint32_t *) (IO_BASE + 0x0010)
  13              	// gpio hack stuff
  14              	#define GPIO_DIR            ( volatile uint32_t  *) (IO_BASE + 0x0014)
  15              	#define GPIO_PULLUP         ( volatile uint32_t  *) (IO_BASE + 0x0018) // not implemented
  16              	#define GPIO_OUTPUT         ( volatile uint32_t  *) (IO_BASE + 0x001C)
  17              	#define GPIO_INPUT          ( volatile uint32_t  *) (IO_BASE + 0x0020)
  18              	#define IO_OUT(reg, value) *((volatile uint32_t  *) (reg)) = (value)
  19              	#define IO_IN(reg)         *((volatile uint32_t  *) reg)
  20              	// dma stuff
  21              	#define DMA_SRC             ( volatile uint32_t  *) (IO_BASE + 0x002C)
  22              	#define DMA_DST             ( volatile uint32_t  *) (IO_BASE + 0x0030)
  23              	#define DMA_LEN             ( volatile uint32_t  *) (IO_BASE + 0x0034)
  24              	#define DMA_CTRL            ( volatile uint32_t  *) (IO_BASE + 0x0038)
  25              	#define DMA_MEMCPY          (1 << 0)
  26              	#define DMA_MEMSET          (1 << 1)
  27              	
  28              	#define GPIO_INPUT_PIN  0
  29              	#define GPIO_OUTPUT_PIN 1
  30              	//#define RV32_FASTCODE __attribute((section(".fastcode")))
  31              	#define RV32_FASTCODE
  32              	
  33              	//__attribute((section(".fastcode")))
  34              	
  35              	#define RED   "\x1B[31m"
  36              	#define GRN   "\x1B[32m"
  37              	#define YEL   "\x1B[33m"
  38              	#define BLU   "\x1B[34m"
  39              	#define MAG   "\x1B[35m"
  40              	#define CYN   "\x1B[36m"
  41              	#define WHT   "\x1B[37m"
  42              	#define RESET "\x1B[0m"
  43              	
  44              	#define CLS       "\x1B[2J"
  45              	#define BOLD      "\x1B[1m"
  46              	#define BLINK     "\x1B[5m"
  47              	#define BLINK_OFF "\x1B[25m"
  48              	
  49              	// dma stuff
  50              	void dma_action(uint32_t src, uint32_t dst, uint32_t len, uint32_t ctrl) {
  51              	  *( (volatile uint32_t*) DMA_SRC  ) = src;
  52              	  *( (volatile uint32_t*) DMA_DST  ) = dst;
  53              	  *( (volatile uint32_t*) DMA_LEN  ) = len;
  54              	  *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
  55              	}
  56              	
  57              	void _sendCmd(uint8_t c)
  58              	{
  59              	    //digitalWrite(_dc,LOW);
  60              	    //digitalWrite(_cs,LOW);
  61              	    // SPI.transfer(c);
  62              	    *((volatile uint32_t *) VIDEO_RAW) = ((0x00) << 8) | c;
  63              	    //digitalWrite(_cs,HIGH);
  64              	}
  65              	
  66              	void _sendData(uint8_t c)
  67              	{
  68              	    //digitalWrite(_dc,LOW);
  69              	    //digitalWrite(_cs,LOW);
  70              	    // SPI.transfer(c);
  71              	    *((volatile uint32_t *) VIDEO_RAW) = ((0x01) << 8) | c;
  72              	    //digitalWrite(_cs,HIGH);
  73              	}
  74              	
  75              	void init_oled1331(void)
  76              	{
  77              	    //pinMode(_dc, OUTPUT);
  78              	    //pinMode(_cs, OUTPUT);
  79              	
  80              	    //SPI.begin();
  81              	
  82              	    _sendCmd(CMD_DISPLAY_OFF);	//Display Off
  83              	    _sendCmd(CMD_SET_CONTRAST_A);	//Set contrast for color A
  84              	    _sendCmd(0x91);		//145
  85              	    _sendCmd(CMD_SET_CONTRAST_B);	//Set contrast for color B
  86              	    _sendCmd(0x80);		//80
  87              	    _sendCmd(CMD_SET_CONTRAST_C);	//Set contrast for color C
  88              	    _sendCmd(0x7D);		//125
  89              	    _sendCmd(CMD_MASTER_CURRENT_CONTROL);	//master current control
  90              	    _sendCmd(0x06);		//6
  91              	    _sendCmd(CMD_SET_PRECHARGE_SPEED_A);	//Set Second Pre-change Speed For ColorA
  92              	    _sendCmd(0x64);		//100
  93              	    _sendCmd(CMD_SET_PRECHARGE_SPEED_B);	//Set Second Pre-change Speed For ColorB
  94              	    _sendCmd(0x78);		//120
  95              	    _sendCmd(CMD_SET_PRECHARGE_SPEED_C);	//Set Second Pre-change Speed For ColorC
  96              	    _sendCmd(0x64);		//100
  97              	    _sendCmd(CMD_SET_REMAP);	//set remap & data format
  98              	    _sendCmd(0x72);		//0x72
  99              	    _sendCmd(CMD_SET_DISPLAY_START_LINE);	//Set display Start Line
 100              	    _sendCmd(0x0);
 101              	    _sendCmd(CMD_SET_DISPLAY_OFFSET);	//Set display offset
 102              	    _sendCmd(0x0);
 103              	    _sendCmd(CMD_NORMAL_DISPLAY);	//Set display mode
 104              	    _sendCmd(CMD_SET_MULTIPLEX_RATIO);	//Set multiplex ratio
 105              	    _sendCmd(0x3F);
 106              	    _sendCmd(CMD_SET_MASTER_CONFIGURE);	//Set master configuration
 107              	    _sendCmd(0x8E);
 108              	    _sendCmd(CMD_POWER_SAVE_MODE);	//Set Power Save Mode
 109              	    _sendCmd(0x00);		//0x00
 110              	    _sendCmd(CMD_PHASE_PERIOD_ADJUSTMENT);	//phase 1 and 2 period adjustment
 111              	    _sendCmd(0x31);		//0x31
 112              	    _sendCmd(CMD_DISPLAY_CLOCK_DIV);	//display clock divider/oscillator frequency
 113              	    _sendCmd(0xF0);
 114              	    _sendCmd(CMD_SET_PRECHARGE_VOLTAGE);	//Set Pre-Change Level
 115              	    _sendCmd(0x3A);
 116              	    _sendCmd(CMD_SET_V_VOLTAGE);	//Set vcomH
 117              	    _sendCmd(0x3E);
 118              	    _sendCmd(CMD_DEACTIVE_SCROLLING);	//disable scrolling
 119              	    _sendCmd(CMD_NORMAL_BRIGHTNESS_DISPLAY_ON);	//set display on
 120              	}
 121              	
 122              	
 123              	void set_reg(volatile uint32_t *p, int gpio, int bit) {
 124              	    if (bit) {
 125              	      *p |=  (0x01 << (gpio & 0x1f));
 126              	    } else {
 127              	      *p &= ~( 0x01 << (gpio & 0x1f));
 128              	    }
 129              	}
 130              	
 131              	void gpio_set_value(int gpio, int bit) {
 132              	    set_reg(GPIO_OUTPUT, gpio, bit);
 133              	}
 134              	
 135              	uint32_t gpio_get_input_value(int gpio) {
 136              	  uint32_t read = IO_IN(GPIO_INPUT);
 137              	
 138              	  //  return ((read & (1<<gpio)) >> gpio);
 139              	  return ((read >> gpio) & 0x01);
 140              	}
 141              	
 142              	void gpio_set_direction(int gpio, int bit) {
 143              	    set_reg(GPIO_DIR, gpio, bit);
 144              	}
 145              	
 146              	uint64_t get_cycles() {
 147              	  volatile uint32_t tmph0;
 148              	  volatile uint32_t tmpl0;
 149              	
 150 01cc F32700C8 	  asm volatile ("rdcycleh %0" : "=r"(tmph0));
 151              	  asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 203              		rdcycleh a5	# tmp78
 204              	# 0 "" 2
 205              	 #NO_APP
 206 01d0 2324F100 		sw	a5,8(sp)	# tmp78, tmph0
 207              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 208              	 #APP
 209              	# 151 "kianv_stdlib.h" 1
 152              	
 210              		rdcycle  a5	# tmp79
 211              	# 0 "" 2
 212              	 #NO_APP
 213 01d8 2326F100 		sw	a5,12(sp)	# tmp79, tmpl0
 214              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 215 01dc 83258100 		lw	a1,8(sp)		# tmph0.0_1, tmph0
 216              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 217 01e0 0325C100 		lw	a0,12(sp)		# tmpl0.1_4, tmpl0
 218              	# kianv_stdlib.h:155: }
 219 01e4 13010101 		addi	sp,sp,16	#,,
 220 01e8 67800000 		jr	ra		#
 222              		.align	2
 223              		.globl	wait_cycles
 225              	wait_cycles:
 226 01ec 130101FF 		addi	sp,sp,-16	#,,
 227 01f0 23248100 		sw	s0,8(sp)	#,
 228 01f4 23229100 		sw	s1,4(sp)	#,
 229 01f8 23202101 		sw	s2,0(sp)	#,
 230 01fc 93040500 		mv	s1,a0	# wait, tmp97
 231 0200 13890500 		mv	s2,a1	# wait, tmp98
 232 0204 23261100 		sw	ra,12(sp)	#,
 233              	# kianv_stdlib.h:162:   uint64_t lim = get_cycles() + wait;
 234 0208 97000000 		call	get_cycles		#
 234      E7800000 
 235              	# kianv_stdlib.h:162:   uint64_t lim = get_cycles() + wait;
 236 0210 B3049500 		add	s1,a0,s1	# wait, tmp95, _1
 237 0214 33B4A400 		sltu	s0,s1,a0	# _1, tmp78, tmp95
 238 0218 B3852501 		add	a1,a1,s2	# wait, tmp96, tmp100
 239 021c 3304B400 		add	s0,s0,a1	# tmp96, tmp80, tmp78
 240              	.L17:
 241              	# kianv_stdlib.h:163:   while (get_cycles() < lim)
 242 0220 97000000 		call	get_cycles		#
 242      E7800000 
 243              	# kianv_stdlib.h:163:   while (get_cycles() < lim)
 244 0228 E3EC85FE 		bgtu	s0,a1,.L17	#, tmp80, _2,
 245 022c 6314B400 		bne	s0,a1,.L14	#, tmp80, _2,
 246 0230 E36895FE 		bgtu	s1,a0,.L17	#, tmp95, _2,
 247              	.L14:
 248              	# kianv_stdlib.h:165: }
 249 0234 8320C100 		lw	ra,12(sp)		#,
 250 0238 03248100 		lw	s0,8(sp)		#,
 251 023c 83244100 		lw	s1,4(sp)		#,
 252 0240 03290100 		lw	s2,0(sp)		#,
 253 0244 13010101 		addi	sp,sp,16	#,,
 254 0248 67800000 		jr	ra		#
 256              		.align	2
 257              		.globl	usleep
 259              	usleep:
 260              	# kianv_stdlib.h:168:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 261 024c 63040502 		beq	a0,zero,.L19	#, us,,
 262              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 263 0250 B7070030 		li	a5,805306368		# tmp78,
 264 0254 83A70701 		lw	a5,16(a5)		# _8, MEM[(volatile uint32_t *)805306384B]
 265              	# kianv_stdlib.h:168:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 266 0258 37470F00 		li	a4,999424		# tmp82,
 267 025c 13070724 		addi	a4,a4,576	#, tmp81, tmp82
 268 0260 B3D7E702 		divu	a5,a5,a4	# tmp81, tmp80, _8
 269              	# kianv_stdlib.h:168:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 270 0264 93050000 		li	a1,0		#,
 271 0268 3385A702 		mul	a0,a5,a0	#, tmp80, us
 272 026c 17030000 		tail	wait_cycles		#
 272      67000300 
 273              	.L19:
 274              	# kianv_stdlib.h:169: }
 275 0274 67800000 		ret	
 277              		.align	2
 278              		.globl	msleep
 280              	msleep:
 281              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 282 0278 63020502 		beq	a0,zero,.L21	#, ms,,
 283              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 284 027c B7070030 		li	a5,805306368		# tmp78,
 285 0280 83A70701 		lw	a5,16(a5)		# _8, MEM[(volatile uint32_t *)805306384B]
 286              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 287 0284 1307803E 		li	a4,1000		# tmp80,
 288              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 289 0288 93050000 		li	a1,0		#,
 290              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 291 028c B3D7E702 		divu	a5,a5,a4	# tmp80, tmp81, _8
 292              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 293 0290 3385A702 		mul	a0,a5,a0	#, tmp81, ms
 294 0294 17030000 		tail	wait_cycles		#
 294      67000300 
 295              	.L21:
 296              	# kianv_stdlib.h:173: }
 297 029c 67800000 		ret	
 299              		.align	2
 300              		.globl	sleep
 302              	sleep:
 303              	# kianv_stdlib.h:176:   if (sec) wait_cycles(sec * get_cpu_freq());
 304 02a0 630E0500 		beq	a0,zero,.L23	#, sec,,
 305              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 306 02a4 B7070030 		li	a5,805306368		# tmp77,
 307 02a8 83A70701 		lw	a5,16(a5)		# _7, MEM[(volatile uint32_t *)805306384B]
 308              	# kianv_stdlib.h:176:   if (sec) wait_cycles(sec * get_cpu_freq());
 309 02ac 93050000 		li	a1,0		#,
 310 02b0 3305F502 		mul	a0,a0,a5	#, sec, _7
 311 02b4 17030000 		tail	wait_cycles		#
 311      67000300 
 312              	.L23:
 313              	# kianv_stdlib.h:177: }
 314 02bc 67800000 		ret	
 316              		.globl	__udivdi3
 317              		.align	2
 318              		.globl	nanoseconds
 320              	nanoseconds:
 321 02c0 130101FF 		addi	sp,sp,-16	#,,
 322 02c4 23261100 		sw	ra,12(sp)	#,
 323              	# kianv_stdlib.h:180:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000000);
 324 02c8 97000000 		call	get_cycles		#
 324      E7800000 
 325              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 326 02d0 B7070030 		li	a5,805306368		# tmp78,
 327 02d4 03A60701 		lw	a2,16(a5)		# _7, MEM[(volatile uint32_t *)805306384B]
 328              	# kianv_stdlib.h:180:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000000);
 329 02d8 B7470F00 		li	a5,999424		# tmp83,
 330 02dc 93870724 		addi	a5,a5,576	#, tmp82, tmp83
 331 02e0 3356F602 		divu	a2,a2,a5	# tmp82,, _7
 332 02e4 93060000 		li	a3,0		#,
 333 02e8 97000000 		call	__udivdi3		#
 333      E7800000 
 334              	# kianv_stdlib.h:181: }
 335 02f0 8320C100 		lw	ra,12(sp)		#,
 336 02f4 13010101 		addi	sp,sp,16	#,,
 337 02f8 67800000 		jr	ra		#
 339              		.align	2
 340              		.globl	milliseconds
 342              	milliseconds:
 343 02fc 130101FF 		addi	sp,sp,-16	#,,
 344 0300 23261100 		sw	ra,12(sp)	#,
 345              	# kianv_stdlib.h:184:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000);
 346 0304 97000000 		call	get_cycles		#
 346      E7800000 
 347              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 348 030c B7070030 		li	a5,805306368		# tmp78,
 349 0310 03A60701 		lw	a2,16(a5)		# _7, MEM[(volatile uint32_t *)805306384B]
 350              	# kianv_stdlib.h:184:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000);
 351 0314 9307803E 		li	a5,1000		# tmp81,
 352 0318 93060000 		li	a3,0		#,
 353 031c 3356F602 		divu	a2,a2,a5	# tmp81,, _7
 354 0320 97000000 		call	__udivdi3		#
 354      E7800000 
 355              	# kianv_stdlib.h:185: }
 356 0328 8320C100 		lw	ra,12(sp)		#,
 357 032c 13010101 		addi	sp,sp,16	#,,
 358 0330 67800000 		jr	ra		#
 360              		.align	2
 361              		.globl	seconds
 363              	seconds:
 364 0334 130101FF 		addi	sp,sp,-16	#,,
 365 0338 23261100 		sw	ra,12(sp)	#,
 366              	# kianv_stdlib.h:188:   return get_cycles() / (uint64_t) (get_cpu_freq());
 367 033c 97000000 		call	get_cycles		#
 367      E7800000 
 368              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 369 0344 B7070030 		li	a5,805306368		# tmp77,
 370 0348 03A60701 		lw	a2,16(a5)		# _6, MEM[(volatile uint32_t *)805306384B]
 371              	# kianv_stdlib.h:188:   return get_cycles() / (uint64_t) (get_cpu_freq());
 372 034c 93060000 		li	a3,0		#,
 373 0350 97000000 		call	__udivdi3		#
 373      E7800000 
 374              	# kianv_stdlib.h:189: }
 375 0358 8320C100 		lw	ra,12(sp)		#,
 376 035c 13010101 		addi	sp,sp,16	#,,
 377 0360 67800000 		jr	ra		#
 379              		.align	2
 380              		.globl	putchar
 382              	putchar:
 383              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 384 0364 B7070030 		li	a5,805306368		# tmp75,
 385              	.L32:
 386              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 387 0368 03A70700 		lw	a4,0(a5)		# _1, MEM[(volatile uint32_t *)805306368B]
 388              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 389 036c E30E07FE 		beq	a4,zero,.L32	#, _1,,
 390              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 391 0370 23A0A700 		sw	a0,0(a5)	# c, MEM[(volatile uint32_t *)805306368B]
 392              	# kianv_stdlib.h:195:    if (c == 13) {
 393 0374 1307D000 		li	a4,13		# tmp77,
 394 0378 6316E500 		bne	a0,a4,.L31	#, c, tmp77,
 395              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 396 037c 1307A000 		li	a4,10		# tmp79,
 397 0380 23A0E700 		sw	a4,0(a5)	# tmp79, MEM[(volatile uint32_t *)805306368B]
 398              	.L31:
 399              	# kianv_stdlib.h:198: }
 400 0384 67800000 		ret	
 402              		.align	2
 403              		.globl	print_chr
 405              	print_chr:
 406              	# kianv_stdlib.h:201:   putchar(ch);
 407 0388 17030000 		tail	putchar		#
 407      67000300 
 409              		.align	2
 410              		.globl	print_char
 412              	print_char:
 413 0390 17030000 		tail	putchar		#
 413      67000300 
 415              		.align	2
 416              		.globl	print_str
 418              	print_str:
 419 0398 130101FF 		addi	sp,sp,-16	#,,
 420 039c 23248100 		sw	s0,8(sp)	#,
 421 03a0 23229100 		sw	s1,4(sp)	#,
 422 03a4 23261100 		sw	ra,12(sp)	#,
 423              	# kianv_stdlib.h:208: void print_str(char *p) {
 424 03a8 13040500 		mv	s0,a0	# p, tmp77
 425              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 426 03ac B7040030 		li	s1,805306368		# tmp76,
 427              	.L39:
 428              	# kianv_stdlib.h:209:   while (*p != 0) {
 429 03b0 03450400 		lbu	a0,0(s0)	# _2, MEM[(char *)p_3]
 430              	# kianv_stdlib.h:209:   while (*p != 0) {
 431 03b4 631C0500 		bne	a0,zero,.L40	#, _2,,
 432              	# kianv_stdlib.h:214: }
 433 03b8 8320C100 		lw	ra,12(sp)		#,
 434 03bc 03248100 		lw	s0,8(sp)		#,
 435 03c0 83244100 		lw	s1,4(sp)		#,
 436 03c4 13010101 		addi	sp,sp,16	#,,
 437 03c8 67800000 		jr	ra		#
 438              	.L40:
 439              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 440 03cc 83A70400 		lw	a5,0(s1)		# _1, MEM[(volatile uint32_t *)805306368B]
 441              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 442 03d0 E38E07FE 		beq	a5,zero,.L40	#, _1,,
 443              	# kianv_stdlib.h:212:     putchar(*(p++));
 444 03d4 13041400 		addi	s0,s0,1	#, p, p
 445              	# kianv_stdlib.h:212:     putchar(*(p++));
 446 03d8 97000000 		call	putchar		#
 446      E7800000 
 447 03e0 6FF01FFD 		j	.L39		#
 449              		.align	2
 450              		.globl	print_str_ln
 452              	print_str_ln:
 453 03e4 130101FF 		addi	sp,sp,-16	#,,
 454 03e8 23261100 		sw	ra,12(sp)	#,
 455              	# kianv_stdlib.h:217:   print_str(p);
 456 03ec 97000000 		call	print_str		#
 456      E7800000 
 457              	# kianv_stdlib.h:219: }
 458 03f4 8320C100 		lw	ra,12(sp)		#,
 459              	# kianv_stdlib.h:201:   putchar(ch);
 460 03f8 1305D000 		li	a0,13		#,
 461              	# kianv_stdlib.h:219: }
 462 03fc 13010101 		addi	sp,sp,16	#,,
 463              	# kianv_stdlib.h:201:   putchar(ch);
 464 0400 17030000 		tail	putchar		#
 464      67000300 
 466              		.align	2
 467              		.globl	print_dec
 469              	print_dec:
 470 0408 130101FF 		addi	sp,sp,-16	#,,
 471              	# kianv_stdlib.h:223:   char *p = buffer;
 472 040c 93074100 		addi	a5,sp,4	#, p,
 473 0410 93860700 		mv	a3,a5	# p, p
 474              	# kianv_stdlib.h:225:     *(p++) = val % 10;
 475 0414 1307A000 		li	a4,10		# tmp93,
 476              	.L48:
 477              	# kianv_stdlib.h:224:   while (val || p == buffer) {
 478 0418 63180502 		bne	a0,zero,.L49	#, val,,
 479              	# kianv_stdlib.h:224:   while (val || p == buffer) {
 480 041c 6386D702 		beq	a5,a3,.L49	#, p, p,
 481              	# kianv_stdlib.h:230:     while (!*((volatile uint32_t*) UART_READY))
 482 0420 37060030 		li	a2,805306368		# tmp88,
 483              	.L50:
 484              	# kianv_stdlib.h:230:     while (!*((volatile uint32_t*) UART_READY))
 485 0424 03270600 		lw	a4,0(a2)		# _3, MEM[(volatile uint32_t *)805306368B]
 486              	# kianv_stdlib.h:230:     while (!*((volatile uint32_t*) UART_READY))
 487 0428 E30E07FE 		beq	a4,zero,.L50	#, _3,,
 488              	# kianv_stdlib.h:232:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 489 042c 03C7F7FF 		lbu	a4,-1(a5)	# MEM[(char *)p_16], MEM[(char *)p_16]
 490              	# kianv_stdlib.h:232:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 491 0430 9387F7FF 		addi	a5,a5,-1	#, p, p
 492              	# kianv_stdlib.h:232:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 493 0434 13070703 		addi	a4,a4,48	#, _7, MEM[(char *)p_16]
 494              	# kianv_stdlib.h:232:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 495 0438 2320E600 		sw	a4,0(a2)	# _7, MEM[(volatile uint32_t *)805306368B]
 496              	# kianv_stdlib.h:229:   while (p != buffer) {
 497 043c E394D7FE 		bne	a5,a3,.L50	#, p, p,
 498              	# kianv_stdlib.h:234: }
 499 0440 13010101 		addi	sp,sp,16	#,,
 500 0444 67800000 		jr	ra		#
 501              	.L49:
 502              	# kianv_stdlib.h:225:     *(p++) = val % 10;
 503 0448 3376E502 		remu	a2,a0,a4	# tmp93, tmp83, val
 504              	# kianv_stdlib.h:225:     *(p++) = val % 10;
 505 044c 93871700 		addi	a5,a5,1	#, p, p
 506              	# kianv_stdlib.h:226:     val = val / 10;
 507 0450 3355E502 		divu	a0,a0,a4	# tmp93, val, val
 508              	# kianv_stdlib.h:225:     *(p++) = val % 10;
 509 0454 A38FC7FE 		sb	a2,-1(a5)	# tmp83, MEM[(char *)p_18 + 4294967295B]
 510 0458 6FF01FFC 		j	.L48		#
 512              		.globl	__umoddi3
 513              		.align	2
 514              		.globl	print_dec64
 516              	print_dec64:
 517 045c 130101FC 		addi	sp,sp,-64	#,,
 518 0460 23282103 		sw	s2,48(sp)	#,
 519              	# kianv_stdlib.h:238:   char *p = buffer;
 520 0464 1309C100 		addi	s2,sp,12	#, p,
 521              	# kianv_stdlib.h:236: void print_dec64(uint64_t val) {
 522 0468 232C8102 		sw	s0,56(sp)	#,
 523 046c 232A9102 		sw	s1,52(sp)	#,
 524 0470 23263103 		sw	s3,44(sp)	#,
 525 0474 232E1102 		sw	ra,60(sp)	#,
 526              	# kianv_stdlib.h:236: void print_dec64(uint64_t val) {
 527 0478 13040500 		mv	s0,a0	# val, tmp102
 528 047c 93840500 		mv	s1,a1	# val, tmp103
 529 0480 93090900 		mv	s3,s2	# p, p
 530              	.L57:
 531              	# kianv_stdlib.h:239:   while (val || p == buffer) {
 532 0484 B3679400 		or	a5,s0,s1	# val, val, val
 533 0488 63920704 		bne	a5,zero,.L58	#, val,,
 534              	# kianv_stdlib.h:239:   while (val || p == buffer) {
 535 048c 63003905 		beq	s2,s3,.L58	#, p, p,
 536              	# kianv_stdlib.h:245:     while (!*((volatile uint32_t*) UART_READY))
 537 0490 37070030 		li	a4,805306368		# tmp93,
 538              	.L59:
 539              	# kianv_stdlib.h:245:     while (!*((volatile uint32_t*) UART_READY))
 540 0494 83270700 		lw	a5,0(a4)		# _3, MEM[(volatile uint32_t *)805306368B]
 541              	# kianv_stdlib.h:245:     while (!*((volatile uint32_t*) UART_READY))
 542 0498 E38E07FE 		beq	a5,zero,.L59	#, _3,,
 543              	# kianv_stdlib.h:247:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 544 049c 8347F9FF 		lbu	a5,-1(s2)	# MEM[(char *)p_16], MEM[(char *)p_16]
 545              	# kianv_stdlib.h:247:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 546 04a0 1309F9FF 		addi	s2,s2,-1	#, p, p
 547              	# kianv_stdlib.h:247:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 548 04a4 93870703 		addi	a5,a5,48	#, _7, MEM[(char *)p_16]
 549              	# kianv_stdlib.h:247:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 550 04a8 2320F700 		sw	a5,0(a4)	# _7, MEM[(volatile uint32_t *)805306368B]
 551              	# kianv_stdlib.h:244:   while (p != buffer) {
 552 04ac E31439FF 		bne	s2,s3,.L59	#, p, p,
 553              	# kianv_stdlib.h:249: }
 554 04b0 8320C103 		lw	ra,60(sp)		#,
 555 04b4 03248103 		lw	s0,56(sp)		#,
 556 04b8 83244103 		lw	s1,52(sp)		#,
 557 04bc 03290103 		lw	s2,48(sp)		#,
 558 04c0 8329C102 		lw	s3,44(sp)		#,
 559 04c4 13010104 		addi	sp,sp,64	#,,
 560 04c8 67800000 		jr	ra		#
 561              	.L58:
 562              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 563 04cc 1306A000 		li	a2,10		#,
 564 04d0 93060000 		li	a3,0		#,
 565 04d4 13050400 		mv	a0,s0	#, val
 566 04d8 93850400 		mv	a1,s1	#, val
 567 04dc 97000000 		call	__umoddi3		#
 567      E7800000 
 568              	# kianv_stdlib.h:241:     val = val / 10;
 569 04e4 93850400 		mv	a1,s1	#, val
 570              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 571 04e8 2300A900 		sb	a0,0(s2)	# tmp104, MEM[(char *)p_18 + 4294967295B]
 572              	# kianv_stdlib.h:241:     val = val / 10;
 573 04ec 1306A000 		li	a2,10		#,
 574 04f0 13050400 		mv	a0,s0	#, val
 575 04f4 93060000 		li	a3,0		#,
 576 04f8 97000000 		call	__udivdi3		#
 576      E7800000 
 577              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 578 0500 13091900 		addi	s2,s2,1	#, p, p
 579              	# kianv_stdlib.h:241:     val = val / 10;
 580 0504 13040500 		mv	s0,a0	# val, tmp106
 581 0508 93840500 		mv	s1,a1	# val, tmp107
 582 050c 6FF09FF7 		j	.L57		#
 584              		.section	.rodata.str1.4,"aMS",@progbits,1
 585              		.align	2
 586              	.LC1:
 587 0000 30313233 		.string	"0123456789ABCDEF"
 587      34353637 
 587      38394142 
 587      43444546 
 587      00
 588              		.text
 589              		.align	2
 590              		.globl	print_hex
 592              	print_hex:
 593              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 594 0510 9385F5FF 		addi	a1,a1,-1	#, tmp81, tmp93
 595              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 596 0514 37070000 		lui	a4,%hi(.LC1)	# tmp90,
 597              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 598 0518 93952500 		slli	a1,a1,2	#, i, tmp81
 599              	# kianv_stdlib.h:253:     while (!*((volatile uint32_t*) UART_READY))
 600 051c B7060030 		li	a3,805306368		# tmp89,
 601              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 602 0520 13070700 		addi	a4,a4,%lo(.LC1)	# tmp91, tmp90,
 603              	.L66:
 604              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 605 0524 63D40500 		bge	a1,zero,.L67	#, i,,
 606              	# kianv_stdlib.h:257: }
 607 0528 67800000 		ret	
 608              	.L67:
 609              	# kianv_stdlib.h:253:     while (!*((volatile uint32_t*) UART_READY))
 610 052c 83A70600 		lw	a5,0(a3)		# _2, MEM[(volatile uint32_t *)805306368B]
 611              	# kianv_stdlib.h:253:     while (!*((volatile uint32_t*) UART_READY))
 612 0530 E38E07FE 		beq	a5,zero,.L67	#, _2,,
 613              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 614 0534 B357B500 		srl	a5,a0,a1	# i, tmp85, val
 615              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 616 0538 93F7F700 		andi	a5,a5,15	#, tmp86, tmp85
 617              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 618 053c B307F700 		add	a5,a4,a5	# tmp86, tmp87, tmp91
 619 0540 83C70700 		lbu	a5,0(a5)	# _6, "0123456789ABCDEF"[_4]
 620              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 621 0544 9385C5FF 		addi	a1,a1,-4	#, i, i
 622              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 623 0548 23A0F600 		sw	a5,0(a3)	# _6, MEM[(volatile uint32_t *)805306368B]
 624 054c 6FF09FFD 		j	.L66		#
 626              		.align	2
 627              		.globl	setpixel
 629              	setpixel:
 630              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 631 0550 B7070100 		li	a5,65536		# tmp88,
 632 0554 9387F7FF 		addi	a5,a5,-1	#, tmp87, tmp88
 633 0558 93958500 		slli	a1,a1,8	#, tmp85, tmp94
 634 055c B3F5F500 		and	a1,a1,a5	# tmp87, tmp86, tmp85
 635              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 636 0560 93960601 		slli	a3,a3,16	#, tmp89, tmp96
 637              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 638 0564 B3E5D500 		or	a1,a1,a3	# tmp89, tmp90, tmp86
 639              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 640 0568 1376F60F 		andi	a2,a2,0xff	# tmp91, tmp95
 641              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 642 056c B3E5C500 		or	a1,a1,a2	# tmp91, _9, tmp90
 643              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 644 0570 B7070030 		li	a5,805306368		# tmp93,
 645 0574 23A4B700 		sw	a1,8(a5)	# _9, MEM[(volatile uint32_t *)805306376B]
 646              	# kianv_stdlib.h:272: }
 647 0578 67800000 		ret	
 649              		.align	2
 650              		.globl	draw_bresenham
 652              	draw_bresenham:
 653 057c 130101FC 		addi	sp,sp,-64	#,,
 654 0580 232E7101 		sw	s7,28(sp)	#,
 655 0584 930B0500 		mv	s7,a0	# fb, tmp101
 656              	# kianv_stdlib.h:277:   int dx =  abs(x1 - x0);
 657 0588 3385B640 		sub	a0,a3,a1	#, x1, x0
 658              	# kianv_stdlib.h:275: {
 659 058c 232C8102 		sw	s0,56(sp)	#,
 660 0590 232A9102 		sw	s1,52(sp)	#,
 661 0594 23263103 		sw	s3,44(sp)	#,
 662 0598 23225103 		sw	s5,36(sp)	#,
 663 059c 23206103 		sw	s6,32(sp)	#,
 664 05a0 232C8101 		sw	s8,24(sp)	#,
 665 05a4 2328A101 		sw	s10,16(sp)	#,
 666 05a8 232E1102 		sw	ra,60(sp)	#,
 667 05ac 23282103 		sw	s2,48(sp)	#,
 668 05b0 23244103 		sw	s4,40(sp)	#,
 669 05b4 232A9101 		sw	s9,20(sp)	#,
 670 05b8 2326B101 		sw	s11,12(sp)	#,
 671              	# kianv_stdlib.h:275: {
 672 05bc 93840500 		mv	s1,a1	# x0, tmp102
 673 05c0 13040600 		mv	s0,a2	# y0, tmp103
 674 05c4 938A0600 		mv	s5,a3	# x1, tmp104
 675 05c8 130B0700 		mv	s6,a4	# y1, tmp105
 676 05cc 138C0700 		mv	s8,a5	# color, tmp106
 677              	# kianv_stdlib.h:277:   int dx =  abs(x1 - x0);
 678 05d0 97000000 		call	abs		#
 678      E7800000 
 679 05d8 93090500 		mv	s3,a0	# dx, tmp107
 680              	# kianv_stdlib.h:278:   int sx = x0 < x1 ? 1 : -1;
 681 05dc 130DF0FF 		li	s10,-1		# iftmp.6_9,
 682 05e0 63D45401 		ble	s5,s1,.L73	#, x1, x0,
 683 05e4 130D1000 		li	s10,1		# iftmp.6_9,
 684              	.L73:
 685              	# kianv_stdlib.h:279:   int dy = -abs(y1 - y0);
 686 05e8 33058B40 		sub	a0,s6,s0	#, y1, y0
 687 05ec 97000000 		call	abs		#
 687      E7800000 
 688 05f4 130A0500 		mv	s4,a0	# _3, tmp108
 689              	# kianv_stdlib.h:279:   int dy = -abs(y1 - y0);
 690 05f8 B30DA040 		neg	s11,a0	# dy, _3
 691              	# kianv_stdlib.h:280:   int sy = y0 < y1 ? 1 : -1;
 692 05fc 930C1000 		li	s9,1		# iftmp.7_10,
 693 0600 63446401 		bgt	s6,s0,.L74	#, y1, y0,
 694              	# kianv_stdlib.h:280:   int sy = y0 < y1 ? 1 : -1;
 695 0604 930CF0FF 		li	s9,-1		# iftmp.7_10,
 696              	.L74:
 697 0608 33894941 		sub	s2,s3,s4	# err, dx, _3
 698              	.L75:
 699              	# kianv_stdlib.h:284:     setpixel(fb, x0, y0, color);
 700 060c 93060C00 		mv	a3,s8	#, color
 701 0610 13060400 		mv	a2,s0	#, y0
 702 0614 93850400 		mv	a1,s1	#, x0
 703 0618 13850B00 		mv	a0,s7	#, fb
 704 061c 97000000 		call	setpixel		#
 704      E7800000 
 705              	# kianv_stdlib.h:285:     if (x0 == x1 && y0 == y1) break;
 706 0624 63945401 		bne	s1,s5,.L76	#, x0, x1,
 707              	# kianv_stdlib.h:285:     if (x0 == x1 && y0 == y1) break;
 708 0628 63026403 		beq	s0,s6,.L72	#, y0, y1,
 709              	.L76:
 710              	# kianv_stdlib.h:286:     e2 = 2*err;
 711 062c 93171900 		slli	a5,s2,1	#, e2, err
 712              	# kianv_stdlib.h:287:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 713 0630 63C6B701 		bgt	s11,a5,.L78	#, dy, e2,
 714 0634 33094941 		sub	s2,s2,s4	# err, err, _3
 715              	# kianv_stdlib.h:287:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 716 0638 B384A401 		add	s1,s1,s10	# iftmp.6_9, x0, x0
 717              	.L78:
 718              	# kianv_stdlib.h:288:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 719 063c E3C8F9FC 		blt	s3,a5,.L75	#, dx, e2,
 720              	# kianv_stdlib.h:288:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 721 0640 33093901 		add	s2,s2,s3	# dx, err, err
 722              	# kianv_stdlib.h:288:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 723 0644 33049401 		add	s0,s0,s9	# iftmp.7_10, y0, y0
 724 0648 6FF05FFC 		j	.L75		#
 725              	.L72:
 726              	# kianv_stdlib.h:290: }
 727 064c 8320C103 		lw	ra,60(sp)		#,
 728 0650 03248103 		lw	s0,56(sp)		#,
 729 0654 83244103 		lw	s1,52(sp)		#,
 730 0658 03290103 		lw	s2,48(sp)		#,
 731 065c 8329C102 		lw	s3,44(sp)		#,
 732 0660 032A8102 		lw	s4,40(sp)		#,
 733 0664 832A4102 		lw	s5,36(sp)		#,
 734 0668 032B0102 		lw	s6,32(sp)		#,
 735 066c 832BC101 		lw	s7,28(sp)		#,
 736 0670 032C8101 		lw	s8,24(sp)		#,
 737 0674 832C4101 		lw	s9,20(sp)		#,
 738 0678 032D0101 		lw	s10,16(sp)		#,
 739 067c 832DC100 		lw	s11,12(sp)		#,
 740 0680 13010104 		addi	sp,sp,64	#,,
 741 0684 67800000 		jr	ra		#
 743              		.align	2
 744              		.globl	time
 746              	time:
 747              	# stdlib.c:33: 	asm volatile ("rdcycle %0" : "=r"(cycles));
 748              	 #APP
 749              	# 33 "stdlib.c" 1
   1              	// This is free and unencumbered software released into the public domain.
   2              	//
   3              	// Anyone is free to copy, modify, publish, use, compile, sell, or
   4              	// distribute this software, either in source code form or as a compiled
   5              	// binary, for any purpose, commercial or non-commercial, and by any
   6              	// means.
   7              	
   8              	#ifndef KV_STDLIB_H
   9              	#define KV_STDLIB_H
  10              	
  11              	#include <stdarg.h>
  12              	#include <stdint.h>
  13              	#include "kianv_stdlib.h"
  14              	extern long time();
  15              	extern long insn();
  16              	
  17              	#if defined(NOT_USE_MYSTDLIB)
  18              	#else
  19              	extern char *malloc();
  20              	extern int printf(const char *format, ...);
  21              	
  22              	extern void *memcpy(void *dest, const void *src, long n);
  23              	extern char *strcpy(char *dest, const char *src);
  24              	extern int strcmp(const char *s1, const char *s2);
  25              	
  26              	char heap_memory[1024];
  27              	int heap_memory_used = 0;
  28              	#endif
  29              	
  30              	long time()
  31              	{
  32              		int cycles;
  33 0688 732500C0 		asm volatile ("rdcycle %0" : "=r"(cycles));
  34              		// printf("[time() -> %d]", cycles);
 750              		rdcycle a0	# cycles
 751              	# 0 "" 2
 752              	# stdlib.c:36: }
 753              	 #NO_APP
 754 068c 67800000 		ret	
 756              		.align	2
 757              		.globl	insn
 759              	insn:
 760              	# stdlib.c:41: 	asm volatile ("rdinstret %0" : "=r"(insns));
 761              	 #APP
 762              	# 41 "stdlib.c" 1
  35              		return cycles;
  36              	}
  37              	
  38              	long insn()
  39              	{
  40              		int insns;
  41 0690 732520C0 		asm volatile ("rdinstret %0" : "=r"(insns));
  42              		// printf("[insn() -> %d]", insns);
 763              		rdinstret a0	# insns
 764              	# 0 "" 2
 765              	# stdlib.c:44: }
 766              	 #NO_APP
 767 0694 67800000 		ret	
 769              		.align	2
 770              		.globl	printf
 772              	printf:
 773 0698 130101F8 		addi	sp,sp,-128	#,,
 774 069c 232AF106 		sw	a5,116(sp)	#,
 775              	# stdlib.c:94: 	va_start(ap, format);
 776 06a0 93074106 		addi	a5,sp,100	#, tmp107,
 777              	# stdlib.c:90: {
 778 06a4 23282105 		sw	s2,80(sp)	#,
 779 06a8 23263105 		sw	s3,76(sp)	#,
 780 06ac 23244105 		sw	s4,72(sp)	#,
 781 06b0 23225105 		sw	s5,68(sp)	#,
 782 06b4 23206105 		sw	s6,64(sp)	#,
 783 06b8 232E7103 		sw	s7,60(sp)	#,
 784 06bc 232E1104 		sw	ra,92(sp)	#,
 785 06c0 232C8104 		sw	s0,88(sp)	#,
 786 06c4 232A9104 		sw	s1,84(sp)	#,
 787 06c8 232C8103 		sw	s8,56(sp)	#,
 788              	# stdlib.c:90: {
 789 06cc 93090500 		mv	s3,a0	# format, tmp175
 790 06d0 2322B106 		sw	a1,100(sp)	#,
 791 06d4 2324C106 		sw	a2,104(sp)	#,
 792 06d8 2326D106 		sw	a3,108(sp)	#,
 793 06dc 2328E106 		sw	a4,112(sp)	#,
 794 06e0 232C0107 		sw	a6,120(sp)	#,
 795 06e4 232E1107 		sw	a7,124(sp)	#,
 796              	# stdlib.c:94: 	va_start(ap, format);
 797 06e8 2326F100 		sw	a5,12(sp)	# tmp107, MEM[(void * *)&ap]
 798              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 799 06ec 13090000 		li	s2,0		# i,
 800              	# stdlib.c:99: 				if (format[i] == 'c') {
 801 06f0 130A3006 		li	s4,99		# tmp167,
 802              	# stdlib.c:103: 				if (format[i] == 's') {
 803 06f4 930A3007 		li	s5,115		# tmp168,
 804              	# stdlib.c:107: 				if (format[i] == 'd') {
 805 06f8 130B4006 		li	s6,100		# tmp169,
 806              	# stdlib.c:111: 				if (format[i] == 'u') {
 807 06fc 930B5007 		li	s7,117		# tmp170,
 808              	.L87:
 809              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 810 0700 B3872901 		add	a5,s3,s2	# i, tmp157, format
 811 0704 03C50700 		lbu	a0,0(a5)	# _14, *_13
 812              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 813 0708 631A0502 		bne	a0,zero,.L104	#, _14,,
 814              	# stdlib.c:121: }
 815 070c 8320C105 		lw	ra,92(sp)		#,
 816 0710 03248105 		lw	s0,88(sp)		#,
 817 0714 83244105 		lw	s1,84(sp)		#,
 818 0718 03290105 		lw	s2,80(sp)		#,
 819 071c 8329C104 		lw	s3,76(sp)		#,
 820 0720 032A8104 		lw	s4,72(sp)		#,
 821 0724 832A4104 		lw	s5,68(sp)		#,
 822 0728 032B0104 		lw	s6,64(sp)		#,
 823 072c 832BC103 		lw	s7,60(sp)		#,
 824 0730 032C8103 		lw	s8,56(sp)		#,
 825 0734 13010108 		addi	sp,sp,128	#,,
 826 0738 67800000 		jr	ra		#
 827              	.L104:
 828              	# stdlib.c:97: 		if (format[i] == '%') {
 829 073c 93075002 		li	a5,37		# tmp108,
 830 0740 6314F502 		bne	a0,a5,.L109	#, _14, tmp108,
 831              	.L88:
 832              	# stdlib.c:98: 			while (format[++i]) {
 833 0744 13091900 		addi	s2,s2,1	#, i, i
 834              	# stdlib.c:98: 			while (format[++i]) {
 835 0748 B3872901 		add	a5,s3,s2	# i, tmp156, format
 836 074c 83C70700 		lbu	a5,0(a5)	# _10, MEM[(const char *)_27]
 837              	# stdlib.c:98: 			while (format[++i]) {
 838 0750 63800704 		beq	a5,zero,.L91	#, _10,,
 839              	# stdlib.c:99: 				if (format[i] == 'c') {
 840 0754 63904703 		bne	a5,s4,.L90	#, _10, tmp167,
 841              	# stdlib.c:100: 					printf_c(va_arg(ap,int));
 842 0758 8327C100 		lw	a5,12(sp)		# D.2544, ap
 843              	# kianv_stdlib.h:201:   putchar(ch);
 844 075c 03C50700 		lbu	a0,0(a5)	#, MEM[(int *)_98]
 845              	# stdlib.c:100: 					printf_c(va_arg(ap,int));
 846 0760 13874700 		addi	a4,a5,4	#, D.2545, D.2544
 847 0764 2326E100 		sw	a4,12(sp)	# D.2545, ap
 848              	.L109:
 849              	# kianv_stdlib.h:201:   putchar(ch);
 850 0768 97000000 		call	putchar		#
 850      E7800000 
 851              	# stdlib.c:50: }
 852 0770 6F000002 		j	.L91		#
 853              	.L90:
 854              	# stdlib.c:103: 				if (format[i] == 's') {
 855 0774 639A5703 		bne	a5,s5,.L92	#, _10, tmp168,
 856              	# stdlib.c:104: 					printf_s(va_arg(ap,char*));
 857 0778 8327C100 		lw	a5,12(sp)		# D.2546, ap
 858 077c 03A40700 		lw	s0,0(a5)		# p, MEM[(char * *)_67]
 859 0780 13874700 		addi	a4,a5,4	#, D.2547, D.2546
 860 0784 2326E100 		sw	a4,12(sp)	# D.2547, ap
 861              	.L93:
 862              	# stdlib.c:54: 	while (*p)
 863 0788 03450400 		lbu	a0,0(s0)	# _39, MEM[(char *)p_37]
 864 078c 63160500 		bne	a0,zero,.L94	#, _39,,
 865              	.L91:
 866              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 867 0790 13091900 		addi	s2,s2,1	#, i, i
 868 0794 6FF0DFF6 		j	.L87		#
 869              	.L94:
 870              	# stdlib.c:56:     print_chr(*(p++));
 871 0798 13041400 		addi	s0,s0,1	#, p, p
 872              	# kianv_stdlib.h:201:   putchar(ch);
 873 079c 97000000 		call	putchar		#
 873      E7800000 
 874              	# kianv_stdlib.h:202: }
 875 07a4 6FF05FFE 		j	.L93		#
 876              	.L92:
 877              	# stdlib.c:107: 				if (format[i] == 'd') {
 878 07a8 63966707 		bne	a5,s6,.L95	#, _10, tmp169,
 879              	# stdlib.c:108: 					printf_d(va_arg(ap,int));
 880 07ac 8327C100 		lw	a5,12(sp)		# D.2548, ap
 881 07b0 83A40700 		lw	s1,0(a5)		# val, MEM[(int *)_99]
 882 07b4 13874700 		addi	a4,a5,4	#, D.2549, D.2548
 883 07b8 2326E100 		sw	a4,12(sp)	# D.2549, ap
 884              	# stdlib.c:63: 	if (val < 0) {
 885 07bc 63DA0400 		bge	s1,zero,.L96	#, val,,
 886              	# kianv_stdlib.h:201:   putchar(ch);
 887 07c0 1305D002 		li	a0,45		#,
 888 07c4 97000000 		call	putchar		#
 888      E7800000 
 889              	# stdlib.c:65: 		val = -val;
 890 07cc B3049040 		neg	s1,s1	# val, val
 891              	.L96:
 892              	# stdlib.c:90: {
 893 07d0 13040101 		addi	s0,sp,16	#, p,
 894 07d4 130C0400 		mv	s8,s0	# p, p
 895              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 896 07d8 1307A000 		li	a4,10		# tmp161,
 897              	.L97:
 898              	# stdlib.c:67: 	while (val || p == buffer) {
 899 07dc 63900402 		bne	s1,zero,.L98	#, val,,
 900 07e0 630E8401 		beq	s0,s8,.L98	#, p, p,
 901              	.L99:
 902              	# kianv_stdlib.h:201:   putchar(ch);
 903 07e4 0345F4FF 		lbu	a0,-1(s0)	#, MEM[(char *)p_49]
 904              	# stdlib.c:72: 		printf_c(*(--p));
 905 07e8 1304F4FF 		addi	s0,s0,-1	#, p, p
 906              	# kianv_stdlib.h:201:   putchar(ch);
 907 07ec 97000000 		call	putchar		#
 907      E7800000 
 908              	# stdlib.c:71: 	while (p != buffer)
 909 07f4 E31884FF 		bne	s0,s8,.L99	#, p, p,
 910 07f8 6FF09FF9 		j	.L91		#
 911              	.L98:
 912              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 913 07fc B3E7E402 		rem	a5,s1,a4	# tmp161, tmp122, val
 914              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 915 0800 13041400 		addi	s0,s0,1	#, p, p
 916              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 917 0804 93870703 		addi	a5,a5,48	#, tmp124, tmp122
 918              	# stdlib.c:69: 		val = val / 10;
 919 0808 B3C4E402 		div	s1,s1,a4	# tmp161, val, val
 920              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 921 080c A30FF4FE 		sb	a5,-1(s0)	# tmp124, MEM[(char *)p_45 + 4294967295B]
 922 0810 6FF0DFFC 		j	.L97		#
 923              	.L95:
 924              	# stdlib.c:111: 				if (format[i] == 'u') {
 925 0814 E39877F3 		bne	a5,s7,.L88	#, _10, tmp170,
 926              	# stdlib.c:112: 					printf_u(va_arg(ap,int));
 927 0818 8327C100 		lw	a5,12(sp)		# D.2550, ap
 928              	# stdlib.c:78: 	char *p = buffer;
 929 081c 13040101 		addi	s0,sp,16	#, p,
 930 0820 93040400 		mv	s1,s0	# p, p
 931              	# stdlib.c:112: 					printf_u(va_arg(ap,int));
 932 0824 13874700 		addi	a4,a5,4	#, D.2551, D.2550
 933              	# stdlib.c:80:   val = val >= 0 ? val : -val;
 934 0828 83A70700 		lw	a5,0(a5)		# MEM[(int *)_102], MEM[(int *)_102]
 935              	# stdlib.c:112: 					printf_u(va_arg(ap,int));
 936 082c 2326E100 		sw	a4,12(sp)	# D.2551, ap
 937              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 938 0830 9306A000 		li	a3,10		# tmp162,
 939              	# stdlib.c:80:   val = val >= 0 ? val : -val;
 940 0834 13D7F741 		srai	a4,a5,31	#, tmp136, MEM[(int *)_102]
 941 0838 B347F700 		xor	a5,a4,a5	# MEM[(int *)_102], val, tmp136
 942 083c B387E740 		sub	a5,a5,a4	# val, val, tmp136
 943              	.L100:
 944              	# stdlib.c:81: 	while (val || p == buffer) {
 945 0840 63900702 		bne	a5,zero,.L101	#, val,,
 946 0844 630E9400 		beq	s0,s1,.L101	#, p, p,
 947              	.L102:
 948              	# kianv_stdlib.h:201:   putchar(ch);
 949 0848 0345F4FF 		lbu	a0,-1(s0)	#, MEM[(char *)p_62]
 950              	# stdlib.c:86: 		printf_c(*(--p));
 951 084c 1304F4FF 		addi	s0,s0,-1	#, p, p
 952              	# kianv_stdlib.h:201:   putchar(ch);
 953 0850 97000000 		call	putchar		#
 953      E7800000 
 954              	# stdlib.c:85: 	while (p != buffer)
 955 0858 E31894FE 		bne	s0,s1,.L102	#, p, p,
 956 085c 6FF05FF3 		j	.L91		#
 957              	.L101:
 958              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 959 0860 33E7D702 		rem	a4,a5,a3	# tmp162, tmp144, val
 960              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 961 0864 13041400 		addi	s0,s0,1	#, p, p
 962              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 963 0868 13070703 		addi	a4,a4,48	#, tmp146, tmp144
 964              	# stdlib.c:83: 		val = val / 10;
 965 086c B3C7D702 		div	a5,a5,a3	# tmp162, val, val
 966              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 967 0870 A30FE4FE 		sb	a4,-1(s0)	# tmp146, MEM[(char *)p_58 + 4294967295B]
 968 0874 6FF0DFFC 		j	.L100		#
 970              		.align	2
 971              		.globl	malloc
 973              	malloc:
 974              	# stdlib.c:126: 	char *p = heap_memory + heap_memory_used;
 975 0878 B7060000 		lui	a3,%hi(heap_memory_used)	# tmp77,
 976 087c 03A70600 		lw	a4,%lo(heap_memory_used)(a3)		# heap_memory_used.19_1, heap_memory_used
 977              	# stdlib.c:126: 	char *p = heap_memory + heap_memory_used;
 978 0880 B7070000 		lui	a5,%hi(.LANCHOR0)	# tmp79,
 979 0884 93870700 		addi	a5,a5,%lo(.LANCHOR0)	# tmp78, tmp79,
 980 0888 B387E700 		add	a5,a5,a4	# heap_memory_used.19_1, <retval>, tmp78
 981              	# stdlib.c:128: 	heap_memory_used += size;
 982 088c 3307A700 		add	a4,a4,a0	# tmp83, _3, heap_memory_used.19_1
 983 0890 23A0E600 		sw	a4,%lo(heap_memory_used)(a3)	# _3, heap_memory_used
 984              	# stdlib.c:129: 	if (heap_memory_used > 1024)
 985 0894 93060040 		li	a3,1024		# tmp81,
 986 0898 63D4E600 		ble	a4,a3,.L111	#, _3, tmp81,
 987              	# stdlib.c:130: 		asm volatile ("ebreak");
 988              	 #APP
 989              	# 130 "stdlib.c" 1
  43              		return insns;
  44              	}
  45              	
  46              	static void printf_c(int c)
  47              	{
  48              		//*((volatile int*)0x10000000) = c;
  49              	    print_chr(c);
  50              	}
  51              	
  52              	static void printf_s(char *p)
  53              	{
  54              		while (*p)
  55              			//*((volatile int*)0x10000000) = *(p++);
  56              	    print_chr(*(p++));
  57              	}
  58              	
  59              	static void printf_d(int val)
  60              	{
  61              		char buffer[32];
  62              		char *p = buffer;
  63              		if (val < 0) {
  64              			printf_c('-');
  65              			val = -val;
  66              		}
  67              		while (val || p == buffer) {
  68              			*(p++) = '0' + val % 10;
  69              			val = val / 10;
  70              		}
  71              		while (p != buffer)
  72              			printf_c(*(--p));
  73              	}
  74              	
  75              	static void printf_u(int val)
  76              	{
  77              		char buffer[32];
  78              		char *p = buffer;
  79              	
  80              	  val = val >= 0 ? val : -val;
  81              		while (val || p == buffer) {
  82              			*(p++) = '0' + val % 10;
  83              			val = val / 10;
  84              		}
  85              		while (p != buffer)
  86              			printf_c(*(--p));
  87              	}
  88              	
  89              	int printf(const char *format, ...)
  90              	{
  91              		int i;
  92              		va_list ap;
  93              	
  94              		va_start(ap, format);
  95              	
  96              		for (i = 0; format[i]; i++)
  97              			if (format[i] == '%') {
  98              				while (format[++i]) {
  99              					if (format[i] == 'c') {
 100              						printf_c(va_arg(ap,int));
 101              						break;
 102              					}
 103              					if (format[i] == 's') {
 104              						printf_s(va_arg(ap,char*));
 105              						break;
 106              					}
 107              					if (format[i] == 'd') {
 108              						printf_d(va_arg(ap,int));
 109              						break;
 110              					}
 111              					if (format[i] == 'u') {
 112              						printf_u(va_arg(ap,int));
 113              						break;
 114              					}
 115              				}
 116              			} else
 117              				printf_c(format[i]);
 118              	
 119              		va_end(ap);
 120              	  return 0;
 121              	}
 122              	
 123              	#if !defined(NOT_USE_MYSTDLIB)
 124              	char *malloc(int size)
 125              	{
 126              		char *p = heap_memory + heap_memory_used;
 127              		// printf("[malloc(%d) -> %d (%d..%d)]", size, (int)p, heap_memory_used, heap_memory_used + size);
 128              		heap_memory_used += size;
 129              		if (heap_memory_used > 1024)
 130 089c 73001000 			asm volatile ("ebreak");
 131              		return p;
 990              		ebreak
 991              	# 0 "" 2
 992              	 #NO_APP
 993              	.L111:
 994              	# stdlib.c:132: }
 995 08a0 13850700 		mv	a0,a5	#, <retval>
 996 08a4 67800000 		ret	
 998              		.align	2
 999              		.globl	memcpy
 1001              	memcpy:
 1002              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1003 08a8 93070000 		li	a5,0		# ivtmp.299,
 1004              	.L114:
 1005              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1006 08ac 6394C700 		bne	a5,a2,.L115	#, ivtmp.299, _16,
 1007              	# stdlib.c:142: }
 1008 08b0 67800000 		ret	
 1009              	.L115:
 1010              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1011 08b4 3387F500 		add	a4,a1,a5	# ivtmp.299, tmp81, bb
 1012 08b8 83460700 		lbu	a3,0(a4)	# _1, MEM[(const char *)_17]
 1013              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1014 08bc 3307F500 		add	a4,a0,a5	# ivtmp.299, tmp82, aa
 1015 08c0 93871700 		addi	a5,a5,1	#, ivtmp.299, ivtmp.299
 1016 08c4 2300D700 		sb	a3,0(a4)	# _1, MEM[(char *)_18]
 1017 08c8 6FF05FFE 		j	.L114		#
 1019              		.align	2
 1020              		.globl	strcpy
 1022              	strcpy:
 1023              	# stdlib.c:148: 	while ((((uint32_t)dst | (uint32_t)src) & 3) != 0)
 1024 08cc 93070500 		mv	a5,a0	# dst, dst
 1025              	.L117:
 1026              	# stdlib.c:148: 	while ((((uint32_t)dst | (uint32_t)src) & 3) != 0)
 1027 08d0 33E7B700 		or	a4,a5,a1	# src, tmp96, dst
 1028              	# stdlib.c:148: 	while ((((uint32_t)dst | (uint32_t)src) & 3) != 0)
 1029 08d4 13773700 		andi	a4,a4,3	#, tmp97, tmp96
 1030              	# stdlib.c:148: 	while ((((uint32_t)dst | (uint32_t)src) & 3) != 0)
 1031 08d8 63120706 		bne	a4,zero,.L119	#, tmp97,,
 1032              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1033 08dc 3706FFFE 		li	a2,-16842752		# tmp100,
 1034              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1035 08e0 37888080 		li	a6,-2139062272		# tmp105,
 1036              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1037 08e4 1306F6EF 		addi	a2,a2,-257	#, tmp99, tmp100
 1038              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1039 08e8 13080808 		addi	a6,a6,128	#, tmp104, tmp105
 1040              	.L122:
 1041              	# stdlib.c:157: 		uint32_t v = *(uint32_t*)src;
 1042 08ec 03A70500 		lw	a4,0(a1)		# v, MEM[(uint32_t *)src_21]
 1043              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1044 08f0 B306C700 		add	a3,a4,a2	# tmp99, tmp98, v
 1045              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1046 08f4 9348F7FF 		not	a7,a4	# tmp101, v
 1047              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1048 08f8 B3F61601 		and	a3,a3,a7	# tmp101, tmp102, tmp98
 1049              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1050 08fc B3F60601 		and	a3,a3,a6	# tmp104, tmp103, tmp102
 1051              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1052 0900 638A0604 		beq	a3,zero,.L120	#, tmp103,,
 1053              	# stdlib.c:161: 			dst[0] = v & 0xff;
 1054 0904 2380E700 		sb	a4,0(a5)	# v, *dst_19
 1055              	# stdlib.c:162: 			if ((v & 0xff) == 0)
 1056 0908 9376F70F 		andi	a3,a4,255	#, tmp106, v
 1057              	# stdlib.c:162: 			if ((v & 0xff) == 0)
 1058 090c 63820604 		beq	a3,zero,.L121	#, tmp106,,
 1059              	# stdlib.c:164: 			v = v >> 8;
 1060 0910 93568700 		srli	a3,a4,8	#, v, v
 1061              	# stdlib.c:166: 			dst[1] = v & 0xff;
 1062 0914 A380D700 		sb	a3,1(a5)	# v, MEM[(char *)dst_19 + 1B]
 1063              	# stdlib.c:167: 			if ((v & 0xff) == 0)
 1064 0918 93F6F60F 		andi	a3,a3,255	#, tmp107, v
 1065              	# stdlib.c:167: 			if ((v & 0xff) == 0)
 1066 091c 638A0602 		beq	a3,zero,.L121	#, tmp107,,
 1067              	# stdlib.c:169: 			v = v >> 8;
 1068 0920 93560701 		srli	a3,a4,16	#, v, v
 1069              	# stdlib.c:171: 			dst[2] = v & 0xff;
 1070 0924 2381D700 		sb	a3,2(a5)	# v, MEM[(char *)dst_19 + 2B]
 1071              	# stdlib.c:172: 			if ((v & 0xff) == 0)
 1072 0928 93F6F60F 		andi	a3,a3,255	#, tmp108, v
 1073              	# stdlib.c:172: 			if ((v & 0xff) == 0)
 1074 092c 63820602 		beq	a3,zero,.L121	#, tmp108,,
 1075              	# stdlib.c:174: 			v = v >> 8;
 1076 0930 13578701 		srli	a4,a4,24	#, v, v
 1077              	# stdlib.c:176: 			dst[3] = v & 0xff;
 1078 0934 A381E700 		sb	a4,3(a5)	# v, MEM[(char *)dst_19 + 3B]
 1079              	# stdlib.c:177: 			return r;
 1080 0938 67800000 		ret	
 1081              	.L119:
 1082              	# stdlib.c:150: 		char c = *(src++);
 1083 093c 03C70500 		lbu	a4,0(a1)	# c, MEM[(const char *)src_40 + 4294967295B]
 1084              	# stdlib.c:150: 		char c = *(src++);
 1085 0940 93851500 		addi	a1,a1,1	#, src, src
 1086              	# stdlib.c:151: 		*(dst++) = c;
 1087 0944 93871700 		addi	a5,a5,1	#, dst, dst
 1088              	# stdlib.c:151: 		*(dst++) = c;
 1089 0948 A38FE7FE 		sb	a4,-1(a5)	# c, MEM[(char *)dst_42 + 4294967295B]
 1090              	# stdlib.c:152: 		if (!c) return r;
 1091 094c E31207F8 		bne	a4,zero,.L117	#, c,,
 1092              	.L121:
 1093              	# stdlib.c:184: }
 1094 0950 67800000 		ret	
 1095              	.L120:
 1096              	# stdlib.c:180: 		*(uint32_t*)dst = v;
 1097 0954 23A0E700 		sw	a4,0(a5)	# v, MEM[(uint32_t *)dst_19]
 1098              	# stdlib.c:181: 		src += 4;
 1099 0958 93854500 		addi	a1,a1,4	#, src, src
 1100              	# stdlib.c:182: 		dst += 4;
 1101 095c 93874700 		addi	a5,a5,4	#, dst, dst
 1102              	# stdlib.c:156: 	{
 1103 0960 6FF0DFF8 		j	.L122		#
 1105              		.align	2
 1106              		.globl	strcmp
 1108              	strcmp:
 1109              	.L136:
 1110              	# stdlib.c:188: 	while ((((uint32_t)s1 | (uint32_t)s2) & 3) != 0)
 1111 0964 B367B500 		or	a5,a0,a1	# s2, tmp101, s1
 1112              	# stdlib.c:188: 	while ((((uint32_t)s1 | (uint32_t)s2) & 3) != 0)
 1113 0968 93F73700 		andi	a5,a5,3	#, tmp102, tmp101
 1114              	# stdlib.c:188: 	while ((((uint32_t)s1 | (uint32_t)s2) & 3) != 0)
 1115 096c 639E0702 		bne	a5,zero,.L140	#, tmp102,,
 1116              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1117 0970 B706FFFE 		li	a3,-16842752		# tmp156,
 1118              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1119 0974 37868080 		li	a2,-2139062272		# tmp158,
 1120              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1121 0978 9386F6EF 		addi	a3,a3,-257	#, tmp157, tmp156
 1122              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1123 097c 13060608 		addi	a2,a2,128	#, tmp159, tmp158
 1124              	.L145:
 1125              	# stdlib.c:201: 		uint32_t v1 = *(uint32_t*)s1;
 1126 0980 83270500 		lw	a5,0(a0)		# v1, MEM[(uint32_t *)s1_15]
 1127              	# stdlib.c:202: 		uint32_t v2 = *(uint32_t*)s2;
 1128 0984 03A70500 		lw	a4,0(a1)		# v2, MEM[(uint32_t *)s2_17]
 1129              	# stdlib.c:204: 		if (__builtin_expect(v1 != v2, 0))
 1130 0988 6384E70A 		beq	a5,a4,.L141	#, v1, v2,
 1131              	# stdlib.c:208: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1132 098c 93F6F70F 		andi	a3,a5,0xff	# c1, v1
 1133              	# stdlib.c:208: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1134 0990 1376F70F 		andi	a2,a4,0xff	# c2, v2
 1135              	# stdlib.c:209: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1136 0994 6382C604 		beq	a3,a2,.L142	#, c1, c2,
 1137              	.L159:
 1138              	# stdlib.c:194: 			return c1 < c2 ? -1 : +1;
 1139 0998 13051000 		li	a0,1		# <retval>,
 1140              	# stdlib.c:219: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1141 099c 63F8C608 		bgeu	a3,a2,.L135	#, c1, c2,
 1142              	.L157:
 1143              	# stdlib.c:194: 			return c1 < c2 ? -1 : +1;
 1144 09a0 1305F0FF 		li	a0,-1		# <retval>,
 1145 09a4 67800000 		ret	
 1146              	.L140:
 1147              	# stdlib.c:190: 		char c1 = *(s1++);
 1148 09a8 83470500 		lbu	a5,0(a0)	# c1, MEM[(const char *)s1_48 + 4294967295B]
 1149              	# stdlib.c:191: 		char c2 = *(s2++);
 1150 09ac 03C70500 		lbu	a4,0(a1)	# c2, MEM[(const char *)s2_50 + 4294967295B]
 1151              	# stdlib.c:190: 		char c1 = *(s1++);
 1152 09b0 13051500 		addi	a0,a0,1	#, s1, s1
 1153              	# stdlib.c:191: 		char c2 = *(s2++);
 1154 09b4 93851500 		addi	a1,a1,1	#, s2, s2
 1155              	# stdlib.c:193: 		if (c1 != c2)
 1156 09b8 638AE700 		beq	a5,a4,.L137	#, c1, c2,
 1157              	# stdlib.c:194: 			return c1 < c2 ? -1 : +1;
 1158 09bc 1305F0FF 		li	a0,-1		# <retval>,
 1159 09c0 63E6E706 		bltu	a5,a4,.L135	#, c1, c2,
 1160 09c4 13051000 		li	a0,1		# <retval>,
 1161 09c8 67800000 		ret	
 1162              	.L137:
 1163              	# stdlib.c:195: 		else if (!c1)
 1164 09cc E39C07F8 		bne	a5,zero,.L136	#, c1,,
 1165              	.L155:
 1166              	# stdlib.c:196: 			return 0;
 1167 09d0 13050000 		li	a0,0		# <retval>,
 1168 09d4 6F008005 		j	.L135		#
 1169              	.L142:
 1170 09d8 13050000 		li	a0,0		# <retval>,
 1171              	# stdlib.c:210: 			if (!c1) return 0;
 1172 09dc 63880604 		beq	a3,zero,.L135	#, c1,,
 1173              	# stdlib.c:211: 			v1 = v1 >> 8, v2 = v2 >> 8;
 1174 09e0 93D68700 		srli	a3,a5,8	#, v1, v1
 1175              	# stdlib.c:211: 			v1 = v1 >> 8, v2 = v2 >> 8;
 1176 09e4 13568700 		srli	a2,a4,8	#, v2, v2
 1177              	# stdlib.c:213: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1178 09e8 93F6F60F 		andi	a3,a3,0xff	# c1, v1
 1179              	# stdlib.c:213: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1180 09ec 1376F60F 		andi	a2,a2,0xff	# c2, v2
 1181              	# stdlib.c:214: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1182 09f0 E394C6FA 		bne	a3,a2,.L159	#, c1, c2,
 1183              	# stdlib.c:196: 			return 0;
 1184 09f4 13050000 		li	a0,0		# <retval>,
 1185              	# stdlib.c:215: 			if (!c1) return 0;
 1186 09f8 638A0602 		beq	a3,zero,.L135	#, c1,,
 1187              	# stdlib.c:216: 			v1 = v1 >> 8, v2 = v2 >> 8;
 1188 09fc 93D60701 		srli	a3,a5,16	#, v1, v1
 1189              	# stdlib.c:216: 			v1 = v1 >> 8, v2 = v2 >> 8;
 1190 0a00 13560701 		srli	a2,a4,16	#, v2, v2
 1191              	# stdlib.c:218: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1192 0a04 93F6F60F 		andi	a3,a3,0xff	# c1, v1
 1193              	# stdlib.c:218: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1194 0a08 1376F60F 		andi	a2,a2,0xff	# c2, v2
 1195              	# stdlib.c:219: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1196 0a0c E396C6F8 		bne	a3,a2,.L159	#, c1, c2,
 1197              	# stdlib.c:196: 			return 0;
 1198 0a10 13050000 		li	a0,0		# <retval>,
 1199              	# stdlib.c:220: 			if (!c1) return 0;
 1200 0a14 638C0600 		beq	a3,zero,.L135	#, c1,,
 1201              	# stdlib.c:223: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1202 0a18 93D78701 		srli	a5,a5,24	#, c1, v1
 1203              	# stdlib.c:223: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1204 0a1c 13578701 		srli	a4,a4,24	#, c2, v2
 1205              	# stdlib.c:224: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1206 0a20 6386E700 		beq	a5,a4,.L135	#, c1, c2,
 1207              	# stdlib.c:194: 			return c1 < c2 ? -1 : +1;
 1208 0a24 13051000 		li	a0,1		# <retval>,
 1209              	# stdlib.c:224: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1210 0a28 E3ECE7F6 		bltu	a5,a4,.L157	#, c1, c2,
 1211              	.L135:
 1212              	# stdlib.c:234: }
 1213 0a2c 67800000 		ret	
 1214              	.L141:
 1215              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1216 0a30 3387D700 		add	a4,a5,a3	# tmp157, tmp109, v1
 1217              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1218 0a34 93C7F7FF 		not	a5,a5	# tmp112, v1
 1219              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1220 0a38 B377F700 		and	a5,a4,a5	# tmp112, tmp113, tmp109
 1221              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1222 0a3c B3F7C700 		and	a5,a5,a2	# tmp159, tmp114, tmp113
 1223              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1224 0a40 E39807F8 		bne	a5,zero,.L155	#, tmp114,,
 1225              	# stdlib.c:231: 		s1 += 4;
 1226 0a44 13054500 		addi	a0,a0,4	#, s1, s1
 1227              	# stdlib.c:232: 		s2 += 4;
 1228 0a48 93854500 		addi	a1,a1,4	#, s2, s2
 1229              	# stdlib.c:200: 	{
 1230 0a4c 6FF05FF3 		j	.L145		#
 1232              		.align	2
 1233              		.globl	sin1
 1235              	sin1:
 1236              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1237 0a50 635A0500 		bge	a0,zero,.L162	#, angle,,
 1238              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1239 0a54 B787FFFF 		li	a5,-32768		# tmp96,
 1240 0a58 3305F500 		add	a0,a0,a5	# tmp96, tmp98, angle
 1241 0a5c 13150501 		slli	a0,a0,16	#, angle, tmp98
 1242 0a60 13550541 		srai	a0,a0,16	#, angle, angle
 1243              	.L162:
 1244              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 1245 0a64 93578540 		srai	a5,a0,8	#, v0, angle
 1246              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1247 0a68 93960701 		slli	a3,a5,16	#, v0.41_4, v0
 1248              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1249 0a6c 13F70702 		andi	a4,a5,32	#, tmp102, v0
 1250              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1251 0a70 93D60601 		srli	a3,a3,16	#, v0.41_4, v0.41_4
 1252              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1253 0a74 630A0700 		beq	a4,zero,.L163	#, tmp102,,
 1254              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1255 0a78 93C7F7FF 		not	a5,a5	# tmp104, v0
 1256 0a7c 93970701 		slli	a5,a5,16	#, v0, tmp104
 1257 0a80 93D70741 		srai	a5,a5,16	#, v0, v0
 1258              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1259 0a84 1345F5FF 		not	a0,a0	# angle, angle
 1260              	.L163:
 1261              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1262 0a88 93F7F701 		andi	a5,a5,31	#, _6, v0
 1263 0a8c 13961700 		slli	a2,a5,1	#, tmp110, _6
 1264 0a90 37070000 		lui	a4,%hi(.LANCHOR1)	# tmp109,
 1265              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1266 0a94 93871700 		addi	a5,a5,1	#, tmp114, _6
 1267              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1268 0a98 13070700 		addi	a4,a4,%lo(.LANCHOR1)	# tmp108, tmp109,
 1269              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1270 0a9c 93971700 		slli	a5,a5,1	#, tmp115, tmp114
 1271              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1272 0aa0 3306C700 		add	a2,a4,a2	# tmp110, tmp111, tmp108
 1273              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1274 0aa4 3307F700 		add	a4,a4,a5	# tmp115, tmp116, tmp108
 1275              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1276 0aa8 03160600 		lh	a2,0(a2)		# _7, sin90[_6]
 1277              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1278 0aac 83170700 		lh	a5,0(a4)		# sin90[_9], sin90[_9]
 1279              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1280 0ab0 1375F50F 		andi	a0,a0,0xff	# tmp121, angle
 1281              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1282 0ab4 B387C740 		sub	a5,a5,a2	# tmp118, sin90[_9], _7
 1283              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1284 0ab8 3385A702 		mul	a0,a5,a0	# tmp122, tmp118, tmp121
 1285              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1286 0abc 93F70604 		andi	a5,a3,64	#, tmp129, v0.41_4
 1287              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1288 0ac0 13558540 		srai	a0,a0,8	#, tmp123, tmp122
 1289              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1290 0ac4 3305C500 		add	a0,a0,a2	# _7, tmp126, tmp123
 1291 0ac8 13150501 		slli	a0,a0,16	#, _5, tmp126
 1292 0acc 13550501 		srli	a0,a0,16	#, _5, _5
 1293              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1294 0ad0 63880700 		beq	a5,zero,.L164	#, tmp129,,
 1295              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1296 0ad4 3305A040 		neg	a0,a0	# tmp131, _5
 1297 0ad8 13150501 		slli	a0,a0,16	#, _5, tmp131
 1298 0adc 13550501 		srli	a0,a0,16	#, _5, _5
 1299              	.L164:
 1300              	# gfx_lib_hdmi.h:94: }
 1301 0ae0 13150501 		slli	a0,a0,16	#,, _5
 1302 0ae4 13550541 		srai	a0,a0,16	#,,
 1303 0ae8 67800000 		ret	
 1305              		.align	2
 1306              		.globl	cos1
 1308              	cos1:
 1309              	# gfx_lib_hdmi.h:108:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1310 0aec 635A0500 		bge	a0,zero,.L172	#, angle,,
 1311              	# gfx_lib_hdmi.h:108:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1312 0af0 B787FFFF 		li	a5,-32768		# tmp79,
 1313 0af4 3305F500 		add	a0,a0,a5	# tmp79, tmp81, angle
 1314 0af8 13150501 		slli	a0,a0,16	#, angle, tmp81
 1315 0afc 13550541 		srai	a0,a0,16	#, angle, angle
 1316              	.L172:
 1317              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 1318 0b00 B7A7FFFF 		li	a5,-24576		# tmp85,
 1319 0b04 93871700 		addi	a5,a5,1	#, tmp84, tmp85
 1320 0b08 3305F500 		add	a0,a0,a5	# tmp84, tmp83, angle
 1321              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 1322 0b0c 13150501 		slli	a0,a0,16	#,, tmp83
 1323 0b10 13550541 		srai	a0,a0,16	#,,
 1324 0b14 17030000 		tail	sin1		#
 1324      67000300 
 1326              		.align	2
 1327              		.globl	oled_spi_tx
 1329              	oled_spi_tx:
 1330              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1331 0b1c 93958500 		slli	a1,a1,8	#, tmp80, tmp85
 1332 0b20 93F50510 		andi	a1,a1,256	#, tmp81, tmp80
 1333              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1334 0b24 B3E5A500 		or	a1,a1,a0	# tmp84, _6, tmp81
 1335              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1336 0b28 B7070030 		li	a5,805306368		# tmp83,
 1337 0b2c 23A6B700 		sw	a1,12(a5)	# _6, MEM[(volatile uint32_t *)805306380B]
 1338              	# gfx_lib_hdmi.h:115: }
 1339 0b30 67800000 		ret	
 1341              		.align	2
 1342              		.globl	oled_max_window
 1344              	oled_max_window:
 1345              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1346 0b34 B7070030 		li	a5,805306368		# tmp73,
 1347 0b38 13075001 		li	a4,21		# tmp74,
 1348 0b3c 23A6E700 		sw	a4,12(a5)	# tmp74, MEM[(volatile uint32_t *)805306380B]
 1349 0b40 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
 1350 0b44 1307F005 		li	a4,95		# tmp79,
 1351 0b48 23A6E700 		sw	a4,12(a5)	# tmp79, MEM[(volatile uint32_t *)805306380B]
 1352 0b4c 13075007 		li	a4,117		# tmp82,
 1353 0b50 23A6E700 		sw	a4,12(a5)	# tmp82, MEM[(volatile uint32_t *)805306380B]
 1354 0b54 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
 1355 0b58 1307F003 		li	a4,63		# tmp87,
 1356 0b5c 23A6E700 		sw	a4,12(a5)	# tmp87, MEM[(volatile uint32_t *)805306380B]
 1357              	# gfx_lib_hdmi.h:120: }
 1358 0b60 67800000 		ret	
 1360              		.align	2
 1361              		.globl	oled_show_fb_8or16
 1363              	oled_show_fb_8or16:
 1364              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
 1365 0b64 B7070030 		li	a5,805306368		# tmp78,
 1366 0b68 23A6A702 		sw	a0,44(a5)	# framebuffer, MEM[(volatile uint32_t *)805306412B]
 1367              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 1368 0b6c 37170000 		li	a4,4096		# tmp84,
 1369              	# kianv_stdlib.h:52:   *( (volatile uint32_t*) DMA_DST  ) = dst;
 1370 0b70 23A8B702 		sw	a1,48(a5)	# target_fb, MEM[(volatile uint32_t *)805306416B]
 1371              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 1372 0b74 1307072C 		addi	a4,a4,704	#, tmp83, tmp84
 1373 0b78 23AAE702 		sw	a4,52(a5)	# tmp83, MEM[(volatile uint32_t *)805306420B]
 1374              	# kianv_stdlib.h:54:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
 1375 0b7c 13071000 		li	a4,1		# tmp87,
 1376 0b80 23ACE702 		sw	a4,56(a5)	# tmp87, MEM[(volatile uint32_t *)805306424B]
 1377              	# gfx_lib_hdmi.h:132: }
 1378 0b84 67800000 		ret	
 1380              		.align	2
 1381              		.globl	init_oled8bit_colors
 1383              	init_oled8bit_colors:
 1384              	# gfx_lib_hdmi.h:195:     char p = oled_8bit_init_seq[i];
 1385 0b88 37070000 		lui	a4,%hi(.LANCHOR2)	# tmp78,
 1386              	# gfx_lib_hdmi.h:192:   for (int i = 0; i < sizeof(oled_8bit_init_seq)/
 1387 0b8c 93070000 		li	a5,0		# i,
 1388              	# gfx_lib_hdmi.h:195:     char p = oled_8bit_init_seq[i];
 1389 0b90 13070700 		addi	a4,a4,%lo(.LANCHOR2)	# tmp77, tmp78,
 1390              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1391 0b94 37060030 		li	a2,805306368		# tmp81,
 1392              	# gfx_lib_hdmi.h:192:   for (int i = 0; i < sizeof(oled_8bit_init_seq)/
 1393 0b98 93065002 		li	a3,37		# tmp82,
 1394              	.L177:
 1395              	# gfx_lib_hdmi.h:195:     char p = oled_8bit_init_seq[i];
 1396 0b9c B305F700 		add	a1,a4,a5	# i, tmp79, tmp77
 1397              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1398 0ba0 83C50500 		lbu	a1,0(a1)	# _7, MEM[(char *)_1]
 1399              	# gfx_lib_hdmi.h:193:       sizeof(oled_8bit_init_seq[0]); i++) {
 1400 0ba4 93871700 		addi	a5,a5,1	#, i, i
 1401              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1402 0ba8 2326B600 		sw	a1,12(a2)	# _7, MEM[(volatile uint32_t *)805306380B]
 1403              	# gfx_lib_hdmi.h:192:   for (int i = 0; i < sizeof(oled_8bit_init_seq)/
 1404 0bac E398D7FE 		bne	a5,a3,.L177	#, i, tmp82,
 1405              	# gfx_lib_hdmi.h:198: }
 1406 0bb0 67800000 		ret	
 1408              		.align	2
 1409              		.globl	fb_setpixel
 1411              	fb_setpixel:
 1412              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 1413 0bb4 9307F004 		li	a5,79		# tmp84,
 1414 0bb8 63E2B702 		bgtu	a1,a5,.L179	#, x, tmp84,
 1415              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 1416 0bbc 9307B003 		li	a5,59		# tmp85,
 1417 0bc0 63EEC700 		bgtu	a2,a5,.L179	#, y, tmp85,
 1418              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 1419 0bc4 93070005 		li	a5,80		# tmp86,
 1420 0bc8 3306F602 		mul	a2,a2,a5	# tmp87, y, tmp86
 1421 0bcc B305B600 		add	a1,a2,a1	# x, tmp88, tmp87
 1422              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 1423 0bd0 93952500 		slli	a1,a1,2	#, tmp89, tmp88
 1424 0bd4 3305B500 		add	a0,a0,a1	# tmp89, tmp90, fb
 1425 0bd8 2320D500 		sw	a3,0(a0)	# color, *_12
 1426              	.L179:
 1427              	# gfx_lib_hdmi.h:207: }
 1428 0bdc 67800000 		ret	
 1430              		.align	2
 1431              		.globl	fb_draw_bresenham
 1433              	fb_draw_bresenham:
 1434 0be0 130101FC 		addi	sp,sp,-64	#,,
 1435 0be4 232E7101 		sw	s7,28(sp)	#,
 1436 0be8 930B0500 		mv	s7,a0	# fb, tmp101
 1437              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 1438 0bec 3385B640 		sub	a0,a3,a1	#, x1, x0
 1439              	# gfx_lib_hdmi.h:210: {
 1440 0bf0 232C8102 		sw	s0,56(sp)	#,
 1441 0bf4 232A9102 		sw	s1,52(sp)	#,
 1442 0bf8 23263103 		sw	s3,44(sp)	#,
 1443 0bfc 23225103 		sw	s5,36(sp)	#,
 1444 0c00 23206103 		sw	s6,32(sp)	#,
 1445 0c04 232C8101 		sw	s8,24(sp)	#,
 1446 0c08 2328A101 		sw	s10,16(sp)	#,
 1447 0c0c 232E1102 		sw	ra,60(sp)	#,
 1448 0c10 23282103 		sw	s2,48(sp)	#,
 1449 0c14 23244103 		sw	s4,40(sp)	#,
 1450 0c18 232A9101 		sw	s9,20(sp)	#,
 1451 0c1c 2326B101 		sw	s11,12(sp)	#,
 1452              	# gfx_lib_hdmi.h:210: {
 1453 0c20 93840500 		mv	s1,a1	# x0, tmp102
 1454 0c24 13040600 		mv	s0,a2	# y0, tmp103
 1455 0c28 938A0600 		mv	s5,a3	# x1, tmp104
 1456 0c2c 130B0700 		mv	s6,a4	# y1, tmp105
 1457 0c30 138C0700 		mv	s8,a5	# color, tmp106
 1458              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 1459 0c34 97000000 		call	abs		#
 1459      E7800000 
 1460 0c3c 93090500 		mv	s3,a0	# dx, tmp107
 1461              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 1462 0c40 130DF0FF 		li	s10,-1		# iftmp.50_9,
 1463 0c44 63D45401 		ble	s5,s1,.L182	#, x1, x0,
 1464 0c48 130D1000 		li	s10,1		# iftmp.50_9,
 1465              	.L182:
 1466              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 1467 0c4c 33058B40 		sub	a0,s6,s0	#, y1, y0
 1468 0c50 97000000 		call	abs		#
 1468      E7800000 
 1469 0c58 130A0500 		mv	s4,a0	# _3, tmp108
 1470              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 1471 0c5c B30DA040 		neg	s11,a0	# dy, _3
 1472              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 1473 0c60 930C1000 		li	s9,1		# iftmp.51_10,
 1474 0c64 63446401 		bgt	s6,s0,.L183	#, y1, y0,
 1475              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 1476 0c68 930CF0FF 		li	s9,-1		# iftmp.51_10,
 1477              	.L183:
 1478 0c6c 33894941 		sub	s2,s3,s4	# err, dx, _3
 1479              	.L184:
 1480              	# gfx_lib_hdmi.h:217:     fb_setpixel(fb, x0, y0, color);
 1481 0c70 93060C00 		mv	a3,s8	#, color
 1482 0c74 13060400 		mv	a2,s0	#, y0
 1483 0c78 93850400 		mv	a1,s1	#, x0
 1484 0c7c 13850B00 		mv	a0,s7	#, fb
 1485 0c80 97000000 		call	fb_setpixel		#
 1485      E7800000 
 1486              	# gfx_lib_hdmi.h:218:     if (x0 == x1 && y0 == y1) break;
 1487 0c88 63945401 		bne	s1,s5,.L185	#, x0, x1,
 1488              	# gfx_lib_hdmi.h:218:     if (x0 == x1 && y0 == y1) break;
 1489 0c8c 63026403 		beq	s0,s6,.L181	#, y0, y1,
 1490              	.L185:
 1491              	# gfx_lib_hdmi.h:220:     e2 = 2*err;
 1492 0c90 93171900 		slli	a5,s2,1	#, e2, err
 1493              	# gfx_lib_hdmi.h:221:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 1494 0c94 63C6B701 		bgt	s11,a5,.L187	#, dy, e2,
 1495 0c98 33094941 		sub	s2,s2,s4	# err, err, _3
 1496              	# gfx_lib_hdmi.h:221:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 1497 0c9c B384A401 		add	s1,s1,s10	# iftmp.50_9, x0, x0
 1498              	.L187:
 1499              	# gfx_lib_hdmi.h:222:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 1500 0ca0 E3C8F9FC 		blt	s3,a5,.L184	#, dx, e2,
 1501              	# gfx_lib_hdmi.h:222:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 1502 0ca4 33093901 		add	s2,s2,s3	# dx, err, err
 1503              	# gfx_lib_hdmi.h:222:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 1504 0ca8 33049401 		add	s0,s0,s9	# iftmp.51_10, y0, y0
 1505 0cac 6FF05FFC 		j	.L184		#
 1506              	.L181:
 1507              	# gfx_lib_hdmi.h:224: }
 1508 0cb0 8320C103 		lw	ra,60(sp)		#,
 1509 0cb4 03248103 		lw	s0,56(sp)		#,
 1510 0cb8 83244103 		lw	s1,52(sp)		#,
 1511 0cbc 03290103 		lw	s2,48(sp)		#,
 1512 0cc0 8329C102 		lw	s3,44(sp)		#,
 1513 0cc4 032A8102 		lw	s4,40(sp)		#,
 1514 0cc8 832A4102 		lw	s5,36(sp)		#,
 1515 0ccc 032B0102 		lw	s6,32(sp)		#,
 1516 0cd0 832BC101 		lw	s7,28(sp)		#,
 1517 0cd4 032C8101 		lw	s8,24(sp)		#,
 1518 0cd8 832C4101 		lw	s9,20(sp)		#,
 1519 0cdc 032D0101 		lw	s10,16(sp)		#,
 1520 0ce0 832DC100 		lw	s11,12(sp)		#,
 1521 0ce4 13010104 		addi	sp,sp,64	#,,
 1522 0ce8 67800000 		jr	ra		#
 1524              		.align	2
 1525              		.globl	fill_oled
 1527              	fill_oled:
 1528              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
 1529 0cec B7070030 		li	a5,805306368		# tmp77,
 1530 0cf0 23A6A702 		sw	a0,44(a5)	# framebuffer, MEM[(volatile uint32_t *)805306412B]
 1531              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 1532 0cf4 37170000 		li	a4,4096		# tmp83,
 1533              	# kianv_stdlib.h:52:   *( (volatile uint32_t*) DMA_DST  ) = dst;
 1534 0cf8 23A8B702 		sw	a1,48(a5)	# rgb, MEM[(volatile uint32_t *)805306416B]
 1535              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 1536 0cfc 1307072C 		addi	a4,a4,704	#, tmp82, tmp83
 1537 0d00 23AAE702 		sw	a4,52(a5)	# tmp82, MEM[(volatile uint32_t *)805306420B]
 1538              	# kianv_stdlib.h:54:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
 1539 0d04 13072000 		li	a4,2		# tmp86,
 1540 0d08 23ACE702 		sw	a4,56(a5)	# tmp86, MEM[(volatile uint32_t *)805306424B]
 1541              	# gfx_lib_hdmi.h:233: }
 1542 0d0c 67800000 		ret	
 1544              		.align	2
 1545              		.globl	mirror_x_axis
 1547              	mirror_x_axis:
 1548              	# gfx_lib_hdmi.h:236:   point transformed = {p->x, 1.0 * p->y};
 1549 0d10 03A74500 		lw	a4,4(a1)		# _2, p_4(D)->y
 1550              	# gfx_lib_hdmi.h:237:   return transformed;
 1551 0d14 83A60500 		lw	a3,0(a1)		# p_4(D)->x, p_4(D)->x
 1552 0d18 23240500 		sw	zero,8(a0)	#, <retval>.z
 1553 0d1c 2322E500 		sw	a4,4(a0)	# _2, <retval>.y
 1554 0d20 2320D500 		sw	a3,0(a0)	# p_4(D)->x, <retval>.x
 1555              	# gfx_lib_hdmi.h:238: }
 1556 0d24 67800000 		ret	
 1558              		.globl	__floatsidf
 1559              		.globl	__fixdfsi
 1560              		.align	2
 1561              		.globl	mirror_y_axis
 1563              	mirror_y_axis:
 1564 0d28 130101FF 		addi	sp,sp,-16	#,,
 1565 0d2c 23248100 		sw	s0,8(sp)	#,
 1566 0d30 13040500 		mv	s0,a0	# .result_ptr, tmp88
 1567              	# gfx_lib_hdmi.h:241:   point transformed = {-1.0 * p->x, p->y};
 1568 0d34 03A50500 		lw	a0,0(a1)		#, p_7(D)->x
 1569              	# gfx_lib_hdmi.h:240: point mirror_y_axis(point *p) {
 1570 0d38 23261100 		sw	ra,12(sp)	#,
 1571 0d3c 23229100 		sw	s1,4(sp)	#,
 1572              	# gfx_lib_hdmi.h:241:   point transformed = {-1.0 * p->x, p->y};
 1573 0d40 83A44500 		lw	s1,4(a1)		# _5, p_7(D)->y
 1574              	# gfx_lib_hdmi.h:241:   point transformed = {-1.0 * p->x, p->y};
 1575 0d44 97000000 		call	__floatsidf		#
 1575      E7800000 
 1576              	# gfx_lib_hdmi.h:241:   point transformed = {-1.0 * p->x, p->y};
 1577 0d4c B7070080 		li	a5,-2147483648		# tmp81,
 1578 0d50 13070500 		mv	a4,a0	# tmp93, tmp90
 1579 0d54 B3C7B700 		xor	a5,a5,a1	# tmp91, tmp94, tmp81
 1580 0d58 13050700 		mv	a0,a4	# tmp95, tmp93
 1581 0d5c 93850700 		mv	a1,a5	#, tmp94
 1582 0d60 97000000 		call	__fixdfsi		#
 1582      E7800000 
 1583 0d68 2320A400 		sw	a0,0(s0)	# tmp92, <retval>.x
 1584              	# gfx_lib_hdmi.h:242:   return transformed;
 1585 0d6c 23229400 		sw	s1,4(s0)	# _5, <retval>.y
 1586              	# gfx_lib_hdmi.h:243: }
 1587 0d70 8320C100 		lw	ra,12(sp)		#,
 1588              	# gfx_lib_hdmi.h:242:   return transformed;
 1589 0d74 23240400 		sw	zero,8(s0)	#, <retval>.z
 1590              	# gfx_lib_hdmi.h:243: }
 1591 0d78 13050400 		mv	a0,s0	#, .result_ptr
 1592 0d7c 03248100 		lw	s0,8(sp)		#,
 1593 0d80 83244100 		lw	s1,4(sp)		#,
 1594 0d84 13010101 		addi	sp,sp,16	#,,
 1595 0d88 67800000 		jr	ra		#
 1597              		.align	2
 1598              		.globl	mirror_z_axis
 1600              	mirror_z_axis:
 1601 0d8c 130101FF 		addi	sp,sp,-16	#,,
 1602 0d90 23248100 		sw	s0,8(sp)	#,
 1603 0d94 13040500 		mv	s0,a0	# .result_ptr, tmp89
 1604              	# gfx_lib_hdmi.h:246:   point transformed = {p->x, p->y, -1.0 * p->z};
 1605 0d98 03A58500 		lw	a0,8(a1)		#, p_8(D)->z
 1606              	# gfx_lib_hdmi.h:245: point mirror_z_axis(point *p) {
 1607 0d9c 23261100 		sw	ra,12(sp)	#,
 1608 0da0 23229100 		sw	s1,4(sp)	#,
 1609 0da4 23202101 		sw	s2,0(sp)	#,
 1610              	# gfx_lib_hdmi.h:245: point mirror_z_axis(point *p) {
 1611 0da8 93840500 		mv	s1,a1	# p, tmp90
 1612              	# gfx_lib_hdmi.h:246:   point transformed = {p->x, p->y, -1.0 * p->z};
 1613 0dac 03A94500 		lw	s2,4(a1)		# _2, p_8(D)->y
 1614              	# gfx_lib_hdmi.h:246:   point transformed = {p->x, p->y, -1.0 * p->z};
 1615 0db0 97000000 		call	__floatsidf		#
 1615      E7800000 
 1616              	# gfx_lib_hdmi.h:246:   point transformed = {p->x, p->y, -1.0 * p->z};
 1617 0db8 B7070080 		li	a5,-2147483648		# tmp82,
 1618 0dbc B3C7B700 		xor	a5,a5,a1	# tmp92, tmp95, tmp82
 1619 0dc0 13070500 		mv	a4,a0	# tmp94, tmp91
 1620 0dc4 93850700 		mv	a1,a5	#, tmp95
 1621 0dc8 13050700 		mv	a0,a4	# tmp96, tmp94
 1622 0dcc 97000000 		call	__fixdfsi		#
 1622      E7800000 
 1623              	# gfx_lib_hdmi.h:247:   return transformed;
 1624 0dd4 83A70400 		lw	a5,0(s1)		# p_8(D)->x, p_8(D)->x
 1625 0dd8 23222401 		sw	s2,4(s0)	# _2, <retval>.y
 1626 0ddc 2324A400 		sw	a0,8(s0)	# tmp93, <retval>.z
 1627              	# gfx_lib_hdmi.h:248: }
 1628 0de0 8320C100 		lw	ra,12(sp)		#,
 1629              	# gfx_lib_hdmi.h:247:   return transformed;
 1630 0de4 2320F400 		sw	a5,0(s0)	# p_8(D)->x, <retval>.x
 1631              	# gfx_lib_hdmi.h:248: }
 1632 0de8 13050400 		mv	a0,s0	#, .result_ptr
 1633 0dec 03248100 		lw	s0,8(sp)		#,
 1634 0df0 83244100 		lw	s1,4(sp)		#,
 1635 0df4 03290100 		lw	s2,0(sp)		#,
 1636 0df8 13010101 		addi	sp,sp,16	#,,
 1637 0dfc 67800000 		jr	ra		#
 1639              		.globl	__floatsisf
 1640              		.globl	__mulsf3
 1641              		.globl	__fixsfsi
 1642              		.align	2
 1643              		.globl	scale
 1645              	scale:
 1646 0e00 130101FD 		addi	sp,sp,-48	#,,
 1647 0e04 23248102 		sw	s0,40(sp)	#,
 1648 0e08 13040500 		mv	s0,a0	# .result_ptr, tmp96
 1649              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 1650 0e0c 03A54500 		lw	a0,4(a1)		#, p_14(D)->y
 1651              	# gfx_lib_hdmi.h:250: point scale(point *p, float sx, float sy, float sz) {
 1652 0e10 23261102 		sw	ra,44(sp)	#,
 1653 0e14 23229102 		sw	s1,36(sp)	#,
 1654 0e18 23202103 		sw	s2,32(sp)	#,
 1655 0e1c 232E3101 		sw	s3,28(sp)	#,
 1656 0e20 13090700 		mv	s2,a4	# sz, tmp100
 1657 0e24 232C4101 		sw	s4,24(sp)	#,
 1658              	# gfx_lib_hdmi.h:250: point scale(point *p, float sx, float sy, float sz) {
 1659 0e28 2326D100 		sw	a3,12(sp)	# sy, %sfp
 1660 0e2c 130A0600 		mv	s4,a2	# sx, tmp98
 1661 0e30 93840500 		mv	s1,a1	# p, tmp97
 1662              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 1663 0e34 97000000 		call	__floatsisf		#
 1663      E7800000 
 1664 0e3c 8325C100 		lw	a1,12(sp)		# sy, %sfp
 1665 0e40 97000000 		call	__mulsf3		#
 1665      E7800000 
 1666              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 1667 0e48 97000000 		call	__fixsfsi		#
 1667      E7800000 
 1668 0e50 93090500 		mv	s3,a0	# _8, tmp101
 1669              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 1670 0e54 03A58400 		lw	a0,8(s1)		#, p_14(D)->z
 1671 0e58 97000000 		call	__floatsisf		#
 1671      E7800000 
 1672 0e60 93050900 		mv	a1,s2	#, sz
 1673 0e64 97000000 		call	__mulsf3		#
 1673      E7800000 
 1674              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 1675 0e6c 97000000 		call	__fixsfsi		#
 1675      E7800000 
 1676 0e74 13090500 		mv	s2,a0	# _12, tmp102
 1677              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 1678 0e78 03A50400 		lw	a0,0(s1)		#, p_14(D)->x
 1679 0e7c 97000000 		call	__floatsisf		#
 1679      E7800000 
 1680 0e84 93050A00 		mv	a1,s4	#, sx
 1681 0e88 97000000 		call	__mulsf3		#
 1681      E7800000 
 1682              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 1683 0e90 97000000 		call	__fixsfsi		#
 1683      E7800000 
 1684 0e98 2320A400 		sw	a0,0(s0)	# tmp103, <retval>.x
 1685              	# gfx_lib_hdmi.h:252:   return transformed;
 1686 0e9c 23223401 		sw	s3,4(s0)	# _8, <retval>.y
 1687 0ea0 23242401 		sw	s2,8(s0)	# _12, <retval>.z
 1688              	# gfx_lib_hdmi.h:253: }
 1689 0ea4 8320C102 		lw	ra,44(sp)		#,
 1690 0ea8 13050400 		mv	a0,s0	#, .result_ptr
 1691 0eac 03248102 		lw	s0,40(sp)		#,
 1692 0eb0 83244102 		lw	s1,36(sp)		#,
 1693 0eb4 03290102 		lw	s2,32(sp)		#,
 1694 0eb8 8329C101 		lw	s3,28(sp)		#,
 1695 0ebc 032A8101 		lw	s4,24(sp)		#,
 1696 0ec0 13010103 		addi	sp,sp,48	#,,
 1697 0ec4 67800000 		jr	ra		#
 1699              		.align	2
 1700              		.globl	translate
 1702              	translate:
 1703              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 1704 0ec8 03A84500 		lw	a6,4(a1)		# p_8(D)->y, p_8(D)->y
 1705 0ecc B3860601 		add	a3,a3,a6	# p_8(D)->y, _4, tmp90
 1706              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 1707 0ed0 03A88500 		lw	a6,8(a1)		# p_8(D)->z, p_8(D)->z
 1708              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 1709 0ed4 83A50500 		lw	a1,0(a1)		# p_8(D)->x, p_8(D)->x
 1710              	# gfx_lib_hdmi.h:257:   return transformed;
 1711 0ed8 2322D500 		sw	a3,4(a0)	# _4, <retval>.y
 1712              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 1713 0edc 33070701 		add	a4,a4,a6	# p_8(D)->z, _6, tmp91
 1714              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 1715 0ee0 B385C500 		add	a1,a1,a2	# tmp89, tmp85, p_8(D)->x
 1716              	# gfx_lib_hdmi.h:257:   return transformed;
 1717 0ee4 2320B500 		sw	a1,0(a0)	# tmp85, <retval>.x
 1718 0ee8 2324E500 		sw	a4,8(a0)	# _6, <retval>.z
 1719              	# gfx_lib_hdmi.h:258: }
 1720 0eec 67800000 		ret	
 1722              		.globl	__muldf3
 1723              		.globl	__divdf3
 1724              		.globl	__truncdfsf2
 1725              		.globl	__subsf3
 1726              		.globl	__addsf3
 1727              		.align	2
 1728              		.globl	rotateX_pivot
 1730              	rotateX_pivot:
 1731 0ef0 130101FD 		addi	sp,sp,-48	#,,
 1732 0ef4 23248102 		sw	s0,40(sp)	#,
 1733 0ef8 13040500 		mv	s0,a0	# .result_ptr, tmp141
 1734              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 1735 0efc 13850600 		mv	a0,a3	#, tmp144
 1736              	# gfx_lib_hdmi.h:261: point rotateX_pivot(point *p, point *pivot, int angle) {
 1737 0f00 23261102 		sw	ra,44(sp)	#,
 1738 0f04 23229102 		sw	s1,36(sp)	#,
 1739 0f08 23202103 		sw	s2,32(sp)	#,
 1740 0f0c 232E3101 		sw	s3,28(sp)	#,
 1741 0f10 232C4101 		sw	s4,24(sp)	#,
 1742 0f14 232A5101 		sw	s5,20(sp)	#,
 1743 0f18 23286101 		sw	s6,16(sp)	#,
 1744 0f1c 23267101 		sw	s7,12(sp)	#,
 1745 0f20 23248101 		sw	s8,8(sp)	#,
 1746              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1747 0f24 832B8600 		lw	s7,8(a2)		# _6, pivot_34(D)->z
 1748              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1749 0f28 032C4600 		lw	s8,4(a2)		# _3, pivot_34(D)->y
 1750              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1751 0f2c 03AA4500 		lw	s4,4(a1)		# p_33(D)->y, p_33(D)->y
 1752              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1753 0f30 03AB8500 		lw	s6,8(a1)		# p_33(D)->z, p_33(D)->z
 1754              	# gfx_lib_hdmi.h:261: point rotateX_pivot(point *p, point *pivot, int angle) {
 1755 0f34 93840500 		mv	s1,a1	# p, tmp142
 1756              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 1757 0f38 97000000 		call	__floatsidf		#
 1757      E7800000 
 1758 0f40 B7070000 		lui	a5,%hi(.LC2)	# tmp112,
 1759 0f44 03A60700 		lw	a2,%lo(.LC2)(a5)		#,
 1760 0f48 83A64700 		lw	a3,%lo(.LC2+4)(a5)		#,
 1761 0f4c B7090000 		lui	s3,%hi(.LC4)	# tmp120,
 1762              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1763 0f50 330A8A41 		sub	s4,s4,s8	# _4, p_33(D)->y, _3
 1764              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 1765 0f54 97000000 		call	__muldf3		#
 1765      E7800000 
 1766 0f5c B7070000 		lui	a5,%hi(.LC3)	# tmp114,
 1767 0f60 03A60700 		lw	a2,%lo(.LC3)(a5)		#,
 1768 0f64 83A64700 		lw	a3,%lo(.LC3+4)(a5)		#,
 1769              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1770 0f68 330B7B41 		sub	s6,s6,s7	# _7, p_33(D)->z, _6
 1771              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 1772 0f6c 97000000 		call	__divdf3		#
 1772      E7800000 
 1773 0f74 97000000 		call	__fixdfsi		#
 1773      E7800000 
 1774 0f7c 13190501 		slli	s2,a0,16	#, _11, tmp145
 1775 0f80 13590941 		srai	s2,s2,16	#, _11, _11
 1776 0f84 13050900 		mv	a0,s2	#, _11
 1777 0f88 97000000 		call	sin1		#
 1777      E7800000 
 1778 0f90 97000000 		call	__floatsidf		#
 1778      E7800000 
 1779 0f98 03A60900 		lw	a2,%lo(.LC4)(s3)		#,
 1780 0f9c 83A64900 		lw	a3,%lo(.LC4+4)(s3)		#,
 1781 0fa0 97000000 		call	__muldf3		#
 1781      E7800000 
 1782              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 1783 0fa8 97000000 		call	__truncdfsf2		#
 1783      E7800000 
 1784 0fb0 930A0500 		mv	s5,a0	# tmp122, tmp146
 1785              	# gfx_lib_hdmi.h:267:   float cos_theta = COS_FAST(angle);
 1786 0fb4 13050900 		mv	a0,s2	#, _11
 1787 0fb8 97000000 		call	cos1		#
 1787      E7800000 
 1788 0fc0 97000000 		call	__floatsidf		#
 1788      E7800000 
 1789 0fc8 03A60900 		lw	a2,%lo(.LC4)(s3)		#,
 1790 0fcc 83A64900 		lw	a3,%lo(.LC4+4)(s3)		#,
 1791 0fd0 97000000 		call	__muldf3		#
 1791      E7800000 
 1792              	# gfx_lib_hdmi.h:267:   float cos_theta = COS_FAST(angle);
 1793 0fd8 97000000 		call	__truncdfsf2		#
 1793      E7800000 
 1794 0fe0 93090500 		mv	s3,a0	# tmp127, tmp147
 1795              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 1796 0fe4 13050A00 		mv	a0,s4	#, _4
 1797 0fe8 97000000 		call	__floatsisf		#
 1797      E7800000 
 1798 0ff0 130A0500 		mv	s4,a0	# _19, tmp148
 1799              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 1800 0ff4 13050B00 		mv	a0,s6	#, _7
 1801 0ff8 97000000 		call	__floatsisf		#
 1801      E7800000 
 1802              	# gfx_lib_hdmi.h:273:   return transformed;
 1803 1000 83A70400 		lw	a5,0(s1)		# p_33(D)->x, p_33(D)->x
 1804              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 1805 1004 13090500 		mv	s2,a0	# _21, tmp149
 1806              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 1807 1008 93850900 		mv	a1,s3	#, tmp127
 1808              	# gfx_lib_hdmi.h:273:   return transformed;
 1809 100c 2320F400 		sw	a5,0(s0)	# p_33(D)->x, <retval>.x
 1810              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 1811 1010 13050A00 		mv	a0,s4	#, _19
 1812 1014 97000000 		call	__mulsf3		#
 1812      E7800000 
 1813 101c 93040500 		mv	s1,a0	# tmp129, tmp150
 1814              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 1815 1020 93850A00 		mv	a1,s5	#, tmp122
 1816 1024 13050900 		mv	a0,s2	#, _21
 1817 1028 97000000 		call	__mulsf3		#
 1817      E7800000 
 1818 1030 93050500 		mv	a1,a0	# tmp151,
 1819              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 1820 1034 13850400 		mv	a0,s1	#, tmp129
 1821 1038 97000000 		call	__subsf3		#
 1821      E7800000 
 1822 1040 93040500 		mv	s1,a0	# tmp131, tmp152
 1823              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 1824 1044 13050C00 		mv	a0,s8	#, _3
 1825 1048 97000000 		call	__floatsisf		#
 1825      E7800000 
 1826 1050 93050500 		mv	a1,a0	# tmp153,
 1827 1054 13850400 		mv	a0,s1	#, tmp131
 1828 1058 97000000 		call	__addsf3		#
 1828      E7800000 
 1829              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 1830 1060 97000000 		call	__fixsfsi		#
 1830      E7800000 
 1831 1068 2322A400 		sw	a0,4(s0)	# tmp154, <retval>.y
 1832              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 1833 106c 93850A00 		mv	a1,s5	#, tmp122
 1834 1070 13050A00 		mv	a0,s4	#, _19
 1835 1074 97000000 		call	__mulsf3		#
 1835      E7800000 
 1836 107c 93040500 		mv	s1,a0	# tmp135, tmp155
 1837              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 1838 1080 93850900 		mv	a1,s3	#, tmp127
 1839 1084 13050900 		mv	a0,s2	#, _21
 1840 1088 97000000 		call	__mulsf3		#
 1840      E7800000 
 1841 1090 93050500 		mv	a1,a0	# tmp156,
 1842              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 1843 1094 13850400 		mv	a0,s1	#, tmp135
 1844 1098 97000000 		call	__addsf3		#
 1844      E7800000 
 1845 10a0 93040500 		mv	s1,a0	# tmp137, tmp157
 1846              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 1847 10a4 13850B00 		mv	a0,s7	#, _6
 1848 10a8 97000000 		call	__floatsisf		#
 1848      E7800000 
 1849 10b0 93050500 		mv	a1,a0	# tmp158,
 1850 10b4 13850400 		mv	a0,s1	#, tmp137
 1851 10b8 97000000 		call	__addsf3		#
 1851      E7800000 
 1852              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 1853 10c0 97000000 		call	__fixsfsi		#
 1853      E7800000 
 1854 10c8 2324A400 		sw	a0,8(s0)	# tmp159, <retval>.z
 1855              	# gfx_lib_hdmi.h:274: }
 1856 10cc 8320C102 		lw	ra,44(sp)		#,
 1857 10d0 13050400 		mv	a0,s0	#, .result_ptr
 1858 10d4 03248102 		lw	s0,40(sp)		#,
 1859 10d8 83244102 		lw	s1,36(sp)		#,
 1860 10dc 03290102 		lw	s2,32(sp)		#,
 1861 10e0 8329C101 		lw	s3,28(sp)		#,
 1862 10e4 032A8101 		lw	s4,24(sp)		#,
 1863 10e8 832A4101 		lw	s5,20(sp)		#,
 1864 10ec 032B0101 		lw	s6,16(sp)		#,
 1865 10f0 832BC100 		lw	s7,12(sp)		#,
 1866 10f4 032C8100 		lw	s8,8(sp)		#,
 1867 10f8 13010103 		addi	sp,sp,48	#,,
 1868 10fc 67800000 		jr	ra		#
 1870              		.align	2
 1871              		.globl	rotateY_pivot
 1873              	rotateY_pivot:
 1874 1100 130101FD 		addi	sp,sp,-48	#,,
 1875 1104 23248102 		sw	s0,40(sp)	#,
 1876 1108 13040500 		mv	s0,a0	# .result_ptr, tmp140
 1877              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 1878 110c 13850600 		mv	a0,a3	#, tmp143
 1879              	# gfx_lib_hdmi.h:276: point rotateY_pivot(point *p, point *pivot, int angle) {
 1880 1110 23261102 		sw	ra,44(sp)	#,
 1881 1114 23229102 		sw	s1,36(sp)	#,
 1882 1118 23202103 		sw	s2,32(sp)	#,
 1883 111c 232E3101 		sw	s3,28(sp)	#,
 1884 1120 232C4101 		sw	s4,24(sp)	#,
 1885 1124 232A5101 		sw	s5,20(sp)	#,
 1886 1128 23286101 		sw	s6,16(sp)	#,
 1887 112c 23267101 		sw	s7,12(sp)	#,
 1888 1130 23248101 		sw	s8,8(sp)	#,
 1889              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1890 1134 832B0600 		lw	s7,0(a2)		# _2, pivot_34(D)->x
 1891              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1892 1138 032B8600 		lw	s6,8(a2)		# _6, pivot_34(D)->z
 1893              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1894 113c 03AC4500 		lw	s8,4(a1)		# _4, p_33(D)->y
 1895              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1896 1140 83AA0500 		lw	s5,0(a1)		# p_33(D)->x, p_33(D)->x
 1897              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1898 1144 83A98500 		lw	s3,8(a1)		# p_33(D)->z, p_33(D)->z
 1899              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 1900 1148 97000000 		call	__floatsidf		#
 1900      E7800000 
 1901 1150 B7070000 		lui	a5,%hi(.LC2)	# tmp112,
 1902 1154 03A60700 		lw	a2,%lo(.LC2)(a5)		#,
 1903 1158 83A64700 		lw	a3,%lo(.LC2+4)(a5)		#,
 1904 115c 370A0000 		lui	s4,%hi(.LC4)	# tmp120,
 1905              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1906 1160 B38A7A41 		sub	s5,s5,s7	# _3, p_33(D)->x, _2
 1907              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 1908 1164 97000000 		call	__muldf3		#
 1908      E7800000 
 1909 116c B7070000 		lui	a5,%hi(.LC3)	# tmp114,
 1910 1170 03A60700 		lw	a2,%lo(.LC3)(a5)		#,
 1911 1174 83A64700 		lw	a3,%lo(.LC3+4)(a5)		#,
 1912              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 1913 1178 B3896941 		sub	s3,s3,s6	# _7, p_33(D)->z, _6
 1914              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 1915 117c 97000000 		call	__divdf3		#
 1915      E7800000 
 1916 1184 97000000 		call	__fixdfsi		#
 1916      E7800000 
 1917 118c 93140501 		slli	s1,a0,16	#, _11, tmp144
 1918 1190 93D40441 		srai	s1,s1,16	#, _11, _11
 1919 1194 13850400 		mv	a0,s1	#, _11
 1920 1198 97000000 		call	sin1		#
 1920      E7800000 
 1921 11a0 97000000 		call	__floatsidf		#
 1921      E7800000 
 1922 11a8 03260A00 		lw	a2,%lo(.LC4)(s4)		#,
 1923 11ac 83264A00 		lw	a3,%lo(.LC4+4)(s4)		#,
 1924 11b0 97000000 		call	__muldf3		#
 1924      E7800000 
 1925              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 1926 11b8 97000000 		call	__truncdfsf2		#
 1926      E7800000 
 1927 11c0 13090500 		mv	s2,a0	# tmp122, tmp145
 1928              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 1929 11c4 13850400 		mv	a0,s1	#, _11
 1930 11c8 97000000 		call	cos1		#
 1930      E7800000 
 1931 11d0 97000000 		call	__floatsidf		#
 1931      E7800000 
 1932 11d8 03260A00 		lw	a2,%lo(.LC4)(s4)		#,
 1933 11dc 83264A00 		lw	a3,%lo(.LC4+4)(s4)		#,
 1934 11e0 97000000 		call	__muldf3		#
 1934      E7800000 
 1935              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 1936 11e8 97000000 		call	__truncdfsf2		#
 1936      E7800000 
 1937 11f0 130A0500 		mv	s4,a0	# tmp127, tmp146
 1938              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 1939 11f4 13850A00 		mv	a0,s5	#, _3
 1940 11f8 97000000 		call	__floatsisf		#
 1940      E7800000 
 1941 1200 93040500 		mv	s1,a0	# _19, tmp147
 1942              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 1943 1204 13850900 		mv	a0,s3	#, _7
 1944 1208 97000000 		call	__floatsisf		#
 1944      E7800000 
 1945 1210 93090500 		mv	s3,a0	# _21, tmp148
 1946              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 1947 1214 93050A00 		mv	a1,s4	#, tmp127
 1948 1218 13850400 		mv	a0,s1	#, _19
 1949 121c 97000000 		call	__mulsf3		#
 1949      E7800000 
 1950 1224 930A0500 		mv	s5,a0	# tmp128, tmp149
 1951              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 1952 1228 93050900 		mv	a1,s2	#, tmp122
 1953 122c 13850900 		mv	a0,s3	#, _21
 1954 1230 97000000 		call	__mulsf3		#
 1954      E7800000 
 1955 1238 93050500 		mv	a1,a0	# tmp150,
 1956              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 1957 123c 13850A00 		mv	a0,s5	#, tmp128
 1958 1240 97000000 		call	__addsf3		#
 1958      E7800000 
 1959 1248 930A0500 		mv	s5,a0	# tmp130, tmp151
 1960              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 1961 124c 13850B00 		mv	a0,s7	#, _2
 1962 1250 97000000 		call	__floatsisf		#
 1962      E7800000 
 1963 1258 93050500 		mv	a1,a0	# tmp152,
 1964 125c 13850A00 		mv	a0,s5	#, tmp130
 1965 1260 97000000 		call	__addsf3		#
 1965      E7800000 
 1966              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 1967 1268 97000000 		call	__fixsfsi		#
 1967      E7800000 
 1968 1270 2320A400 		sw	a0,0(s0)	# tmp153, <retval>.x
 1969              	# gfx_lib_hdmi.h:288:   return transformed;
 1970 1274 23228401 		sw	s8,4(s0)	# _4, <retval>.y
 1971              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 1972 1278 93050A00 		mv	a1,s4	#, tmp127
 1973 127c 13850900 		mv	a0,s3	#, _21
 1974 1280 97000000 		call	__mulsf3		#
 1974      E7800000 
 1975 1288 93090500 		mv	s3,a0	# tmp134, tmp154
 1976              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 1977 128c 93050900 		mv	a1,s2	#, tmp122
 1978 1290 13850400 		mv	a0,s1	#, _19
 1979 1294 97000000 		call	__mulsf3		#
 1979      E7800000 
 1980 129c 93050500 		mv	a1,a0	# tmp155,
 1981              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 1982 12a0 13850900 		mv	a0,s3	#, tmp134
 1983 12a4 97000000 		call	__subsf3		#
 1983      E7800000 
 1984 12ac 93040500 		mv	s1,a0	# tmp136, tmp156
 1985              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 1986 12b0 13050B00 		mv	a0,s6	#, _6
 1987 12b4 97000000 		call	__floatsisf		#
 1987      E7800000 
 1988 12bc 93050500 		mv	a1,a0	# tmp157,
 1989 12c0 13850400 		mv	a0,s1	#, tmp136
 1990 12c4 97000000 		call	__addsf3		#
 1990      E7800000 
 1991              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 1992 12cc 97000000 		call	__fixsfsi		#
 1992      E7800000 
 1993 12d4 2324A400 		sw	a0,8(s0)	# tmp158, <retval>.z
 1994              	# gfx_lib_hdmi.h:289: }
 1995 12d8 8320C102 		lw	ra,44(sp)		#,
 1996 12dc 13050400 		mv	a0,s0	#, .result_ptr
 1997 12e0 03248102 		lw	s0,40(sp)		#,
 1998 12e4 83244102 		lw	s1,36(sp)		#,
 1999 12e8 03290102 		lw	s2,32(sp)		#,
 2000 12ec 8329C101 		lw	s3,28(sp)		#,
 2001 12f0 032A8101 		lw	s4,24(sp)		#,
 2002 12f4 832A4101 		lw	s5,20(sp)		#,
 2003 12f8 032B0101 		lw	s6,16(sp)		#,
 2004 12fc 832BC100 		lw	s7,12(sp)		#,
 2005 1300 032C8100 		lw	s8,8(sp)		#,
 2006 1304 13010103 		addi	sp,sp,48	#,,
 2007 1308 67800000 		jr	ra		#
 2009              		.align	2
 2010              		.globl	rotateZ_pivot
 2012              	rotateZ_pivot:
 2013 130c 130101FD 		addi	sp,sp,-48	#,,
 2014 1310 23248102 		sw	s0,40(sp)	#,
 2015 1314 13040500 		mv	s0,a0	# .result_ptr, tmp140
 2016              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2017 1318 13850600 		mv	a0,a3	#, tmp143
 2018              	# gfx_lib_hdmi.h:291: point rotateZ_pivot(point *p, point *pivot, int angle) {
 2019 131c 23261102 		sw	ra,44(sp)	#,
 2020 1320 23229102 		sw	s1,36(sp)	#,
 2021 1324 23202103 		sw	s2,32(sp)	#,
 2022 1328 232E3101 		sw	s3,28(sp)	#,
 2023 132c 232C4101 		sw	s4,24(sp)	#,
 2024 1330 232A5101 		sw	s5,20(sp)	#,
 2025 1334 23286101 		sw	s6,16(sp)	#,
 2026 1338 23267101 		sw	s7,12(sp)	#,
 2027 133c 23248101 		sw	s8,8(sp)	#,
 2028              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2029 1340 832B0600 		lw	s7,0(a2)		# _2, pivot_34(D)->x
 2030              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2031 1344 032B4600 		lw	s6,4(a2)		# _5, pivot_34(D)->y
 2032              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2033 1348 03AC8500 		lw	s8,8(a1)		# _7, p_33(D)->z
 2034              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2035 134c 83A90500 		lw	s3,0(a1)		# p_33(D)->x, p_33(D)->x
 2036              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2037 1350 83AA4500 		lw	s5,4(a1)		# p_33(D)->y, p_33(D)->y
 2038              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2039 1354 97000000 		call	__floatsidf		#
 2039      E7800000 
 2040 135c B7070000 		lui	a5,%hi(.LC2)	# tmp112,
 2041 1360 03A60700 		lw	a2,%lo(.LC2)(a5)		#,
 2042 1364 83A64700 		lw	a3,%lo(.LC2+4)(a5)		#,
 2043 1368 37090000 		lui	s2,%hi(.LC4)	# tmp120,
 2044              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2045 136c B3897941 		sub	s3,s3,s7	# _3, p_33(D)->x, _2
 2046              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2047 1370 97000000 		call	__muldf3		#
 2047      E7800000 
 2048 1378 B7070000 		lui	a5,%hi(.LC3)	# tmp114,
 2049 137c 03A60700 		lw	a2,%lo(.LC3)(a5)		#,
 2050 1380 83A64700 		lw	a3,%lo(.LC3+4)(a5)		#,
 2051              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2052 1384 B38A6A41 		sub	s5,s5,s6	# _6, p_33(D)->y, _5
 2053              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2054 1388 97000000 		call	__divdf3		#
 2054      E7800000 
 2055 1390 97000000 		call	__fixdfsi		#
 2055      E7800000 
 2056 1398 93140501 		slli	s1,a0,16	#, _11, tmp144
 2057 139c 93D40441 		srai	s1,s1,16	#, _11, _11
 2058 13a0 13850400 		mv	a0,s1	#, _11
 2059 13a4 97000000 		call	sin1		#
 2059      E7800000 
 2060 13ac 97000000 		call	__floatsidf		#
 2060      E7800000 
 2061 13b4 03260900 		lw	a2,%lo(.LC4)(s2)		#,
 2062 13b8 83264900 		lw	a3,%lo(.LC4+4)(s2)		#,
 2063 13bc 97000000 		call	__muldf3		#
 2063      E7800000 
 2064              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2065 13c4 97000000 		call	__truncdfsf2		#
 2065      E7800000 
 2066 13cc 130A0500 		mv	s4,a0	# tmp122, tmp145
 2067              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 2068 13d0 13850400 		mv	a0,s1	#, _11
 2069 13d4 97000000 		call	cos1		#
 2069      E7800000 
 2070 13dc 97000000 		call	__floatsidf		#
 2070      E7800000 
 2071 13e4 03260900 		lw	a2,%lo(.LC4)(s2)		#,
 2072 13e8 83264900 		lw	a3,%lo(.LC4+4)(s2)		#,
 2073 13ec 97000000 		call	__muldf3		#
 2073      E7800000 
 2074              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 2075 13f4 97000000 		call	__truncdfsf2		#
 2075      E7800000 
 2076 13fc 13090500 		mv	s2,a0	# tmp127, tmp146
 2077              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 2078 1400 13850900 		mv	a0,s3	#, _3
 2079 1404 97000000 		call	__floatsisf		#
 2079      E7800000 
 2080 140c 93090500 		mv	s3,a0	# _19, tmp147
 2081              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 2082 1410 13850A00 		mv	a0,s5	#, _6
 2083 1414 97000000 		call	__floatsisf		#
 2083      E7800000 
 2084 141c 93040500 		mv	s1,a0	# _21, tmp148
 2085              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 2086 1420 93050900 		mv	a1,s2	#, tmp127
 2087 1424 13850900 		mv	a0,s3	#, _19
 2088 1428 97000000 		call	__mulsf3		#
 2088      E7800000 
 2089 1430 930A0500 		mv	s5,a0	# tmp128, tmp149
 2090              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 2091 1434 93050A00 		mv	a1,s4	#, tmp122
 2092 1438 13850400 		mv	a0,s1	#, _21
 2093 143c 97000000 		call	__mulsf3		#
 2093      E7800000 
 2094 1444 93050500 		mv	a1,a0	# tmp150,
 2095              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 2096 1448 13850A00 		mv	a0,s5	#, tmp128
 2097 144c 97000000 		call	__subsf3		#
 2097      E7800000 
 2098 1454 930A0500 		mv	s5,a0	# tmp130, tmp151
 2099              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 2100 1458 13850B00 		mv	a0,s7	#, _2
 2101 145c 97000000 		call	__floatsisf		#
 2101      E7800000 
 2102 1464 93050500 		mv	a1,a0	# tmp152,
 2103 1468 13850A00 		mv	a0,s5	#, tmp130
 2104 146c 97000000 		call	__addsf3		#
 2104      E7800000 
 2105              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 2106 1474 97000000 		call	__fixsfsi		#
 2106      E7800000 
 2107 147c 2320A400 		sw	a0,0(s0)	# tmp153, <retval>.x
 2108              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 2109 1480 93050A00 		mv	a1,s4	#, tmp122
 2110 1484 13850900 		mv	a0,s3	#, _19
 2111 1488 97000000 		call	__mulsf3		#
 2111      E7800000 
 2112 1490 93090500 		mv	s3,a0	# tmp134, tmp154
 2113              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 2114 1494 93050900 		mv	a1,s2	#, tmp127
 2115 1498 13850400 		mv	a0,s1	#, _21
 2116 149c 97000000 		call	__mulsf3		#
 2116      E7800000 
 2117 14a4 93050500 		mv	a1,a0	# tmp155,
 2118              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 2119 14a8 13850900 		mv	a0,s3	#, tmp134
 2120 14ac 97000000 		call	__addsf3		#
 2120      E7800000 
 2121 14b4 93040500 		mv	s1,a0	# tmp136, tmp156
 2122              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 2123 14b8 13050B00 		mv	a0,s6	#, _5
 2124 14bc 97000000 		call	__floatsisf		#
 2124      E7800000 
 2125 14c4 93050500 		mv	a1,a0	# tmp157,
 2126 14c8 13850400 		mv	a0,s1	#, tmp136
 2127 14cc 97000000 		call	__addsf3		#
 2127      E7800000 
 2128              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 2129 14d4 97000000 		call	__fixsfsi		#
 2129      E7800000 
 2130 14dc 2322A400 		sw	a0,4(s0)	# tmp158, <retval>.y
 2131              	# gfx_lib_hdmi.h:303:   return transformed;
 2132 14e0 23248401 		sw	s8,8(s0)	# _7, <retval>.z
 2133              	# gfx_lib_hdmi.h:304: }
 2134 14e4 8320C102 		lw	ra,44(sp)		#,
 2135 14e8 13050400 		mv	a0,s0	#, .result_ptr
 2136 14ec 03248102 		lw	s0,40(sp)		#,
 2137 14f0 83244102 		lw	s1,36(sp)		#,
 2138 14f4 03290102 		lw	s2,32(sp)		#,
 2139 14f8 8329C101 		lw	s3,28(sp)		#,
 2140 14fc 032A8101 		lw	s4,24(sp)		#,
 2141 1500 832A4101 		lw	s5,20(sp)		#,
 2142 1504 032B0101 		lw	s6,16(sp)		#,
 2143 1508 832BC100 		lw	s7,12(sp)		#,
 2144 150c 032C8100 		lw	s8,8(sp)		#,
 2145 1510 13010103 		addi	sp,sp,48	#,,
 2146 1514 67800000 		jr	ra		#
 2148              		.align	2
 2149              		.globl	render_lines
 2151              	render_lines:
 2152 1518 130101F7 		addi	sp,sp,-144	#,,
 2153 151c 23248108 		sw	s0,136(sp)	#,
 2154 1520 13840700 		mv	s0,a5	# scalef, tmp217
 2155              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2156 1524 B7070000 		lui	a5,%hi(.LC5)	# tmp204,
 2157              	# main_house3d_rotate_hdmi.c:65: void render_lines(point points [], size_t s, float angle_x, float 
 2158 1528 232A5107 		sw	s5,116(sp)	#,
 2159              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2160 152c 83AA0700 		lw	s5,%lo(.LC5)(a5)		# tmp205,
 2161              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2162 1530 B7070000 		lui	a5,%hi(.LC6)	# tmp206,
 2163              	# main_house3d_rotate_hdmi.c:65: void render_lines(point points [], size_t s, float angle_x, float 
 2164 1534 23286107 		sw	s6,112(sp)	#,
 2165              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2166 1538 03AB0700 		lw	s6,%lo(.LC6)(a5)		# tmp207,
 2167              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2168 153c B7070000 		lui	a5,%hi(.LC7)	# tmp208,
 2169              	# main_house3d_rotate_hdmi.c:65: void render_lines(point points [], size_t s, float angle_x, float 
 2170 1540 23267107 		sw	s7,108(sp)	#,
 2171              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2172 1544 83AB0700 		lw	s7,%lo(.LC7)(a5)		# tmp209,
 2173              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2174 1548 B7070000 		lui	a5,%hi(.LC8)	# tmp210,
 2175              	# main_house3d_rotate_hdmi.c:65: void render_lines(point points [], size_t s, float angle_x, float 
 2176 154c 23248107 		sw	s8,104(sp)	#,
 2177              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2178 1550 03AC0700 		lw	s8,%lo(.LC8)(a5)		# tmp211,
 2179              	# main_house3d_rotate_hdmi.c:65: void render_lines(point points [], size_t s, float angle_x, float 
 2180 1554 23229108 		sw	s1,132(sp)	#,
 2181 1558 232E3107 		sw	s3,124(sp)	#,
 2182 155c 232C4107 		sw	s4,120(sp)	#,
 2183 1560 2320A107 		sw	s10,96(sp)	#,
 2184 1564 232EB105 		sw	s11,92(sp)	#,
 2185 1568 23261108 		sw	ra,140(sp)	#,
 2186 156c 23202109 		sw	s2,128(sp)	#,
 2187 1570 23229107 		sw	s9,100(sp)	#,
 2188              	# main_house3d_rotate_hdmi.c:65: void render_lines(point points [], size_t s, float angle_x, float 
 2189 1574 938D0500 		mv	s11,a1	# s, tmp213
 2190 1578 2322C100 		sw	a2,4(sp)	# tmp214, %sfp
 2191 157c 93890600 		mv	s3,a3	# angle_y, tmp215
 2192 1580 130A0700 		mv	s4,a4	# angle_z, tmp216
 2193 1584 93040500 		mv	s1,a0	# ivtmp.421, tmp212
 2194              	# main_house3d_rotate_hdmi.c:66:   for (int i = 0; i < s - 1; i = i + 2) {
 2195 1588 130D0000 		li	s10,0		# i,
 2196              	.L209:
 2197              	# main_house3d_rotate_hdmi.c:66:   for (int i = 0; i < s - 1; i = i + 2) {
 2198 158c 9387FDFF 		addi	a5,s11,-1	#, tmp203, s
 2199              	# main_house3d_rotate_hdmi.c:66:   for (int i = 0; i < s - 1; i = i + 2) {
 2200 1590 6360FD04 		bgtu	a5,s10,.L210	#, tmp203, i,
 2201              	# main_house3d_rotate_hdmi.c:91: }
 2202 1594 8320C108 		lw	ra,140(sp)		#,
 2203 1598 03248108 		lw	s0,136(sp)		#,
 2204 159c 83244108 		lw	s1,132(sp)		#,
 2205 15a0 03290108 		lw	s2,128(sp)		#,
 2206 15a4 8329C107 		lw	s3,124(sp)		#,
 2207 15a8 032A8107 		lw	s4,120(sp)		#,
 2208 15ac 832A4107 		lw	s5,116(sp)		#,
 2209 15b0 032B0107 		lw	s6,112(sp)		#,
 2210 15b4 832BC106 		lw	s7,108(sp)		#,
 2211 15b8 032C8106 		lw	s8,104(sp)		#,
 2212 15bc 832C4106 		lw	s9,100(sp)		#,
 2213 15c0 032D0106 		lw	s10,96(sp)		#,
 2214 15c4 832DC105 		lw	s11,92(sp)		#,
 2215 15c8 13010109 		addi	sp,sp,144	#,,
 2216 15cc 67800000 		jr	ra		#
 2217              	.L210:
 2218              	# main_house3d_rotate_hdmi.c:67:     point p0 = points[i];
 2219 15d0 93850400 		mv	a1,s1	#, ivtmp.421
 2220 15d4 1306C000 		li	a2,12		#,
 2221 15d8 1305C102 		addi	a0,sp,44	#, tmp227,
 2222 15dc 97000000 		call	memcpy		#
 2222      E7800000 
 2223              	# main_house3d_rotate_hdmi.c:68:     point p1 = points[i + 1];
 2224 15e4 9385C400 		addi	a1,s1,12	#,, ivtmp.421
 2225 15e8 1306C000 		li	a2,12		#,
 2226 15ec 13058103 		addi	a0,sp,56	#, tmp228,
 2227 15f0 97000000 		call	memcpy		#
 2227      E7800000 
 2228              	# main_house3d_rotate_hdmi.c:71:     p0 = scale(&p0, scalef, scalef, scalef);
 2229 15f8 13070400 		mv	a4,s0	#, scalef
 2230 15fc 93060400 		mv	a3,s0	#, scalef
 2231 1600 13060400 		mv	a2,s0	#, scalef
 2232 1604 9305C102 		addi	a1,sp,44	#, tmp229,
 2233 1608 13050101 		addi	a0,sp,16	#,,
 2234 160c 97000000 		call	scale		#
 2234      E7800000 
 2235 1614 1306C000 		li	a2,12		#,
 2236 1618 93050101 		addi	a1,sp,16	#,,
 2237 161c 1305C102 		addi	a0,sp,44	#, tmp230,
 2238 1620 97000000 		call	memcpy		#
 2238      E7800000 
 2239              	# main_house3d_rotate_hdmi.c:72:     p1 = scale(&p1, scalef, scalef, scalef);
 2240 1628 13070400 		mv	a4,s0	#, scalef
 2241 162c 93060400 		mv	a3,s0	#, scalef
 2242 1630 13060400 		mv	a2,s0	#, scalef
 2243 1634 93058103 		addi	a1,sp,56	#, tmp231,
 2244 1638 13050101 		addi	a0,sp,16	#,,
 2245 163c 97000000 		call	scale		#
 2245      E7800000 
 2246 1644 1306C000 		li	a2,12		#,
 2247 1648 93050101 		addi	a1,sp,16	#,,
 2248 164c 13058103 		addi	a0,sp,56	#, tmp232,
 2249 1650 97000000 		call	memcpy		#
 2249      E7800000 
 2250              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2251 1658 93850A00 		mv	a1,s5	#, tmp205
 2252 165c 13050400 		mv	a0,s0	#, scalef
 2253 1660 97000000 		call	__mulsf3		#
 2253      E7800000 
 2254              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2255 1668 93050500 		mv	a1,a0	#, tmp133
 2256 166c 2326A100 		sw	a0,12(sp)	# tmp133, %sfp
 2257 1670 13050B00 		mv	a0,s6	#, tmp207
 2258 1674 97000000 		call	__subsf3		#
 2258      E7800000 
 2259              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2260 167c 97000000 		call	__fixsfsi		#
 2260      E7800000 
 2261 1684 2324A100 		sw	a0,8(sp)	# _8, %sfp
 2262              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2263 1688 93850B00 		mv	a1,s7	#, tmp209
 2264 168c 13050400 		mv	a0,s0	#, scalef
 2265 1690 97000000 		call	__mulsf3		#
 2265      E7800000 
 2266 1698 93050500 		mv	a1,a0	# tmp220,
 2267              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2268 169c 13050C00 		mv	a0,s8	#, tmp211
 2269 16a0 97000000 		call	__subsf3		#
 2269      E7800000 
 2270              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2271 16a8 97000000 		call	__fixsfsi		#
 2271      E7800000 
 2272 16b0 8327C100 		lw	a5,12(sp)		# tmp133, %sfp
 2273 16b4 37090080 		li	s2,-2147483648		# tmp141,
 2274 16b8 930C0500 		mv	s9,a0	# _11, tmp221
 2275 16bc 3345F900 		xor	a0,s2,a5	# tmp133,, tmp141
 2276 16c0 97000000 		call	__fixsfsi		#
 2276      E7800000 
 2277              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2278 16c8 83264103 		lw	a3,52(sp)		# p0.z, p0.z
 2279              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2280 16cc 03260103 		lw	a2,48(sp)		# p0.y, p0.y
 2281              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2282 16d0 03278100 		lw	a4,8(sp)		# _8, %sfp
 2283              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2284 16d4 B306D500 		add	a3,a0,a3	# p0.z, _59, _12
 2285              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2286 16d8 232AD102 		sw	a3,52(sp)	# _59, p0.z
 2287              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2288 16dc 8326C103 		lw	a3,60(sp)		# p1.y, p1.y
 2289 16e0 3386CC00 		add	a2,s9,a2	# p0.y, _57, _11
 2290              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2291 16e4 8325C102 		lw	a1,44(sp)		# p0.x, p0.x
 2292              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2293 16e8 B38CDC00 		add	s9,s9,a3	# p1.y, _51, _11
 2294              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2295 16ec 83260104 		lw	a3,64(sp)		# p1.z, p1.z
 2296              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2297 16f0 B385E500 		add	a1,a1,a4	# _8, tmp144, p0.x
 2298              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2299 16f4 2326B102 		sw	a1,44(sp)	# tmp144, p0.x
 2300              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2301 16f8 B307D500 		add	a5,a0,a3	# p1.z, _53, _12
 2302              	# main_house3d_rotate_hdmi.c:75:     p1 = translate(&p1, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2303 16fc 2320F104 		sw	a5,64(sp)	# _53, p1.z
 2304              	# main_house3d_rotate_hdmi.c:77:     point pivot = {HRES/2, VRES/2, 0};
 2305 1700 93078002 		li	a5,40		# tmp150,
 2306 1704 2322F104 		sw	a5,68(sp)	# tmp150, pivot.x
 2307 1708 9307E001 		li	a5,30		# tmp151,
 2308              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2309 170c 83268103 		lw	a3,56(sp)		# p1.x, p1.x
 2310              	# main_house3d_rotate_hdmi.c:77:     point pivot = {HRES/2, VRES/2, 0};
 2311 1710 2324F104 		sw	a5,72(sp)	# tmp151, pivot.y
 2312              	# main_house3d_rotate_hdmi.c:79:     p0 = rotateX_pivot(&p0, &pivot, -angle_x);
 2313 1714 83274100 		lw	a5,4(sp)		# tmp233, %sfp
 2314              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2315 1718 3387E600 		add	a4,a3,a4	# _8, tmp148, p1.x
 2316              	# main_house3d_rotate_hdmi.c:75:     p1 = translate(&p1, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2317 171c 232CE102 		sw	a4,56(sp)	# tmp148, p1.x
 2318              	# main_house3d_rotate_hdmi.c:79:     p0 = rotateX_pivot(&p0, &pivot, -angle_x);
 2319 1720 3345F900 		xor	a0,s2,a5	# tmp233,, tmp141
 2320              	# main_house3d_rotate_hdmi.c:74:     p0 = translate(&p0, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2321 1724 2328C102 		sw	a2,48(sp)	# _57, p0.y
 2322              	# main_house3d_rotate_hdmi.c:75:     p1 = translate(&p1, HRES/2 -5*scalef, VRES/2 -15*scalef, -5*sc
 2323 1728 232E9103 		sw	s9,60(sp)	# _51, p1.y
 2324              	# main_house3d_rotate_hdmi.c:77:     point pivot = {HRES/2, VRES/2, 0};
 2325 172c 23260104 		sw	zero,76(sp)	#, pivot.z
 2326              	# main_house3d_rotate_hdmi.c:79:     p0 = rotateX_pivot(&p0, &pivot, -angle_x);
 2327 1730 97000000 		call	__fixsfsi		#
 2327      E7800000 
 2328 1738 93060500 		mv	a3,a0	# _14, tmp223
 2329 173c 2324A100 		sw	a0,8(sp)	# _14, %sfp
 2330 1740 13064104 		addi	a2,sp,68	#, tmp234,
 2331 1744 9305C102 		addi	a1,sp,44	#, tmp235,
 2332 1748 13050101 		addi	a0,sp,16	#,,
 2333 174c 97000000 		call	rotateX_pivot		#
 2333      E7800000 
 2334 1754 1306C000 		li	a2,12		#,
 2335 1758 93050101 		addi	a1,sp,16	#,,
 2336 175c 1305C102 		addi	a0,sp,44	#, tmp236,
 2337 1760 97000000 		call	memcpy		#
 2337      E7800000 
 2338              	# main_house3d_rotate_hdmi.c:80:     p1 = rotateX_pivot(&p1, &pivot, -angle_x);
 2339 1768 83268100 		lw	a3,8(sp)		# _14, %sfp
 2340 176c 13064104 		addi	a2,sp,68	#, tmp237,
 2341 1770 93058103 		addi	a1,sp,56	#, tmp238,
 2342 1774 13050101 		addi	a0,sp,16	#,,
 2343 1778 97000000 		call	rotateX_pivot		#
 2343      E7800000 
 2344 1780 1306C000 		li	a2,12		#,
 2345 1784 93050101 		addi	a1,sp,16	#,,
 2346 1788 13058103 		addi	a0,sp,56	#, tmp239,
 2347 178c 97000000 		call	memcpy		#
 2347      E7800000 
 2348              	# main_house3d_rotate_hdmi.c:81:     p0 = rotateY_pivot(&p0, &pivot, -angle_y);
 2349 1794 33453901 		xor	a0,s2,s3	# angle_y,, tmp141
 2350 1798 97000000 		call	__fixsfsi		#
 2350      E7800000 
 2351 17a0 93060500 		mv	a3,a0	# _16, tmp224
 2352 17a4 2324A100 		sw	a0,8(sp)	# _16, %sfp
 2353 17a8 13064104 		addi	a2,sp,68	#, tmp240,
 2354 17ac 9305C102 		addi	a1,sp,44	#, tmp241,
 2355 17b0 13050101 		addi	a0,sp,16	#,,
 2356 17b4 97000000 		call	rotateY_pivot		#
 2356      E7800000 
 2357 17bc 1306C000 		li	a2,12		#,
 2358 17c0 93050101 		addi	a1,sp,16	#,,
 2359 17c4 1305C102 		addi	a0,sp,44	#, tmp242,
 2360 17c8 97000000 		call	memcpy		#
 2360      E7800000 
 2361              	# main_house3d_rotate_hdmi.c:82:     p1 = rotateY_pivot(&p1, &pivot, -angle_y);
 2362 17d0 83268100 		lw	a3,8(sp)		# _16, %sfp
 2363 17d4 13064104 		addi	a2,sp,68	#, tmp243,
 2364 17d8 93058103 		addi	a1,sp,56	#, tmp244,
 2365 17dc 13050101 		addi	a0,sp,16	#,,
 2366 17e0 97000000 		call	rotateY_pivot		#
 2366      E7800000 
 2367 17e8 1306C000 		li	a2,12		#,
 2368 17ec 93050101 		addi	a1,sp,16	#,,
 2369 17f0 13058103 		addi	a0,sp,56	#, tmp245,
 2370 17f4 97000000 		call	memcpy		#
 2370      E7800000 
 2371              	# main_house3d_rotate_hdmi.c:83:     p0 = rotateZ_pivot(&p0, &pivot, angle_z);
 2372 17fc 13050A00 		mv	a0,s4	#, angle_z
 2373 1800 97000000 		call	__fixsfsi		#
 2373      E7800000 
 2374 1808 93060500 		mv	a3,a0	# _17, tmp225
 2375 180c 2324A100 		sw	a0,8(sp)	# _17, %sfp
 2376 1810 13064104 		addi	a2,sp,68	#, tmp246,
 2377 1814 9305C102 		addi	a1,sp,44	#, tmp247,
 2378 1818 13050101 		addi	a0,sp,16	#,,
 2379 181c 97000000 		call	rotateZ_pivot		#
 2379      E7800000 
 2380 1824 1306C000 		li	a2,12		#,
 2381 1828 93050101 		addi	a1,sp,16	#,,
 2382 182c 1305C102 		addi	a0,sp,44	#, tmp248,
 2383 1830 97000000 		call	memcpy		#
 2383      E7800000 
 2384              	# main_house3d_rotate_hdmi.c:84:     p1 = rotateZ_pivot(&p1, &pivot, angle_z);
 2385 1838 83268100 		lw	a3,8(sp)		# _17, %sfp
 2386 183c 13064104 		addi	a2,sp,68	#, tmp249,
 2387 1840 93058103 		addi	a1,sp,56	#, tmp250,
 2388 1844 13050101 		addi	a0,sp,16	#,,
 2389 1848 97000000 		call	rotateZ_pivot		#
 2389      E7800000 
 2390 1850 1306C000 		li	a2,12		#,
 2391 1854 93050101 		addi	a1,sp,16	#,,
 2392 1858 13058103 		addi	a0,sp,56	#, tmp251,
 2393 185c 97000000 		call	memcpy		#
 2393      E7800000 
 2394              	# main_house3d_rotate_hdmi.c:88:     fb_draw_bresenham(framebuffer, p0.x, p0.y, p1.x, p1.y, 0x00fff
 2395 1864 0327C103 		lw	a4,60(sp)		#, p1.y
 2396 1868 83268103 		lw	a3,56(sp)		#, p1.x
 2397 186c 03260103 		lw	a2,48(sp)		#, p0.y
 2398 1870 8325C102 		lw	a1,44(sp)		#, p0.x
 2399 1874 37050000 		lui	a0,%hi(framebuffer)	# tmp202,
 2400 1878 9307F0FF 		li	a5,-1		#,
 2401 187c 13050500 		addi	a0,a0,%lo(framebuffer)	#, tmp202,
 2402 1880 97000000 		call	fb_draw_bresenham		#
 2402      E7800000 
 2403              	# main_house3d_rotate_hdmi.c:66:   for (int i = 0; i < s - 1; i = i + 2) {
 2404 1888 130D2D00 		addi	s10,s10,2	#, i, i
 2405 188c 93848401 		addi	s1,s1,24	#, ivtmp.421, ivtmp.421
 2406 1890 6FF0DFCF 		j	.L209		#
 2408              		.globl	__gesf2
 2409              		.globl	__lesf2
 2410              		.section	.text.startup,"ax",@progbits
 2411              		.align	2
 2412              		.globl	main
 2414              	main:
 2415 0000 130101FC 		addi	sp,sp,-64	#,,
 2416 0004 23244103 		sw	s4,40(sp)	#,
 2417              	# main_house3d_rotate_hdmi.c:99:   fill_oled(framebuffer, 0x0000);
 2418 0008 370A0000 		lui	s4,%hi(framebuffer)	# tmp88,
 2419 000c 93050000 		li	a1,0		#,
 2420 0010 13050A00 		addi	a0,s4,%lo(framebuffer)	#, tmp88,
 2421              	# main_house3d_rotate_hdmi.c:97: void main() {
 2422 0014 232C8102 		sw	s0,56(sp)	#,
 2423 0018 232A9102 		sw	s1,52(sp)	#,
 2424 001c 23282103 		sw	s2,48(sp)	#,
 2425 0020 23263103 		sw	s3,44(sp)	#,
 2426 0024 23225103 		sw	s5,36(sp)	#,
 2427 0028 23206103 		sw	s6,32(sp)	#,
 2428 002c 232E7101 		sw	s7,28(sp)	#,
 2429 0030 232A9101 		sw	s9,20(sp)	#,
 2430 0034 2328A101 		sw	s10,16(sp)	#,
 2431 0038 2326B101 		sw	s11,12(sp)	#,
 2432 003c 232E1102 		sw	ra,60(sp)	#,
 2433 0040 232C8101 		sw	s8,24(sp)	#,
 2434              	# main_house3d_rotate_hdmi.c:99:   fill_oled(framebuffer, 0x0000);
 2435 0044 97000000 		call	fill_oled		#
 2435      E7800000 
 2436              	# main_house3d_rotate_hdmi.c:107:   *fb_ctrl = 0;
 2437 004c B7070030 		li	a5,805306368		# tmp90,
 2438              	# main_house3d_rotate_hdmi.c:109:   IO_OUT(GPIO_DIR, ~0);
 2439 0050 1307F0FF 		li	a4,-1		# tmp93,
 2440              	# main_house3d_rotate_hdmi.c:107:   *fb_ctrl = 0;
 2441 0054 23A20702 		sw	zero,36(a5)	#, MEM[(uint32_t *)805306404B]
 2442              	# main_house3d_rotate_hdmi.c:109:   IO_OUT(GPIO_DIR, ~0);
 2443 0058 23AAE700 		sw	a4,20(a5)	# tmp93, MEM[(volatile uint32_t *)805306388B]
 2444              	# main_house3d_rotate_hdmi.c:105:   float delta_scale = 0.1;//0.8; /* speedup scale */
 2445 005c B7070000 		lui	a5,%hi(.LC9)	# tmp86,
 2446 0060 03A90700 		lw	s2,%lo(.LC9)(a5)		# delta_scale,
 2447              	# main_house3d_rotate_hdmi.c:104:   float s = 4;
 2448 0064 B7070000 		lui	a5,%hi(.LC10)	# tmp87,
 2449 0068 03A40700 		lw	s0,%lo(.LC10)(a5)		# s,
 2450              	# main_house3d_rotate_hdmi.c:128:     if (s >= 10) delta_scale = -delta_scale;
 2451 006c B7070000 		lui	a5,%hi(.LC11)	# tmp138,
 2452              	# main_house3d_rotate_hdmi.c:112:     render_lines(front, SIZEOF(front), angle, angle, angle, s);
 2453 0070 B7040000 		lui	s1,%hi(.LANCHOR2)	# tmp95,
 2454              	# main_house3d_rotate_hdmi.c:128:     if (s >= 10) delta_scale = -delta_scale;
 2455 0074 83AD0700 		lw	s11,%lo(.LC11)(a5)		# tmp137,
 2456              	# main_house3d_rotate_hdmi.c:112:     render_lines(front, SIZEOF(front), angle, angle, angle, s);
 2457 0078 93840400 		addi	s1,s1,%lo(.LANCHOR2)	# tmp94, tmp95,
 2458              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 2459 007c B71A0000 		li	s5,4096		# tmp127,
 2460              	# main_house3d_rotate_hdmi.c:110:   uint8_t led = 0x01;
 2461 0080 130B1000 		li	s6,1		# led,
 2462              	# main_house3d_rotate_hdmi.c:101:   int angle = 0;
 2463 0084 93090000 		li	s3,0		# angle,
 2464              	# main_house3d_rotate_hdmi.c:114:     render_lines(left_bottom, SIZEOF(left_bottom), angle,angle, a
 2465 0088 938C041F 		addi	s9,s1,496	#, tmp102, tmp94
 2466              	# main_house3d_rotate_hdmi.c:115:     render_lines(left_top, SIZEOF(left_top), angle,angle, angle, 
 2467 008c 138D8420 		addi	s10,s1,520	#, tmp105, tmp94
 2468              	# main_house3d_rotate_hdmi.c:120:     oled_show_fb_8or16(framebuffer, 0x10000000 + ((*fb_ctrl & 1) 
 2469 0090 B70B0030 		li	s7,805306368		# tmp116,
 2470              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 2471 0094 938A0A2C 		addi	s5,s5,704	#, tmp126, tmp127
 2472              	.L219:
 2473              	# main_house3d_rotate_hdmi.c:112:     render_lines(front, SIZEOF(front), angle, angle, angle, s);
 2474 0098 13850900 		mv	a0,s3	#, angle
 2475 009c 97000000 		call	__floatsisf		#
 2475      E7800000 
 2476 00a4 130C0500 		mv	s8,a0	# _1, tmp160
 2477 00a8 13070500 		mv	a4,a0	#, _1
 2478 00ac 93060500 		mv	a3,a0	#, _1
 2479 00b0 13060500 		mv	a2,a0	#, _1
 2480 00b4 37050000 		lui	a0,%hi(.LANCHOR2+40)	# tmp172,
 2481 00b8 93070400 		mv	a5,s0	#, s
 2482 00bc 9305A001 		li	a1,26		#,
 2483 00c0 13058502 		addi	a0,a0,%lo(.LANCHOR2+40)	# tmp171, tmp172,
 2484 00c4 97000000 		call	render_lines		#
 2484      E7800000 
 2485              	# main_house3d_rotate_hdmi.c:113:     render_lines(back, SIZEOF(back), angle,angle, angle,  s);
 2486 00cc 37050000 		lui	a0,%hi(.LANCHOR2+352)	# tmp174,
 2487 00d0 93070400 		mv	a5,s0	#, s
 2488 00d4 13070C00 		mv	a4,s8	#, _1
 2489 00d8 93060C00 		mv	a3,s8	#, _1
 2490 00dc 13060C00 		mv	a2,s8	#, _1
 2491 00e0 9305C000 		li	a1,12		#,
 2492 00e4 13050516 		addi	a0,a0,%lo(.LANCHOR2+352)	# tmp173, tmp174,
 2493 00e8 97000000 		call	render_lines		#
 2493      E7800000 
 2494              	# main_house3d_rotate_hdmi.c:114:     render_lines(left_bottom, SIZEOF(left_bottom), angle,angle, a
 2495 00f0 93070400 		mv	a5,s0	#, s
 2496 00f4 13070C00 		mv	a4,s8	#, _1
 2497 00f8 93060C00 		mv	a3,s8	#, _1
 2498 00fc 13060C00 		mv	a2,s8	#, _1
 2499 0100 93052000 		li	a1,2		#,
 2500 0104 13850C00 		mv	a0,s9	#, tmp102
 2501 0108 97000000 		call	render_lines		#
 2501      E7800000 
 2502              	# main_house3d_rotate_hdmi.c:115:     render_lines(left_top, SIZEOF(left_top), angle,angle, angle, 
 2503 0110 93070400 		mv	a5,s0	#, s
 2504 0114 13070C00 		mv	a4,s8	#, _1
 2505 0118 93060C00 		mv	a3,s8	#, _1
 2506 011c 13060C00 		mv	a2,s8	#, _1
 2507 0120 93052000 		li	a1,2		#,
 2508 0124 13050D00 		mv	a0,s10	#, tmp105
 2509 0128 97000000 		call	render_lines		#
 2509      E7800000 
 2510              	# main_house3d_rotate_hdmi.c:116:     render_lines(right_bottom, SIZEOF(left_bottom), angle,angle, 
 2511 0130 93070400 		mv	a5,s0	#, s
 2512 0134 13070C00 		mv	a4,s8	#, _1
 2513 0138 93060C00 		mv	a3,s8	#, _1
 2514 013c 13060C00 		mv	a2,s8	#, _1
 2515 0140 93052000 		li	a1,2		#,
 2516 0144 13850422 		addi	a0,s1,544	#,, tmp94
 2517 0148 97000000 		call	render_lines		#
 2517      E7800000 
 2518              	# main_house3d_rotate_hdmi.c:117:     render_lines(right_top, SIZEOF(left_top), angle,angle, angle,
 2519 0150 93070400 		mv	a5,s0	#, s
 2520 0154 13070C00 		mv	a4,s8	#, _1
 2521 0158 93060C00 		mv	a3,s8	#, _1
 2522 015c 13060C00 		mv	a2,s8	#, _1
 2523 0160 93052000 		li	a1,2		#,
 2524 0164 13858423 		addi	a0,s1,568	#,, tmp94
 2525 0168 97000000 		call	render_lines		#
 2525      E7800000 
 2526              	# main_house3d_rotate_hdmi.c:118:     render_lines(roof, SIZEOF(roof), angle,angle, angle,  s);
 2527 0170 93070400 		mv	a5,s0	#, s
 2528 0174 13070C00 		mv	a4,s8	#, _1
 2529 0178 93060C00 		mv	a3,s8	#, tmp14
 2530 017c 13060C00 		mv	a2,s8	#, tmp14
 2531 0180 93052000 		li	a1,2		#,
 2532 0184 13850425 		addi	a0,s1,592	#,, tmp94
 2533 0188 97000000 		call	render_lines		#
 2533      E7800000 
 2534              	# main_house3d_rotate_hdmi.c:120:     oled_show_fb_8or16(framebuffer, 0x10000000 + ((*fb_ctrl & 1) 
 2535 0190 83A74B02 		lw	a5,36(s7)		# MEM[(uint32_t *)805306404B], MEM[(uint32_t *)805306404B]
 2536              	# main_house3d_rotate_hdmi.c:120:     oled_show_fb_8or16(framebuffer, 0x10000000 + ((*fb_ctrl & 1) 
 2537 0194 37070010 		li	a4,268435456		# iftmp.57_14,
 2538              	# main_house3d_rotate_hdmi.c:120:     oled_show_fb_8or16(framebuffer, 0x10000000 + ((*fb_ctrl & 1) 
 2539 0198 93F71700 		andi	a5,a5,1	#, tmp117, MEM[(uint32_t *)805306404B]
 2540              	# main_house3d_rotate_hdmi.c:120:     oled_show_fb_8or16(framebuffer, 0x10000000 + ((*fb_ctrl & 1) 
 2541 019c 63940700 		bne	a5,zero,.L213	#, tmp117,,
 2542 01a0 37870010 		li	a4,268468224		# iftmp.57_14,
 2543              	.L213:
 2544              	# gfx_lib_hdmi.h:130:   dma_action((uint32_t) framebuffer, target_fb, VRES*HRES, DMA_MEMCPY);
 2545 01a4 93070A00 		addi	a5,s4,%lo(framebuffer)	# framebuffer.47_37, tmp88,
 2546              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
 2547 01a8 23A6FB02 		sw	a5,44(s7)	# framebuffer.47_37, MEM[(volatile uint32_t *)805306412B]
 2548              	# kianv_stdlib.h:52:   *( (volatile uint32_t*) DMA_DST  ) = dst;
 2549 01ac 23A8EB02 		sw	a4,48(s7)	# iftmp.57_14, MEM[(volatile uint32_t *)805306416B]
 2550              	# kianv_stdlib.h:54:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
 2551 01b0 93071000 		li	a5,1		# tmp130,
 2552              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 2553 01b4 23AA5B03 		sw	s5,52(s7)	# tmp126, MEM[(volatile uint32_t *)805306420B]
 2554              	# kianv_stdlib.h:54:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
 2555 01b8 23ACFB02 		sw	a5,56(s7)	# tmp130, MEM[(volatile uint32_t *)805306424B]
 2556              	# main_house3d_rotate_hdmi.c:121:     *fb_ctrl ^= 1;
 2557 01bc 83A74B02 		lw	a5,36(s7)		# MEM[(uint32_t *)805306404B], MEM[(uint32_t *)805306404B]
 2558              	# main_house3d_rotate_hdmi.c:124:     angle += delta_angle;
 2559 01c0 9389E9FF 		addi	s3,s3,-2	#, angle, angle
 2560              	# main_house3d_rotate_hdmi.c:121:     *fb_ctrl ^= 1;
 2561 01c4 93C71700 		xori	a5,a5,1	#, tmp135, MEM[(uint32_t *)805306404B]
 2562 01c8 23A2FB02 		sw	a5,36(s7)	# tmp135, MEM[(uint32_t *)805306404B]
 2563              	# main_house3d_rotate_hdmi.c:127:     if (angle < 0) angle = 359;
 2564 01cc 63D40900 		bge	s3,zero,.L214	#, angle,,
 2565              	# main_house3d_rotate_hdmi.c:127:     if (angle < 0) angle = 359;
 2566 01d0 93097016 		li	s3,359		# angle,
 2567              	.L214:
 2568              	# main_house3d_rotate_hdmi.c:128:     if (s >= 10) delta_scale = -delta_scale;
 2569 01d4 93850D00 		mv	a1,s11	#, tmp137
 2570 01d8 13050400 		mv	a0,s0	#, s
 2571 01dc 97000000 		call	__gesf2		#
 2571      E7800000 
 2572 01e4 63460500 		blt	a0,zero,.L215	#, tmp161,,
 2573              	# main_house3d_rotate_hdmi.c:128:     if (s >= 10) delta_scale = -delta_scale;
 2574 01e8 B7070080 		li	a5,-2147483648		# tmp141,
 2575 01ec 33C92701 		xor	s2,a5,s2	# delta_scale, delta_scale, tmp141
 2576              	.L215:
 2577              	# main_house3d_rotate_hdmi.c:129:     if (s <= 0) delta_scale = -delta_scale;
 2578 01f0 93050000 		mv	a1,zero	#,
 2579 01f4 13050400 		mv	a0,s0	#, s
 2580 01f8 97000000 		call	__lesf2		#
 2580      E7800000 
 2581 0200 6346A000 		bgt	a0,zero,.L217	#, tmp162,,
 2582              	# main_house3d_rotate_hdmi.c:129:     if (s <= 0) delta_scale = -delta_scale;
 2583 0204 B7070080 		li	a5,-2147483648		# tmp144,
 2584 0208 33C92701 		xor	s2,a5,s2	# delta_scale, delta_scale, tmp144
 2585              	.L217:
 2586              	# main_house3d_rotate_hdmi.c:130:     s += delta_scale;
 2587 020c 93050900 		mv	a1,s2	#, delta_scale
 2588 0210 13050400 		mv	a0,s0	#, s
 2589 0214 97000000 		call	__addsf3		#
 2589      E7800000 
 2590 021c 13040500 		mv	s0,a0	# s, tmp163
 2591              	# main_house3d_rotate_hdmi.c:132:     fill_oled(framebuffer, 0x000000);
 2592 0220 93050000 		li	a1,0		#,
 2593 0224 13050A00 		addi	a0,s4,%lo(framebuffer)	#, tmp88,
 2594 0228 97000000 		call	fill_oled		#
 2594      E7800000 
 2595              	# main_house3d_rotate_hdmi.c:134:     led &= 7;
 2596 0230 13757B00 		andi	a0,s6,7	#, led, led
 2597              	# main_house3d_rotate_hdmi.c:133:     IO_OUT(GPIO_OUTPUT, 0);
 2598 0234 23AE0B00 		sw	zero,28(s7)	#, MEM[(volatile uint32_t *)805306396B]
 2599              	# main_house3d_rotate_hdmi.c:136:     gpio_set_value(led++, 1);
 2600 0238 93051000 		li	a1,1		#,
 2601              	# main_house3d_rotate_hdmi.c:136:     gpio_set_value(led++, 1);
 2602 023c 130B1500 		addi	s6,a0,1	#, led, led
 2603              	# main_house3d_rotate_hdmi.c:136:     gpio_set_value(led++, 1);
 2604 0240 97000000 		call	gpio_set_value		#
 2604      E7800000 
 2605              	# main_house3d_rotate_hdmi.c:112:     render_lines(front, SIZEOF(front), angle, angle, angle, s);
 2606 0248 6FF01FE5 		j	.L219		#
 2608              		.globl	roof
 2609              		.globl	right_bottom
 2610              		.globl	right_top
 2611              		.globl	left_bottom
 2612              		.globl	left_top
 2613              		.globl	back
 2614              		.globl	oled_8bit_init_seq
 2615              		.globl	framebuffer
 2616              		.globl	heap_memory_used
 2617              		.globl	heap_memory
 2618              		.section	.srodata.cst8,"aM",@progbits,8
 2619              		.align	3
 2620              	.LC2:
 2621 0000 00000000 		.word	0
 2622 0004 0000E040 		.word	1088421888
 2623              		.align	3
 2624              	.LC3:
 2625 0008 00000000 		.word	0
 2626 000c 00807640 		.word	1081507840
 2627              		.align	3
 2628              	.LC4:
 2629 0010 80004000 		.word	4194432
 2630 0014 2000003F 		.word	1056964640
 2631              		.section	.srodata.cst4,"aM",@progbits,4
 2632              		.align	2
 2633              	.LC5:
 2634 0000 0000A040 		.word	1084227584
 2635              		.align	2
 2636              	.LC6:
 2637 0004 00002042 		.word	1109393408
 2638              		.align	2
 2639              	.LC7:
 2640 0008 00007041 		.word	1097859072
 2641              		.align	2
 2642              	.LC8:
 2643 000c 0000F041 		.word	1106247680
 2644              		.align	2
 2645              	.LC9:
 2646 0010 CDCCCC3D 		.word	1036831949
 2647              		.align	2
 2648              	.LC10:
 2649 0014 00008040 		.word	1082130432
 2650              		.align	2
 2651              	.LC11:
 2652 0018 00002041 		.word	1092616192
 2653              		.section	.rodata
 2654              		.align	2
 2655              		.set	.LANCHOR1,. + 0
 2658              	sin90:
 2659 0000 0000     		.half	0
 2660 0002 4706     		.half	1607
 2661 0004 8B0C     		.half	3211
 2662 0006 C712     		.half	4807
 2663 0008 F818     		.half	6392
 2664 000a 191F     		.half	7961
 2665 000c 2725     		.half	9511
 2666 000e 1E2B     		.half	11038
 2667 0010 FB30     		.half	12539
 2668 0012 B936     		.half	14009
 2669 0014 563C     		.half	15446
 2670 0016 CD41     		.half	16845
 2671 0018 1C47     		.half	18204
 2672 001a 3F4C     		.half	19519
 2673 001c 3351     		.half	20787
 2674 001e F455     		.half	22004
 2675 0020 815A     		.half	23169
 2676 0022 D65E     		.half	24278
 2677 0024 F162     		.half	25329
 2678 0026 CE66     		.half	26318
 2679 0028 6C6A     		.half	27244
 2680 002a C96D     		.half	28105
 2681 002c E170     		.half	28897
 2682 002e B573     		.half	29621
 2683 0030 4076     		.half	30272
 2684 0032 8378     		.half	30851
 2685 0034 7C7A     		.half	31356
 2686 0036 297C     		.half	31785
 2687 0038 897D     		.half	32137
 2688 003a 9C7E     		.half	32412
 2689 003c 617F     		.half	32609
 2690 003e D77F     		.half	32727
 2691 0040 FF7F     		.half	32767
 2692              		.data
 2693              		.align	2
 2694              		.set	.LANCHOR2,. + 0
 2697              	oled_8bit_init_seq:
 2698 0000 AEA032A1 		.string	"\256\2402\241"
 2698      00
 2699 0005 A200     		.string	"\242"
 2700 0007 A4A83FAD 		.ascii	"\244\250?\255\216\260\013\2611\263\360\212d\213x\214d\273:\276"
 2700      8EB00BB1 
 2700      31B3F08A 
 2700      648B788C 
 2700      64BB3ABE 
 2701 001b 3E870681 		.ascii	">\207\006\201\221\202P\203}\257"
 2701      91825083 
 2701      7DAF
 2702 0025 000000   		.zero	3
 2705              	front:
 2706              	# x:
 2707 0028 00000000 		.word	0
 2708              	# y:
 2709 002c 0A000000 		.word	10
 2710              	# z:
 2711 0030 00000000 		.word	0
 2712              	# x:
 2713 0034 05000000 		.word	5
 2714              	# y:
 2715 0038 05000000 		.word	5
 2716              	# z:
 2717 003c 00000000 		.word	0
 2718              	# x:
 2719 0040 05000000 		.word	5
 2720              	# y:
 2721 0044 05000000 		.word	5
 2722              	# z:
 2723 0048 00000000 		.word	0
 2724              	# x:
 2725 004c 0A000000 		.word	10
 2726              	# y:
 2727 0050 0A000000 		.word	10
 2728              	# z:
 2729 0054 00000000 		.word	0
 2730              	# x:
 2731 0058 00000000 		.word	0
 2732              	# y:
 2733 005c 0A000000 		.word	10
 2734              	# z:
 2735 0060 00000000 		.word	0
 2736              	# x:
 2737 0064 0A000000 		.word	10
 2738              	# y:
 2739 0068 0A000000 		.word	10
 2740              	# z:
 2741 006c 00000000 		.word	0
 2742              	# x:
 2743 0070 0A000000 		.word	10
 2744              	# y:
 2745 0074 0A000000 		.word	10
 2746              	# z:
 2747 0078 00000000 		.word	0
 2748              	# x:
 2749 007c 0A000000 		.word	10
 2750              	# y:
 2751 0080 14000000 		.word	20
 2752              	# z:
 2753 0084 00000000 		.word	0
 2754              	# x:
 2755 0088 0A000000 		.word	10
 2756              	# y:
 2757 008c 14000000 		.word	20
 2758              	# z:
 2759 0090 00000000 		.word	0
 2760              	# x:
 2761 0094 00000000 		.word	0
 2762              	# y:
 2763 0098 14000000 		.word	20
 2764              	# z:
 2765 009c 00000000 		.word	0
 2766              	# x:
 2767 00a0 00000000 		.word	0
 2768              	# y:
 2769 00a4 14000000 		.word	20
 2770              	# z:
 2771 00a8 00000000 		.word	0
 2772              	# x:
 2773 00ac 00000000 		.word	0
 2774              	# y:
 2775 00b0 0A000000 		.word	10
 2776              	# z:
 2777 00b4 00000000 		.word	0
 2778              	# x:
 2779 00b8 08000000 		.word	8
 2780              	# y:
 2781 00bc 14000000 		.word	20
 2782              	# z:
 2783 00c0 00000000 		.word	0
 2784              	# x:
 2785 00c4 08000000 		.word	8
 2786              	# y:
 2787 00c8 11000000 		.word	17
 2788              	# z:
 2789 00cc 00000000 		.word	0
 2790              	# x:
 2791 00d0 08000000 		.word	8
 2792              	# y:
 2793 00d4 11000000 		.word	17
 2794              	# z:
 2795 00d8 00000000 		.word	0
 2796              	# x:
 2797 00dc 06000000 		.word	6
 2798              	# y:
 2799 00e0 11000000 		.word	17
 2800              	# z:
 2801 00e4 00000000 		.word	0
 2802              	# x:
 2803 00e8 06000000 		.word	6
 2804              	# y:
 2805 00ec 11000000 		.word	17
 2806              	# z:
 2807 00f0 00000000 		.word	0
 2808              	# x:
 2809 00f4 06000000 		.word	6
 2810              	# y:
 2811 00f8 14000000 		.word	20
 2812              	# z:
 2813 00fc 00000000 		.word	0
 2814              	# x:
 2815 0100 01000000 		.word	1
 2816              	# y:
 2817 0104 0D000000 		.word	13
 2818              	# z:
 2819 0108 00000000 		.word	0
 2820              	# x:
 2821 010c 04000000 		.word	4
 2822              	# y:
 2823 0110 0D000000 		.word	13
 2824              	# z:
 2825 0114 00000000 		.word	0
 2826              	# x:
 2827 0118 04000000 		.word	4
 2828              	# y:
 2829 011c 0D000000 		.word	13
 2830              	# z:
 2831 0120 00000000 		.word	0
 2832              	# x:
 2833 0124 04000000 		.word	4
 2834              	# y:
 2835 0128 10000000 		.word	16
 2836              	# z:
 2837 012c 00000000 		.word	0
 2838              	# x:
 2839 0130 04000000 		.word	4
 2840              	# y:
 2841 0134 10000000 		.word	16
 2842              	# z:
 2843 0138 00000000 		.word	0
 2844              	# x:
 2845 013c 01000000 		.word	1
 2846              	# y:
 2847 0140 10000000 		.word	16
 2848              	# z:
 2849 0144 00000000 		.word	0
 2850              	# x:
 2851 0148 01000000 		.word	1
 2852              	# y:
 2853 014c 10000000 		.word	16
 2854              	# z:
 2855 0150 00000000 		.word	0
 2856              	# x:
 2857 0154 01000000 		.word	1
 2858              	# y:
 2859 0158 0D000000 		.word	13
 2860              	# z:
 2861 015c 00000000 		.word	0
 2864              	back:
 2865              	# x:
 2866 0160 00000000 		.word	0
 2867              	# y:
 2868 0164 0A000000 		.word	10
 2869              	# z:
 2870 0168 0A000000 		.word	10
 2871              	# x:
 2872 016c 05000000 		.word	5
 2873              	# y:
 2874 0170 05000000 		.word	5
 2875              	# z:
 2876 0174 0A000000 		.word	10
 2877              	# x:
 2878 0178 05000000 		.word	5
 2879              	# y:
 2880 017c 05000000 		.word	5
 2881              	# z:
 2882 0180 0A000000 		.word	10
 2883              	# x:
 2884 0184 0A000000 		.word	10
 2885              	# y:
 2886 0188 0A000000 		.word	10
 2887              	# z:
 2888 018c 0A000000 		.word	10
 2889              	# x:
 2890 0190 00000000 		.word	0
 2891              	# y:
 2892 0194 0A000000 		.word	10
 2893              	# z:
 2894 0198 0A000000 		.word	10
 2895              	# x:
 2896 019c 0A000000 		.word	10
 2897              	# y:
 2898 01a0 0A000000 		.word	10
 2899              	# z:
 2900 01a4 0A000000 		.word	10
 2901              	# x:
 2902 01a8 0A000000 		.word	10
 2903              	# y:
 2904 01ac 0A000000 		.word	10
 2905              	# z:
 2906 01b0 0A000000 		.word	10
 2907              	# x:
 2908 01b4 0A000000 		.word	10
 2909              	# y:
 2910 01b8 14000000 		.word	20
 2911              	# z:
 2912 01bc 0A000000 		.word	10
 2913              	# x:
 2914 01c0 0A000000 		.word	10
 2915              	# y:
 2916 01c4 14000000 		.word	20
 2917              	# z:
 2918 01c8 0A000000 		.word	10
 2919              	# x:
 2920 01cc 00000000 		.word	0
 2921              	# y:
 2922 01d0 14000000 		.word	20
 2923              	# z:
 2924 01d4 0A000000 		.word	10
 2925              	# x:
 2926 01d8 00000000 		.word	0
 2927              	# y:
 2928 01dc 14000000 		.word	20
 2929              	# z:
 2930 01e0 0A000000 		.word	10
 2931              	# x:
 2932 01e4 00000000 		.word	0
 2933              	# y:
 2934 01e8 0A000000 		.word	10
 2935              	# z:
 2936 01ec 0A000000 		.word	10
 2939              	left_bottom:
 2940              	# x:
 2941 01f0 00000000 		.word	0
 2942              	# y:
 2943 01f4 14000000 		.word	20
 2944              	# z:
 2945 01f8 00000000 		.word	0
 2946              	# x:
 2947 01fc 00000000 		.word	0
 2948              	# y:
 2949 0200 14000000 		.word	20
 2950              	# z:
 2951 0204 0A000000 		.word	10
 2954              	left_top:
 2955              	# x:
 2956 0208 00000000 		.word	0
 2957              	# y:
 2958 020c 0A000000 		.word	10
 2959              	# z:
 2960 0210 00000000 		.word	0
 2961              	# x:
 2962 0214 00000000 		.word	0
 2963              	# y:
 2964 0218 0A000000 		.word	10
 2965              	# z:
 2966 021c 0A000000 		.word	10
 2969              	right_bottom:
 2970              	# x:
 2971 0220 0A000000 		.word	10
 2972              	# y:
 2973 0224 14000000 		.word	20
 2974              	# z:
 2975 0228 00000000 		.word	0
 2976              	# x:
 2977 022c 0A000000 		.word	10
 2978              	# y:
 2979 0230 14000000 		.word	20
 2980              	# z:
 2981 0234 0A000000 		.word	10
 2984              	right_top:
 2985              	# x:
 2986 0238 0A000000 		.word	10
 2987              	# y:
 2988 023c 0A000000 		.word	10
 2989              	# z:
 2990 0240 00000000 		.word	0
 2991              	# x:
 2992 0244 0A000000 		.word	10
 2993              	# y:
 2994 0248 0A000000 		.word	10
 2995              	# z:
 2996 024c 0A000000 		.word	10
 2999              	roof:
 3000              	# x:
 3001 0250 05000000 		.word	5
 3002              	# y:
 3003 0254 05000000 		.word	5
 3004              	# z:
 3005 0258 00000000 		.word	0
 3006              	# x:
 3007 025c 05000000 		.word	5
 3008              	# y:
 3009 0260 05000000 		.word	5
 3010              	# z:
 3011 0264 0A000000 		.word	10
 3012              		.bss
 3013              		.align	2
 3014              		.set	.LANCHOR0,. + 0
 3017              	heap_memory:
 3018 0000 00000000 		.zero	1024
 3018      00000000 
 3018      00000000 
 3018      00000000 
 3018      00000000 
 3021              	framebuffer:
 3022 0400 00000000 		.zero	19200
 3022      00000000 
 3022      00000000 
 3022      00000000 
 3022      00000000 
 3023              		.section	.sbss,"aw",@nobits
 3024              		.align	2
 3027              	heap_memory_used:
 3028 0000 00000000 		.zero	4
 3029              		.ident	"GCC: (GNU) 11.1.0"
