   1              		.file	"main_balls_hdmi.c"
   2              		.option nopic
   3              		.attribute arch, "rv32i2p0_m2p0"
   4              		.attribute unaligned_access, 0
   5              		.attribute stack_align, 16
   6              	# GNU C17 (GCC) version 11.1.0 (riscv32-unknown-elf)
   7              	#	compiled by GNU C version 9.3.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl ve
   8              	# warning: GMP header version 6.2.0 differs from library version 6.3.0.
   9              	# warning: MPFR header version 4.0.2 differs from library version 4.2.1.
  10              	# warning: MPC header version 1.1.0 differs from library version 1.3.1.
  11              	# GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
  12              	# options passed: -march=rv32im -mabi=ilp32 -mtune=rocket -march=rv32im -O3 -fno-pic -fno-stack-pro
  13              		.text
  14              		.align	2
  15              		.globl	dma_action
  17              	dma_action:
  18              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
  19 0000 B7070030 		li	a5,805306368		# tmp77,
  20 0004 23A6A702 		sw	a0,44(a5)	# src, MEM[(volatile uint32_t *)805306412B]
  21              	# kianv_stdlib.h:52:   *( (volatile uint32_t*) DMA_DST  ) = dst;
  22 0008 23A8B702 		sw	a1,48(a5)	# dst, MEM[(volatile uint32_t *)805306416B]
  23              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
  24 000c 23AAC702 		sw	a2,52(a5)	# len, MEM[(volatile uint32_t *)805306420B]
  25              	# kianv_stdlib.h:54:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
  26 0010 23ACD702 		sw	a3,56(a5)	# ctrl, MEM[(volatile uint32_t *)805306424B]
  27              	# kianv_stdlib.h:55: }
  28 0014 67800000 		ret	
  30              		.align	2
  31              		.globl	_sendCmd
  33              	_sendCmd:
  34              	# kianv_stdlib.h:62:     *((volatile uint32_t *) VIDEO_RAW) = ((0x00) << 8) | c;
  35 0018 B7070030 		li	a5,805306368		# tmp75,
  36 001c 23A6A700 		sw	a0,12(a5)	# c, MEM[(volatile uint32_t *)805306380B]
  37              	# kianv_stdlib.h:64: }
  38 0020 67800000 		ret	
  40              		.align	2
  41              		.globl	_sendData
  43              	_sendData:
  44              	# kianv_stdlib.h:71:     *((volatile uint32_t *) VIDEO_RAW) = ((0x01) << 8) | c;
  45 0024 13650510 		ori	a0,a0,256	#, _3, tmp78
  46              	# kianv_stdlib.h:71:     *((volatile uint32_t *) VIDEO_RAW) = ((0x01) << 8) | c;
  47 0028 B7070030 		li	a5,805306368		# tmp77,
  48 002c 23A6A700 		sw	a0,12(a5)	# _3, MEM[(volatile uint32_t *)805306380B]
  49              	# kianv_stdlib.h:73: }
  50 0030 67800000 		ret	
  52              		.align	2
  53              		.globl	init_oled1331
  55              	init_oled1331:
  56              	# kianv_stdlib.h:62:     *((volatile uint32_t *) VIDEO_RAW) = ((0x00) << 8) | c;
  57 0034 B7070030 		li	a5,805306368		# tmp73,
  58 0038 1307E00A 		li	a4,174		# tmp74,
  59 003c 23A6E700 		sw	a4,12(a5)	# tmp74, MEM[(volatile uint32_t *)805306380B]
  60 0040 13071008 		li	a4,129		# tmp77,
  61 0044 23A6E700 		sw	a4,12(a5)	# tmp77, MEM[(volatile uint32_t *)805306380B]
  62 0048 13071009 		li	a4,145		# tmp80,
  63 004c 23A6E700 		sw	a4,12(a5)	# tmp80, MEM[(volatile uint32_t *)805306380B]
  64 0050 13072008 		li	a4,130		# tmp83,
  65 0054 23A6E700 		sw	a4,12(a5)	# tmp83, MEM[(volatile uint32_t *)805306380B]
  66 0058 13070008 		li	a4,128		# tmp86,
  67 005c 23A6E700 		sw	a4,12(a5)	# tmp86, MEM[(volatile uint32_t *)805306380B]
  68 0060 13073008 		li	a4,131		# tmp89,
  69 0064 23A6E700 		sw	a4,12(a5)	# tmp89, MEM[(volatile uint32_t *)805306380B]
  70 0068 1307D007 		li	a4,125		# tmp92,
  71 006c 23A6E700 		sw	a4,12(a5)	# tmp92, MEM[(volatile uint32_t *)805306380B]
  72 0070 13077008 		li	a4,135		# tmp95,
  73 0074 23A6E700 		sw	a4,12(a5)	# tmp95, MEM[(volatile uint32_t *)805306380B]
  74 0078 13076000 		li	a4,6		# tmp98,
  75 007c 23A6E700 		sw	a4,12(a5)	# tmp98, MEM[(volatile uint32_t *)805306380B]
  76 0080 1307A008 		li	a4,138		# tmp101,
  77 0084 23A6E700 		sw	a4,12(a5)	# tmp101, MEM[(volatile uint32_t *)805306380B]
  78 0088 13074006 		li	a4,100		# tmp104,
  79 008c 23A6E700 		sw	a4,12(a5)	# tmp104, MEM[(volatile uint32_t *)805306380B]
  80 0090 9306B008 		li	a3,139		# tmp107,
  81 0094 23A6D700 		sw	a3,12(a5)	# tmp107, MEM[(volatile uint32_t *)805306380B]
  82 0098 93068007 		li	a3,120		# tmp110,
  83 009c 23A6D700 		sw	a3,12(a5)	# tmp110, MEM[(volatile uint32_t *)805306380B]
  84 00a0 9306C008 		li	a3,140		# tmp113,
  85 00a4 23A6D700 		sw	a3,12(a5)	# tmp113, MEM[(volatile uint32_t *)805306380B]
  86 00a8 23A6E700 		sw	a4,12(a5)	# tmp104, MEM[(volatile uint32_t *)805306380B]
  87 00ac 1307000A 		li	a4,160		# tmp119,
  88 00b0 23A6E700 		sw	a4,12(a5)	# tmp119, MEM[(volatile uint32_t *)805306380B]
  89 00b4 13072007 		li	a4,114		# tmp122,
  90 00b8 23A6E700 		sw	a4,12(a5)	# tmp122, MEM[(volatile uint32_t *)805306380B]
  91 00bc 1307100A 		li	a4,161		# tmp125,
  92 00c0 23A6E700 		sw	a4,12(a5)	# tmp125, MEM[(volatile uint32_t *)805306380B]
  93 00c4 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
  94 00c8 1307200A 		li	a4,162		# tmp130,
  95 00cc 23A6E700 		sw	a4,12(a5)	# tmp130, MEM[(volatile uint32_t *)805306380B]
  96 00d0 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
  97 00d4 1307400A 		li	a4,164		# tmp135,
  98 00d8 23A6E700 		sw	a4,12(a5)	# tmp135, MEM[(volatile uint32_t *)805306380B]
  99 00dc 1307800A 		li	a4,168		# tmp138,
 100 00e0 23A6E700 		sw	a4,12(a5)	# tmp138, MEM[(volatile uint32_t *)805306380B]
 101 00e4 1307F003 		li	a4,63		# tmp141,
 102 00e8 23A6E700 		sw	a4,12(a5)	# tmp141, MEM[(volatile uint32_t *)805306380B]
 103 00ec 1307D00A 		li	a4,173		# tmp144,
 104 00f0 23A6E700 		sw	a4,12(a5)	# tmp144, MEM[(volatile uint32_t *)805306380B]
 105 00f4 1307E008 		li	a4,142		# tmp147,
 106 00f8 23A6E700 		sw	a4,12(a5)	# tmp147, MEM[(volatile uint32_t *)805306380B]
 107 00fc 1307000B 		li	a4,176		# tmp150,
 108 0100 23A6E700 		sw	a4,12(a5)	# tmp150, MEM[(volatile uint32_t *)805306380B]
 109 0104 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
 110 0108 1307100B 		li	a4,177		# tmp155,
 111 010c 23A6E700 		sw	a4,12(a5)	# tmp155, MEM[(volatile uint32_t *)805306380B]
 112 0110 13071003 		li	a4,49		# tmp158,
 113 0114 23A6E700 		sw	a4,12(a5)	# tmp158, MEM[(volatile uint32_t *)805306380B]
 114 0118 1307300B 		li	a4,179		# tmp161,
 115 011c 23A6E700 		sw	a4,12(a5)	# tmp161, MEM[(volatile uint32_t *)805306380B]
 116 0120 1307000F 		li	a4,240		# tmp164,
 117 0124 23A6E700 		sw	a4,12(a5)	# tmp164, MEM[(volatile uint32_t *)805306380B]
 118 0128 1307B00B 		li	a4,187		# tmp167,
 119 012c 23A6E700 		sw	a4,12(a5)	# tmp167, MEM[(volatile uint32_t *)805306380B]
 120 0130 1307A003 		li	a4,58		# tmp170,
 121 0134 23A6E700 		sw	a4,12(a5)	# tmp170, MEM[(volatile uint32_t *)805306380B]
 122 0138 1307E00B 		li	a4,190		# tmp173,
 123 013c 23A6E700 		sw	a4,12(a5)	# tmp173, MEM[(volatile uint32_t *)805306380B]
 124 0140 1307E003 		li	a4,62		# tmp176,
 125 0144 23A6E700 		sw	a4,12(a5)	# tmp176, MEM[(volatile uint32_t *)805306380B]
 126 0148 1307E002 		li	a4,46		# tmp179,
 127 014c 23A6E700 		sw	a4,12(a5)	# tmp179, MEM[(volatile uint32_t *)805306380B]
 128 0150 1307F00A 		li	a4,175		# tmp182,
 129 0154 23A6E700 		sw	a4,12(a5)	# tmp182, MEM[(volatile uint32_t *)805306380B]
 130              	# kianv_stdlib.h:120: }
 131 0158 67800000 		ret	
 133              		.align	2
 134              		.globl	set_reg
 136              	set_reg:
 137              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 138 015c 03270500 		lw	a4,0(a0)		# _1,* p
 139              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 140 0160 93071000 		li	a5,1		# tmp85,
 141 0164 B397B700 		sll	a5,a5,a1	# tmp88, _12, tmp85
 142              	# kianv_stdlib.h:124:     if (bit) {
 143 0168 63080600 		beq	a2,zero,.L7	#, tmp89,,
 144              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 145 016c B3E7E700 		or	a5,a5,a4	# _1, _5, _12
 146 0170 2320F500 		sw	a5,0(a0)	# _5,* p
 147 0174 67800000 		ret	
 148              	.L7:
 149              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 150 0178 93C7F7FF 		not	a5,a5	# tmp86, _12
 151              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 152 017c B3F7E700 		and	a5,a5,a4	# _13, _18, tmp86
 153 0180 2320F500 		sw	a5,0(a0)	# _18,* p
 154              	# kianv_stdlib.h:129: }
 155 0184 67800000 		ret	
 157              		.align	2
 158              		.globl	gpio_set_value
 160              	gpio_set_value:
 161              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 162 0188 37070030 		li	a4,805306368		# tmp86,
 163 018c 8326C701 		lw	a3,28(a4)		# _7,
 164              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 165 0190 93071000 		li	a5,1		# tmp84,
 166 0194 B397A700 		sll	a5,a5,a0	# tmp94, _6, tmp84
 167              	# kianv_stdlib.h:124:     if (bit) {
 168 0198 63880500 		beq	a1,zero,.L10	#, tmp95,,
 169              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 170 019c B3E7D700 		or	a5,a5,a3	# _7, _11, _6
 171 01a0 232EF700 		sw	a5,28(a4)	# _11,
 172              	# kianv_stdlib.h:133: }
 173 01a4 67800000 		ret	
 174              	.L10:
 175              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 176 01a8 93C7F7FF 		not	a5,a5	# tmp91, _6
 177              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 178 01ac B3F7D700 		and	a5,a5,a3	# _12, _17, tmp91
 179 01b0 232EF700 		sw	a5,28(a4)	# _17,
 180              	# kianv_stdlib.h:133: }
 181 01b4 67800000 		ret	
 183              		.align	2
 184              		.globl	gpio_get_input_value
 186              	gpio_get_input_value:
 187              	# kianv_stdlib.h:136:   uint32_t read = IO_IN(GPIO_INPUT);
 188 01b8 B7070030 		li	a5,805306368		# tmp77,
 189 01bc 83A70702 		lw	a5,32(a5)		# read, MEM[(volatile uint32_t *)805306400B]
 190              	# kianv_stdlib.h:139:   return ((read >> gpio) & 0x01);
 191 01c0 33D5A700 		srl	a0,a5,a0	# tmp80, tmp79, read
 192              	# kianv_stdlib.h:140: }
 193 01c4 13751500 		andi	a0,a0,1	#,, tmp79
 194 01c8 67800000 		ret	
 196              		.align	2
 197              		.globl	gpio_set_direction
 199              	gpio_set_direction:
 200              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 201 01cc 37070030 		li	a4,805306368		# tmp86,
 202 01d0 83264701 		lw	a3,20(a4)		# _4,
 203              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 204 01d4 93071000 		li	a5,1		# tmp84,
 205 01d8 B397A700 		sll	a5,a5,a0	# tmp94, _19, tmp84
 206              	# kianv_stdlib.h:124:     if (bit) {
 207 01dc 63880500 		beq	a1,zero,.L14	#, tmp95,,
 208              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 209 01e0 B3E7D700 		or	a5,a5,a3	# _4, _8, _19
 210 01e4 232AF700 		sw	a5,20(a4)	# _8,
 211 01e8 67800000 		ret	
 212              	.L14:
 213              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 214 01ec 93C7F7FF 		not	a5,a5	# tmp91, _19
 215              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 216 01f0 B3F7D700 		and	a5,a5,a3	# _12, _17, tmp91
 217 01f4 232AF700 		sw	a5,20(a4)	# _17,
 218              	# kianv_stdlib.h:144: }
 219 01f8 67800000 		ret	
 221              		.align	2
 222              		.globl	get_cycles
 224              	get_cycles:
 225 01fc 130101FF 		addi	sp,sp,-16	#,,
 226              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 227              	 #APP
 228              	# 150 "kianv_stdlib.h" 1
   1              	#include <stdint.h>
   2              	#include <math.h>
   3              	#include "SSD1331.h"
   4              	
   5              	/* kian hardware register */
   6              	#define IO_BASE 0x30000000
   7              	#define UART_TX             (volatile uint32_t *) (IO_BASE + 0x0000)
   8              	#define UART_READY          (volatile uint32_t *) (IO_BASE + 0x0000)
   9              	#define VIDEOENABLE         (volatile uint32_t *) (IO_BASE + 0x0008)
  10              	#define VIDEO               (volatile uint32_t *) (IO_BASE + 0x0008)
  11              	#define VIDEO_RAW           (volatile uint32_t *) (IO_BASE + 0x000C)
  12              	#define CPU_FREQ            (volatile uint32_t *) (IO_BASE + 0x0010)
  13              	// gpio hack stuff
  14              	#define GPIO_DIR            ( volatile uint32_t  *) (IO_BASE + 0x0014)
  15              	#define GPIO_PULLUP         ( volatile uint32_t  *) (IO_BASE + 0x0018) // not implemented
  16              	#define GPIO_OUTPUT         ( volatile uint32_t  *) (IO_BASE + 0x001C)
  17              	#define GPIO_INPUT          ( volatile uint32_t  *) (IO_BASE + 0x0020)
  18              	#define IO_OUT(reg, value) *((volatile uint32_t  *) (reg)) = (value)
  19              	#define IO_IN(reg)         *((volatile uint32_t  *) reg)
  20              	// dma stuff
  21              	#define DMA_SRC             ( volatile uint32_t  *) (IO_BASE + 0x002C)
  22              	#define DMA_DST             ( volatile uint32_t  *) (IO_BASE + 0x0030)
  23              	#define DMA_LEN             ( volatile uint32_t  *) (IO_BASE + 0x0034)
  24              	#define DMA_CTRL            ( volatile uint32_t  *) (IO_BASE + 0x0038)
  25              	#define DMA_MEMCPY          (1 << 0)
  26              	#define DMA_MEMSET          (1 << 1)
  27              	
  28              	#define GPIO_INPUT_PIN  0
  29              	#define GPIO_OUTPUT_PIN 1
  30              	//#define RV32_FASTCODE __attribute((section(".fastcode")))
  31              	#define RV32_FASTCODE
  32              	
  33              	//__attribute((section(".fastcode")))
  34              	
  35              	#define RED   "\x1B[31m"
  36              	#define GRN   "\x1B[32m"
  37              	#define YEL   "\x1B[33m"
  38              	#define BLU   "\x1B[34m"
  39              	#define MAG   "\x1B[35m"
  40              	#define CYN   "\x1B[36m"
  41              	#define WHT   "\x1B[37m"
  42              	#define RESET "\x1B[0m"
  43              	
  44              	#define CLS       "\x1B[2J"
  45              	#define BOLD      "\x1B[1m"
  46              	#define BLINK     "\x1B[5m"
  47              	#define BLINK_OFF "\x1B[25m"
  48              	
  49              	// dma stuff
  50              	void dma_action(uint32_t src, uint32_t dst, uint32_t len, uint32_t ctrl) {
  51              	  *( (volatile uint32_t*) DMA_SRC  ) = src;
  52              	  *( (volatile uint32_t*) DMA_DST  ) = dst;
  53              	  *( (volatile uint32_t*) DMA_LEN  ) = len;
  54              	  *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
  55              	}
  56              	
  57              	void _sendCmd(uint8_t c)
  58              	{
  59              	    //digitalWrite(_dc,LOW);
  60              	    //digitalWrite(_cs,LOW);
  61              	    // SPI.transfer(c);
  62              	    *((volatile uint32_t *) VIDEO_RAW) = ((0x00) << 8) | c;
  63              	    //digitalWrite(_cs,HIGH);
  64              	}
  65              	
  66              	void _sendData(uint8_t c)
  67              	{
  68              	    //digitalWrite(_dc,LOW);
  69              	    //digitalWrite(_cs,LOW);
  70              	    // SPI.transfer(c);
  71              	    *((volatile uint32_t *) VIDEO_RAW) = ((0x01) << 8) | c;
  72              	    //digitalWrite(_cs,HIGH);
  73              	}
  74              	
  75              	void init_oled1331(void)
  76              	{
  77              	    //pinMode(_dc, OUTPUT);
  78              	    //pinMode(_cs, OUTPUT);
  79              	
  80              	    //SPI.begin();
  81              	
  82              	    _sendCmd(CMD_DISPLAY_OFF);	//Display Off
  83              	    _sendCmd(CMD_SET_CONTRAST_A);	//Set contrast for color A
  84              	    _sendCmd(0x91);		//145
  85              	    _sendCmd(CMD_SET_CONTRAST_B);	//Set contrast for color B
  86              	    _sendCmd(0x80);		//80
  87              	    _sendCmd(CMD_SET_CONTRAST_C);	//Set contrast for color C
  88              	    _sendCmd(0x7D);		//125
  89              	    _sendCmd(CMD_MASTER_CURRENT_CONTROL);	//master current control
  90              	    _sendCmd(0x06);		//6
  91              	    _sendCmd(CMD_SET_PRECHARGE_SPEED_A);	//Set Second Pre-change Speed For ColorA
  92              	    _sendCmd(0x64);		//100
  93              	    _sendCmd(CMD_SET_PRECHARGE_SPEED_B);	//Set Second Pre-change Speed For ColorB
  94              	    _sendCmd(0x78);		//120
  95              	    _sendCmd(CMD_SET_PRECHARGE_SPEED_C);	//Set Second Pre-change Speed For ColorC
  96              	    _sendCmd(0x64);		//100
  97              	    _sendCmd(CMD_SET_REMAP);	//set remap & data format
  98              	    _sendCmd(0x72);		//0x72
  99              	    _sendCmd(CMD_SET_DISPLAY_START_LINE);	//Set display Start Line
 100              	    _sendCmd(0x0);
 101              	    _sendCmd(CMD_SET_DISPLAY_OFFSET);	//Set display offset
 102              	    _sendCmd(0x0);
 103              	    _sendCmd(CMD_NORMAL_DISPLAY);	//Set display mode
 104              	    _sendCmd(CMD_SET_MULTIPLEX_RATIO);	//Set multiplex ratio
 105              	    _sendCmd(0x3F);
 106              	    _sendCmd(CMD_SET_MASTER_CONFIGURE);	//Set master configuration
 107              	    _sendCmd(0x8E);
 108              	    _sendCmd(CMD_POWER_SAVE_MODE);	//Set Power Save Mode
 109              	    _sendCmd(0x00);		//0x00
 110              	    _sendCmd(CMD_PHASE_PERIOD_ADJUSTMENT);	//phase 1 and 2 period adjustment
 111              	    _sendCmd(0x31);		//0x31
 112              	    _sendCmd(CMD_DISPLAY_CLOCK_DIV);	//display clock divider/oscillator frequency
 113              	    _sendCmd(0xF0);
 114              	    _sendCmd(CMD_SET_PRECHARGE_VOLTAGE);	//Set Pre-Change Level
 115              	    _sendCmd(0x3A);
 116              	    _sendCmd(CMD_SET_V_VOLTAGE);	//Set vcomH
 117              	    _sendCmd(0x3E);
 118              	    _sendCmd(CMD_DEACTIVE_SCROLLING);	//disable scrolling
 119              	    _sendCmd(CMD_NORMAL_BRIGHTNESS_DISPLAY_ON);	//set display on
 120              	}
 121              	
 122              	
 123              	void set_reg(volatile uint32_t *p, int gpio, int bit) {
 124              	    if (bit) {
 125              	      *p |=  (0x01 << (gpio & 0x1f));
 126              	    } else {
 127              	      *p &= ~( 0x01 << (gpio & 0x1f));
 128              	    }
 129              	}
 130              	
 131              	void gpio_set_value(int gpio, int bit) {
 132              	    set_reg(GPIO_OUTPUT, gpio, bit);
 133              	}
 134              	
 135              	uint32_t gpio_get_input_value(int gpio) {
 136              	  uint32_t read = IO_IN(GPIO_INPUT);
 137              	
 138              	  //  return ((read & (1<<gpio)) >> gpio);
 139              	  return ((read >> gpio) & 0x01);
 140              	}
 141              	
 142              	void gpio_set_direction(int gpio, int bit) {
 143              	    set_reg(GPIO_DIR, gpio, bit);
 144              	}
 145              	
 146              	uint64_t get_cycles() {
 147              	  volatile uint32_t tmph0;
 148              	  volatile uint32_t tmpl0;
 149              	
 150 0200 F32700C8 	  asm volatile ("rdcycleh %0" : "=r"(tmph0));
 151              	  asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 229              		rdcycleh a5	# tmp78
 230              	# 0 "" 2
 231              	 #NO_APP
 232 0204 2324F100 		sw	a5,8(sp)	# tmp78, tmph0
 233              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 234              	 #APP
 235              	# 151 "kianv_stdlib.h" 1
 152              	
 236              		rdcycle  a5	# tmp79
 237              	# 0 "" 2
 238              	 #NO_APP
 239 020c 2326F100 		sw	a5,12(sp)	# tmp79, tmpl0
 240              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 241 0210 83258100 		lw	a1,8(sp)		# tmph0.0_1, tmph0
 242              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 243 0214 0325C100 		lw	a0,12(sp)		# tmpl0.1_4, tmpl0
 244              	# kianv_stdlib.h:155: }
 245 0218 13010101 		addi	sp,sp,16	#,,
 246 021c 67800000 		jr	ra		#
 248              		.align	2
 249              		.globl	wait_cycles
 251              	wait_cycles:
 252 0220 130101FF 		addi	sp,sp,-16	#,,
 253              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 254              	 #APP
 255              	# 150 "kianv_stdlib.h" 1
 256              		rdcycleh a5	# tmp86
 257              	# 0 "" 2
 258              	 #NO_APP
 259 0228 2320F100 		sw	a5,0(sp)	# tmp86, tmph0
 260              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 261              	 #APP
 262              	# 151 "kianv_stdlib.h" 1
 263              		rdcycle  a5	# tmp87
 264              	# 0 "" 2
 265              	 #NO_APP
 266 0230 2322F100 		sw	a5,4(sp)	# tmp87, tmpl0
 267              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 268 0234 83270100 		lw	a5,0(sp)		# tmph0.0_5, tmph0
 269              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 270 0238 03264100 		lw	a2,4(sp)		# tmpl0.1_8, tmpl0
 271              	# kianv_stdlib.h:162:   uint64_t lim = get_cycles() + wait;
 272 023c B387B700 		add	a5,a5,a1	# wait, tmp126, tmph0.0_5
 273 0240 3306C500 		add	a2,a0,a2	# tmpl0.1_8, tmp129, wait
 274 0244 3335A600 		sltu	a0,a2,a0	# wait, tmp98, tmp129
 275 0248 3307F500 		add	a4,a0,a5	# tmp126, tmp100, tmp98
 276              	.L21:
 277              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 278              	 #APP
 279              	# 150 "kianv_stdlib.h" 1
 280              		rdcycleh a5	# tmp101
 281              	# 0 "" 2
 282              	 #NO_APP
 283 0250 2324F100 		sw	a5,8(sp)	# tmp101, tmph0
 284              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 285              	 #APP
 286              	# 151 "kianv_stdlib.h" 1
 287              		rdcycle  a5	# tmp102
 288              	# 0 "" 2
 289              	 #NO_APP
 290 0258 2326F100 		sw	a5,12(sp)	# tmp102, tmpl0
 291              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 292 025c 83278100 		lw	a5,8(sp)		# tmph0.0_11, tmph0
 293              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 294 0260 8326C100 		lw	a3,12(sp)		# tmpl0.1_14, tmpl0
 295              	# kianv_stdlib.h:163:   while (get_cycles() < lim)
 296 0264 E3E4E7FE 		bgtu	a4,a5,.L21	#, tmp100, tmph0.0_11,
 297 0268 6314F700 		bne	a4,a5,.L18	#, tmp100, tmph0.0_11,
 298 026c E3E0C6FE 		bgtu	a2,a3,.L21	#, tmp129, tmpl0.1_14,
 299              	.L18:
 300              	# kianv_stdlib.h:165: }
 301 0270 13010101 		addi	sp,sp,16	#,,
 302 0274 67800000 		jr	ra		#
 304              		.align	2
 305              		.globl	usleep
 307              	usleep:
 308              	# kianv_stdlib.h:168:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 309 0278 63080506 		beq	a0,zero,.L32	#, us,,
 310              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 311 027c B7070030 		li	a5,805306368		# tmp91,
 312              	# kianv_stdlib.h:167: void usleep(uint32_t us) {
 313 0280 130101FF 		addi	sp,sp,-16	#,,
 314              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 315 0284 83A70701 		lw	a5,16(a5)		# _20, MEM[(volatile uint32_t *)805306384B]
 316              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 317              	 #APP
 318              	# 150 "kianv_stdlib.h" 1
 319              		rdcycleh a4	# tmp92
 320              	# 0 "" 2
 321              	 #NO_APP
 322 028c 2324E100 		sw	a4,8(sp)	# tmp92, tmph0
 323              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 324              	 #APP
 325              	# 151 "kianv_stdlib.h" 1
 326              		rdcycle  a3	# tmp93
 327              	# 0 "" 2
 328              	# kianv_stdlib.h:168:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 329              	 #NO_APP
 330 0294 37470F00 		li	a4,999424		# tmp97,
 331 0298 13070724 		addi	a4,a4,576	#, tmp96, tmp97
 332 029c B3D7E702 		divu	a5,a5,a4	# tmp96, tmp95, _20
 333              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 334 02a0 2326D100 		sw	a3,12(sp)	# tmp93, tmpl0
 335              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 336 02a4 03278100 		lw	a4,8(sp)		# tmph0.0_7, tmph0
 337              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 338 02a8 0326C100 		lw	a2,12(sp)		# tmpl0.1_10, tmpl0
 339              	# kianv_stdlib.h:168:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 340 02ac B387A702 		mul	a5,a5,a0	# tmp98, tmp95, us
 341              	# kianv_stdlib.h:162:   uint64_t lim = get_cycles() + wait;
 342 02b0 3386C700 		add	a2,a5,a2	# tmpl0.1_10, tmp141, tmp98
 343 02b4 B337F600 		sltu	a5,a2,a5	# tmp98, tmp110, tmp141
 344 02b8 B387E700 		add	a5,a5,a4	# tmph0.0_7, tmp112, tmp110
 345              	.L29:
 346              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 347              	 #APP
 348              	# 150 "kianv_stdlib.h" 1
 349              		rdcycleh a4	# tmp113
 350              	# 0 "" 2
 351              	 #NO_APP
 352 02c0 2320E100 		sw	a4,0(sp)	# tmp113, tmph0
 353              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 354              	 #APP
 355              	# 151 "kianv_stdlib.h" 1
 356              		rdcycle  a4	# tmp114
 357              	# 0 "" 2
 358              	 #NO_APP
 359 02c8 2322E100 		sw	a4,4(sp)	# tmp114, tmpl0
 360              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 361 02cc 03270100 		lw	a4,0(sp)		# tmph0.0_14, tmph0
 362              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 363 02d0 83264100 		lw	a3,4(sp)		# tmpl0.1_17, tmpl0
 364              	# kianv_stdlib.h:163:   while (get_cycles() < lim)
 365 02d4 E364F7FE 		bgtu	a5,a4,.L29	#, tmp112, tmph0.0_14,
 366 02d8 6394E700 		bne	a5,a4,.L23	#, tmp112, tmph0.0_14,
 367 02dc E3E0C6FE 		bgtu	a2,a3,.L29	#, tmp141, tmpl0.1_17,
 368              	.L23:
 369              	# kianv_stdlib.h:169: }
 370 02e0 13010101 		addi	sp,sp,16	#,,
 371 02e4 67800000 		jr	ra		#
 372              	.L32:
 373 02e8 67800000 		ret	
 375              		.align	2
 376              		.globl	msleep
 378              	msleep:
 379              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 380 02ec 63060506 		beq	a0,zero,.L44	#, ms,,
 381              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 382 02f0 B7070030 		li	a5,805306368		# tmp91,
 383              	# kianv_stdlib.h:171: void msleep(uint32_t ms) {
 384 02f4 130101FF 		addi	sp,sp,-16	#,,
 385              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 386 02f8 83A70701 		lw	a5,16(a5)		# _5, MEM[(volatile uint32_t *)805306384B]
 387              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 388              	 #APP
 389              	# 150 "kianv_stdlib.h" 1
 390              		rdcycleh a4	# tmp92
 391              	# 0 "" 2
 392              	 #NO_APP
 393 0300 2324E100 		sw	a4,8(sp)	# tmp92, tmph0
 394              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 395              	 #APP
 396              	# 151 "kianv_stdlib.h" 1
 397              		rdcycle  a4	# tmp93
 398              	# 0 "" 2
 399              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 400              	 #NO_APP
 401 0308 9306803E 		li	a3,1000		# tmp95,
 402 030c B3D7D702 		divu	a5,a5,a3	# tmp95, tmp96, _5
 403              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 404 0310 2326E100 		sw	a4,12(sp)	# tmp93, tmpl0
 405              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 406 0314 03278100 		lw	a4,8(sp)		# tmph0.0_9, tmph0
 407              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 408 0318 0326C100 		lw	a2,12(sp)		# tmpl0.1_12, tmpl0
 409              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 410 031c B387A702 		mul	a5,a5,a0	# tmp97, tmp96, ms
 411              	# kianv_stdlib.h:162:   uint64_t lim = get_cycles() + wait;
 412 0320 3386C700 		add	a2,a5,a2	# tmpl0.1_12, tmp140, tmp97
 413 0324 B337F600 		sltu	a5,a2,a5	# tmp97, tmp109, tmp140
 414 0328 B387E700 		add	a5,a5,a4	# tmph0.0_9, tmp111, tmp109
 415              	.L41:
 416              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 417              	 #APP
 418              	# 150 "kianv_stdlib.h" 1
 419              		rdcycleh a4	# tmp112
 420              	# 0 "" 2
 421              	 #NO_APP
 422 0330 2320E100 		sw	a4,0(sp)	# tmp112, tmph0
 423              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 424              	 #APP
 425              	# 151 "kianv_stdlib.h" 1
 426              		rdcycle  a4	# tmp113
 427              	# 0 "" 2
 428              	 #NO_APP
 429 0338 2322E100 		sw	a4,4(sp)	# tmp113, tmpl0
 430              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 431 033c 03270100 		lw	a4,0(sp)		# tmph0.0_16, tmph0
 432              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 433 0340 83264100 		lw	a3,4(sp)		# tmpl0.1_19, tmpl0
 434              	# kianv_stdlib.h:163:   while (get_cycles() < lim)
 435 0344 E364F7FE 		bgtu	a5,a4,.L41	#, tmp111, tmph0.0_16,
 436 0348 6394E700 		bne	a5,a4,.L35	#, tmp111, tmph0.0_16,
 437 034c E3E0C6FE 		bgtu	a2,a3,.L41	#, tmp140, tmpl0.1_19,
 438              	.L35:
 439              	# kianv_stdlib.h:173: }
 440 0350 13010101 		addi	sp,sp,16	#,,
 441 0354 67800000 		jr	ra		#
 442              	.L44:
 443 0358 67800000 		ret	
 445              		.align	2
 446              		.globl	sleep
 448              	sleep:
 449              	# kianv_stdlib.h:176:   if (sec) wait_cycles(sec * get_cpu_freq());
 450 035c 63020506 		beq	a0,zero,.L56	#, sec,,
 451              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 452 0360 B7070030 		li	a5,805306368		# tmp90,
 453              	# kianv_stdlib.h:175: void sleep(uint32_t sec) {
 454 0364 130101FF 		addi	sp,sp,-16	#,,
 455              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 456 0368 03A70701 		lw	a4,16(a5)		# _19, MEM[(volatile uint32_t *)805306384B]
 457              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 458              	 #APP
 459              	# 150 "kianv_stdlib.h" 1
 460              		rdcycleh a5	# tmp91
 461              	# 0 "" 2
 462              	 #NO_APP
 463 0370 2324F100 		sw	a5,8(sp)	# tmp91, tmph0
 464              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 465              	 #APP
 466              	# 151 "kianv_stdlib.h" 1
 467              		rdcycle  a5	# tmp92
 468              	# 0 "" 2
 469              	# kianv_stdlib.h:176:   if (sec) wait_cycles(sec * get_cpu_freq());
 470              	 #NO_APP
 471 0378 3305E502 		mul	a0,a0,a4	# tmp101, sec, _19
 472              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 473 037c 2326F100 		sw	a5,12(sp)	# tmp92, tmpl0
 474              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 475 0380 83278100 		lw	a5,8(sp)		# tmph0.0_6, tmph0
 476              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 477 0384 0327C100 		lw	a4,12(sp)		# tmpl0.1_9, tmpl0
 478              	# kianv_stdlib.h:162:   uint64_t lim = get_cycles() + wait;
 479 0388 3305A700 		add	a0,a4,a0	# tmp101, tmp136, tmpl0.1_9
 480 038c 3337E500 		sltu	a4,a0,a4	# tmpl0.1_9, tmp105, tmp136
 481 0390 3307F700 		add	a4,a4,a5	# tmph0.0_6, tmp107, tmp105
 482              	.L53:
 483              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 484              	 #APP
 485              	# 150 "kianv_stdlib.h" 1
 486              		rdcycleh a5	# tmp108
 487              	# 0 "" 2
 488              	 #NO_APP
 489 0398 2320F100 		sw	a5,0(sp)	# tmp108, tmph0
 490              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 491              	 #APP
 492              	# 151 "kianv_stdlib.h" 1
 493              		rdcycle  a5	# tmp109
 494              	# 0 "" 2
 495              	 #NO_APP
 496 03a0 2322F100 		sw	a5,4(sp)	# tmp109, tmpl0
 497              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 498 03a4 83270100 		lw	a5,0(sp)		# tmph0.0_13, tmph0
 499              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 500 03a8 83264100 		lw	a3,4(sp)		# tmpl0.1_16, tmpl0
 501              	# kianv_stdlib.h:163:   while (get_cycles() < lim)
 502 03ac E3E4E7FE 		bgtu	a4,a5,.L53	#, tmp107, tmph0.0_13,
 503 03b0 6314F700 		bne	a4,a5,.L47	#, tmp107, tmph0.0_13,
 504 03b4 E3E0A6FE 		bgtu	a0,a3,.L53	#, tmp136, tmpl0.1_16,
 505              	.L47:
 506              	# kianv_stdlib.h:177: }
 507 03b8 13010101 		addi	sp,sp,16	#,,
 508 03bc 67800000 		jr	ra		#
 509              	.L56:
 510 03c0 67800000 		ret	
 512              		.globl	__udivdi3
 513              		.align	2
 514              		.globl	nanoseconds
 516              	nanoseconds:
 517 03c4 130101FE 		addi	sp,sp,-32	#,,
 518 03c8 232E1100 		sw	ra,28(sp)	#,
 519              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 520              	 #APP
 521              	# 150 "kianv_stdlib.h" 1
 522              		rdcycleh a5	# tmp82
 523              	# 0 "" 2
 524              	 #NO_APP
 525 03d0 2324F100 		sw	a5,8(sp)	# tmp82, tmph0
 526              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 527              	 #APP
 528              	# 151 "kianv_stdlib.h" 1
 529              		rdcycle  a5	# tmp83
 530              	# 0 "" 2
 531              	 #NO_APP
 532 03d8 2326F100 		sw	a5,12(sp)	# tmp83, tmpl0
 533              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 534 03dc B7070030 		li	a5,805306368		# tmp85,
 535              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 536 03e0 83258100 		lw	a1,8(sp)		# tmph0.0_6, tmph0
 537              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 538 03e4 0325C100 		lw	a0,12(sp)		# tmpl0.1_9, tmpl0
 539              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 540 03e8 03A60701 		lw	a2,16(a5)		# _5, MEM[(volatile uint32_t *)805306384B]
 541              	# kianv_stdlib.h:180:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000000);
 542 03ec B7470F00 		li	a5,999424		# tmp98,
 543 03f0 93870724 		addi	a5,a5,576	#, tmp97, tmp98
 544              	# kianv_stdlib.h:180:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000000);
 545 03f4 3356F602 		divu	a2,a2,a5	# tmp97,, _5
 546 03f8 93060000 		li	a3,0		#,
 547 03fc 97000000 		call	__udivdi3		#
 547      E7800000 
 548              	# kianv_stdlib.h:181: }
 549 0404 8320C101 		lw	ra,28(sp)		#,
 550 0408 13010102 		addi	sp,sp,32	#,,
 551 040c 67800000 		jr	ra		#
 553              		.align	2
 554              		.globl	milliseconds
 556              	milliseconds:
 557 0410 130101FE 		addi	sp,sp,-32	#,,
 558 0414 232E1100 		sw	ra,28(sp)	#,
 559              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 560              	 #APP
 561              	# 150 "kianv_stdlib.h" 1
 562              		rdcycleh a5	# tmp82
 563              	# 0 "" 2
 564              	 #NO_APP
 565 041c 2324F100 		sw	a5,8(sp)	# tmp82, tmph0
 566              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 567              	 #APP
 568              	# 151 "kianv_stdlib.h" 1
 569              		rdcycle  a5	# tmp83
 570              	# 0 "" 2
 571              	 #NO_APP
 572 0424 2326F100 		sw	a5,12(sp)	# tmp83, tmpl0
 573              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 574 0428 B7070030 		li	a5,805306368		# tmp85,
 575              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 576 042c 83258100 		lw	a1,8(sp)		# tmph0.0_6, tmph0
 577              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 578 0430 0325C100 		lw	a0,12(sp)		# tmpl0.1_9, tmpl0
 579              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 580 0434 03A60701 		lw	a2,16(a5)		# _5, MEM[(volatile uint32_t *)805306384B]
 581              	# kianv_stdlib.h:184:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000);
 582 0438 9307803E 		li	a5,1000		# tmp96,
 583 043c 93060000 		li	a3,0		#,
 584 0440 3356F602 		divu	a2,a2,a5	# tmp96,, _5
 585 0444 97000000 		call	__udivdi3		#
 585      E7800000 
 586              	# kianv_stdlib.h:185: }
 587 044c 8320C101 		lw	ra,28(sp)		#,
 588 0450 13010102 		addi	sp,sp,32	#,,
 589 0454 67800000 		jr	ra		#
 591              		.align	2
 592              		.globl	seconds
 594              	seconds:
 595 0458 130101FE 		addi	sp,sp,-32	#,,
 596 045c 232E1100 		sw	ra,28(sp)	#,
 597              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 598              	 #APP
 599              	# 150 "kianv_stdlib.h" 1
 600              		rdcycleh a5	# tmp81
 601              	# 0 "" 2
 602              	 #NO_APP
 603 0464 2324F100 		sw	a5,8(sp)	# tmp81, tmph0
 604              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 605              	 #APP
 606              	# 151 "kianv_stdlib.h" 1
 607              		rdcycle  a5	# tmp82
 608              	# 0 "" 2
 609              	 #NO_APP
 610 046c 2326F100 		sw	a5,12(sp)	# tmp82, tmpl0
 611              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 612 0470 B7070030 		li	a5,805306368		# tmp84,
 613              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 614 0474 83258100 		lw	a1,8(sp)		# tmph0.0_5, tmph0
 615              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 616 0478 0325C100 		lw	a0,12(sp)		# tmpl0.1_8, tmpl0
 617              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 618 047c 03A60701 		lw	a2,16(a5)		# _4, MEM[(volatile uint32_t *)805306384B]
 619              	# kianv_stdlib.h:188:   return get_cycles() / (uint64_t) (get_cpu_freq());
 620 0480 93060000 		li	a3,0		#,
 621 0484 97000000 		call	__udivdi3		#
 621      E7800000 
 622              	# kianv_stdlib.h:189: }
 623 048c 8320C101 		lw	ra,28(sp)		#,
 624 0490 13010102 		addi	sp,sp,32	#,,
 625 0494 67800000 		jr	ra		#
 627              		.align	2
 628              		.globl	putchar
 630              	putchar:
 631              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 632 0498 37070030 		li	a4,805306368		# tmp75,
 633              	.L66:
 634              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 635 049c 83270700 		lw	a5,0(a4)		# _1, MEM[(volatile uint32_t *)805306368B]
 636              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 637 04a0 E38E07FE 		beq	a5,zero,.L66	#, _1,,
 638              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 639 04a4 2320A700 		sw	a0,0(a4)	# c, MEM[(volatile uint32_t *)805306368B]
 640              	# kianv_stdlib.h:195:    if (c == 13) {
 641 04a8 9307D000 		li	a5,13		# tmp77,
 642 04ac 6304F500 		beq	a0,a5,.L70	#, c, tmp77,
 643              	# kianv_stdlib.h:198: }
 644 04b0 67800000 		ret	
 645              	.L70:
 646              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 647 04b4 9307A000 		li	a5,10		# tmp79,
 648 04b8 2320F700 		sw	a5,0(a4)	# tmp79, MEM[(volatile uint32_t *)805306368B]
 649              	# kianv_stdlib.h:198: }
 650 04bc 67800000 		ret	
 652              		.align	2
 653              		.globl	print_chr
 655              	print_chr:
 656 04c0 37070030 		li	a4,805306368		# tmp75,
 657              	.L72:
 658 04c4 83270700 		lw	a5,0(a4)		# _4, MEM[(volatile uint32_t *)805306368B]
 659 04c8 E38E07FE 		beq	a5,zero,.L72	#, _4,,
 660 04cc 2320A700 		sw	a0,0(a4)	# ch, MEM[(volatile uint32_t *)805306368B]
 661 04d0 9307D000 		li	a5,13		# tmp77,
 662 04d4 6304F500 		beq	a0,a5,.L76	#, ch, tmp77,
 663 04d8 67800000 		ret	
 664              	.L76:
 665 04dc 9307A000 		li	a5,10		# tmp79,
 666 04e0 2320F700 		sw	a5,0(a4)	# tmp79, MEM[(volatile uint32_t *)805306368B]
 667 04e4 67800000 		ret	
 669              		.align	2
 670              		.globl	print_char
 672              	print_char:
 673 04e8 37070030 		li	a4,805306368		# tmp75,
 674              	.L78:
 675 04ec 83270700 		lw	a5,0(a4)		# _4, MEM[(volatile uint32_t *)805306368B]
 676 04f0 E38E07FE 		beq	a5,zero,.L78	#, _4,,
 677 04f4 2320A700 		sw	a0,0(a4)	# ch, MEM[(volatile uint32_t *)805306368B]
 678 04f8 9307D000 		li	a5,13		# tmp77,
 679 04fc 6304F500 		beq	a0,a5,.L82	#, ch, tmp77,
 680 0500 67800000 		ret	
 681              	.L82:
 682 0504 9307A000 		li	a5,10		# tmp79,
 683 0508 2320F700 		sw	a5,0(a4)	# tmp79, MEM[(volatile uint32_t *)805306368B]
 684 050c 67800000 		ret	
 686              		.align	2
 687              		.globl	print_str
 689              	print_str:
 690              	# kianv_stdlib.h:209:   while (*p != 0) {
 691 0510 83460500 		lbu	a3,0(a0)	# _3, *p_6(D)
 692              	# kianv_stdlib.h:209:   while (*p != 0) {
 693 0514 638A0602 		beq	a3,zero,.L83	#, _3,,
 694              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 695 0518 B7070030 		li	a5,805306368		# tmp77,
 696              	# kianv_stdlib.h:195:    if (c == 13) {
 697 051c 1306D000 		li	a2,13		# tmp80,
 698              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 699 0520 9305A000 		li	a1,10		# tmp83,
 700              	.L85:
 701              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 702 0524 03A70700 		lw	a4,0(a5)		# _1, MEM[(volatile uint32_t *)805306368B]
 703              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 704 0528 E30E07FE 		beq	a4,zero,.L85	#, _1,,
 705              	# kianv_stdlib.h:212:     putchar(*(p++));
 706 052c 13051500 		addi	a0,a0,1	#, p, p
 707              	.L86:
 708              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 709 0530 03A70700 		lw	a4,0(a5)		# _9, MEM[(volatile uint32_t *)805306368B]
 710              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 711 0534 E30E07FE 		beq	a4,zero,.L86	#, _9,,
 712              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 713 0538 23A0D700 		sw	a3,0(a5)	# _3, MEM[(volatile uint32_t *)805306368B]
 714              	# kianv_stdlib.h:195:    if (c == 13) {
 715 053c 6388C600 		beq	a3,a2,.L100	#, _3, tmp80,
 716              	# kianv_stdlib.h:209:   while (*p != 0) {
 717 0540 83460500 		lbu	a3,0(a0)	# _3, MEM[(char *)p_8]
 718              	# kianv_stdlib.h:209:   while (*p != 0) {
 719 0544 E39006FE 		bne	a3,zero,.L85	#, _3,,
 720              	.L83:
 721              	# kianv_stdlib.h:214: }
 722 0548 67800000 		ret	
 723              	.L100:
 724              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 725 054c 23A0B700 		sw	a1,0(a5)	# tmp83, MEM[(volatile uint32_t *)805306368B]
 726              	# kianv_stdlib.h:209:   while (*p != 0) {
 727 0550 83460500 		lbu	a3,0(a0)	# _3, MEM[(char *)p_8]
 728              	# kianv_stdlib.h:209:   while (*p != 0) {
 729 0554 E39806FC 		bne	a3,zero,.L85	#, _3,,
 730 0558 67800000 		ret	
 732              		.align	2
 733              		.globl	print_str_ln
 735              	print_str_ln:
 736              	# kianv_stdlib.h:209:   while (*p != 0) {
 737 055c 83460500 		lbu	a3,0(a0)	# _9, *p_2(D)
 738              	# kianv_stdlib.h:209:   while (*p != 0) {
 739 0560 638A0602 		beq	a3,zero,.L102	#, _9,,
 740              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 741 0564 B7070030 		li	a5,805306368		# tmp78,
 742              	# kianv_stdlib.h:195:    if (c == 13) {
 743 0568 1306D000 		li	a2,13		# tmp81,
 744              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 745 056c 9305A000 		li	a1,10		# tmp89,
 746              	.L103:
 747              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 748 0570 03A70700 		lw	a4,0(a5)		# _5, MEM[(volatile uint32_t *)805306368B]
 749              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 750 0574 E30E07FE 		beq	a4,zero,.L103	#, _5,,
 751              	# kianv_stdlib.h:212:     putchar(*(p++));
 752 0578 13051500 		addi	a0,a0,1	#, p, p
 753              	.L104:
 754              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 755 057c 03A70700 		lw	a4,0(a5)		# _8, MEM[(volatile uint32_t *)805306368B]
 756              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 757 0580 E30E07FE 		beq	a4,zero,.L104	#, _8,,
 758              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 759 0584 23A0D700 		sw	a3,0(a5)	# _9, MEM[(volatile uint32_t *)805306368B]
 760              	# kianv_stdlib.h:195:    if (c == 13) {
 761 0588 6386C602 		beq	a3,a2,.L121	#, _9, tmp81,
 762              	# kianv_stdlib.h:209:   while (*p != 0) {
 763 058c 83460500 		lbu	a3,0(a0)	# _9, MEM[(char *)p_7]
 764              	# kianv_stdlib.h:209:   while (*p != 0) {
 765 0590 E39006FE 		bne	a3,zero,.L103	#, _9,,
 766              	.L102:
 767              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 768 0594 37070030 		li	a4,805306368		# tmp84,
 769              	.L108:
 770 0598 83270700 		lw	a5,0(a4)		# _3, MEM[(volatile uint32_t *)805306368B]
 771              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 772 059c E38E07FE 		beq	a5,zero,.L108	#, _3,,
 773              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 774 05a0 9307D000 		li	a5,13		# tmp86,
 775 05a4 2320F700 		sw	a5,0(a4)	# tmp86, MEM[(volatile uint32_t *)805306368B]
 776              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 777 05a8 9307A000 		li	a5,10		# tmp88,
 778 05ac 2320F700 		sw	a5,0(a4)	# tmp88, MEM[(volatile uint32_t *)805306368B]
 779              	# kianv_stdlib.h:219: }
 780 05b0 67800000 		ret	
 781              	.L121:
 782              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 783 05b4 23A0B700 		sw	a1,0(a5)	# tmp89, MEM[(volatile uint32_t *)805306368B]
 784              	# kianv_stdlib.h:209:   while (*p != 0) {
 785 05b8 83460500 		lbu	a3,0(a0)	# _9, MEM[(char *)p_7]
 786              	# kianv_stdlib.h:209:   while (*p != 0) {
 787 05bc E39A06FA 		bne	a3,zero,.L103	#, _9,,
 788 05c0 6FF05FFD 		j	.L102		#
 790              		.align	2
 791              		.globl	print_dec
 793              	print_dec:
 794 05c4 130101FF 		addi	sp,sp,-16	#,,
 795              	# kianv_stdlib.h:223:   char *p = buffer;
 796 05c8 13064100 		addi	a2,sp,4	#, tmp92,
 797 05cc 13070600 		mv	a4,a2	# p, tmp92
 798              	# kianv_stdlib.h:225:     *(p++) = val % 10;
 799 05d0 9307A000 		li	a5,10		# tmp93,
 800              	.L123:
 801              	# kianv_stdlib.h:224:   while (val || p == buffer) {
 802 05d4 63140500 		bne	a0,zero,.L124	#, val,,
 803              	# kianv_stdlib.h:224:   while (val || p == buffer) {
 804 05d8 631CC700 		bne	a4,a2,.L131	#, p, tmp92,
 805              	.L124:
 806              	# kianv_stdlib.h:225:     *(p++) = val % 10;
 807 05dc B376F502 		remu	a3,a0,a5	# tmp93, tmp83, val
 808              	# kianv_stdlib.h:225:     *(p++) = val % 10;
 809 05e0 13071700 		addi	a4,a4,1	#, p, p
 810              	# kianv_stdlib.h:226:     val = val / 10;
 811 05e4 3355F502 		divu	a0,a0,a5	# tmp93, val, val
 812              	# kianv_stdlib.h:225:     *(p++) = val % 10;
 813 05e8 A30FD7FE 		sb	a3,-1(a4)	# tmp83, MEM[(char *)p_18 + 4294967295B]
 814 05ec 6FF09FFE 		j	.L123		#
 815              	.L131:
 816              	# kianv_stdlib.h:230:     while (!*((volatile uint32_t*) UART_READY))
 817 05f0 B7060030 		li	a3,805306368		# tmp88,
 818              	.L125:
 819              	# kianv_stdlib.h:230:     while (!*((volatile uint32_t*) UART_READY))
 820 05f4 83A70600 		lw	a5,0(a3)		# _3, MEM[(volatile uint32_t *)805306368B]
 821              	# kianv_stdlib.h:230:     while (!*((volatile uint32_t*) UART_READY))
 822 05f8 E38E07FE 		beq	a5,zero,.L125	#, _3,,
 823              	# kianv_stdlib.h:232:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 824 05fc 8347F7FF 		lbu	a5,-1(a4)	# MEM[(char *)p_16], MEM[(char *)p_16]
 825              	# kianv_stdlib.h:232:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 826 0600 1307F7FF 		addi	a4,a4,-1	#, p, p
 827              	# kianv_stdlib.h:232:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 828 0604 93870703 		addi	a5,a5,48	#, _7, MEM[(char *)p_16]
 829              	# kianv_stdlib.h:232:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 830 0608 23A0F600 		sw	a5,0(a3)	# _7, MEM[(volatile uint32_t *)805306368B]
 831              	# kianv_stdlib.h:229:   while (p != buffer) {
 832 060c E314C7FE 		bne	a4,a2,.L125	#, p, tmp92,
 833              	# kianv_stdlib.h:234: }
 834 0610 13010101 		addi	sp,sp,16	#,,
 835 0614 67800000 		jr	ra		#
 837              		.align	2
 838              		.globl	print_dec64
 840              	print_dec64:
 841 0618 130101FE 		addi	sp,sp,-32	#,,
 842              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 843 061c B7DECCCC 		li	t4,-858992640		# tmp258,
 844              	# kianv_stdlib.h:238:   char *p = buffer;
 845 0620 130EC100 		addi	t3,sp,12	#, tmp254,
 846              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 847 0624 37030010 		li	t1,268435456		# tmp255,
 848 0628 9388DECC 		addi	a7,t4,-819	#, tmp259, tmp258
 849              	# kianv_stdlib.h:236: void print_dec64(uint64_t val) {
 850 062c 13070500 		mv	a4,a0	# val, tmp261
 851 0630 13880500 		mv	a6,a1	# val, tmp262
 852              	# kianv_stdlib.h:238:   char *p = buffer;
 853 0634 13060E00 		mv	a2,t3	# p, tmp254
 854              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 855 0638 1303F3FF 		addi	t1,t1,-1	#, tmp256, tmp255
 856 063c 130F5000 		li	t5,5		# tmp257,
 857 0640 938ECECC 		addi	t4,t4,-820	#, tmp260, tmp258
 858              	# kianv_stdlib.h:239:   while (val || p == buffer) {
 859 0644 6F008005 		j	.L133		#
 860              	.L134:
 861              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 862 0648 B3F7E703 		remu	a5,a5,t5	# tmp257, tmp97, tmp94
 863              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 864 064c 13061600 		addi	a2,a2,1	#, p, p
 865              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 866 0650 B307F740 		sub	a5,a4,a5	# tmp214, val, tmp97
 867 0654 B335F700 		sgtu	a1,a5,a4	# tmp101, tmp214, val
 868 0658 B305B840 		sub	a1,a6,a1	# tmp103, val, tmp101
 869 065c 3385D703 		mul	a0,a5,t4	# tmp107, tmp214, tmp260
 870 0660 B3851503 		mul	a1,a1,a7	# tmp104, tmp103, tmp259
 871 0664 B3B61703 		mulhu	a3,a5,a7	# tmp217, tmp214, tmp259
 872 0668 B385A500 		add	a1,a1,a0	# tmp107, tmp110, tmp104
 873 066c B3871703 		mul	a5,a5,a7	# tmp114, tmp214, tmp259
 874 0670 B385D500 		add	a1,a1,a3	# tmp217, tmp115, tmp110
 875 0674 9396F501 		slli	a3,a1,31	#, tmp133, tmp115
 876              	# kianv_stdlib.h:241:     val = val / 10;
 877 0678 13D81500 		srli	a6,a1,1	#, val, tmp115
 878              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 879 067c 93D71700 		srli	a5,a5,1	#, tmp224, tmp114
 880 0680 B3E7F600 		or	a5,a3,a5	# tmp224, tmp224, tmp133
 881 0684 13952700 		slli	a0,a5,2	#, tmp228, tmp224
 882 0688 3305F500 		add	a0,a0,a5	# tmp224, tmp230, tmp228
 883 068c 13151500 		slli	a0,a0,1	#, tmp232, tmp230
 884 0690 3305A740 		sub	a0,a4,a0	# tmp234, val, tmp232
 885              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 886 0694 A30FA6FE 		sb	a0,-1(a2)	# tmp234, MEM[(char *)p_18 + 4294967295B]
 887              	# kianv_stdlib.h:241:     val = val / 10;
 888 0698 13870700 		mv	a4,a5	# val, tmp224
 889              	.L133:
 890              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 891 069c 93174800 		slli	a5,a6,4	#, tmp88, val
 892 06a0 9356C701 		srli	a3,a4,28	#, tmp208, val
 893 06a4 B3E6D700 		or	a3,a5,a3	# tmp208, tmp208, tmp88
 894 06a8 B3F66600 		and	a3,a3,t1	# tmp256, tmp89, tmp208
 895 06ac B3776700 		and	a5,a4,t1	# tmp256, tmp84, val
 896 06b0 B387D700 		add	a5,a5,a3	# tmp89, tmp92, tmp84
 897 06b4 93558801 		srli	a1,a6,24	#, tmp210, val
 898              	# kianv_stdlib.h:239:   while (val || p == buffer) {
 899 06b8 B3660701 		or	a3,a4,a6	# val, val, val
 900              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 901 06bc B387B700 		add	a5,a5,a1	# tmp210, tmp94, tmp92
 902              	# kianv_stdlib.h:239:   while (val || p == buffer) {
 903 06c0 E39406F8 		bne	a3,zero,.L134	#, val,,
 904              	# kianv_stdlib.h:239:   while (val || p == buffer) {
 905 06c4 E302C6F9 		beq	a2,t3,.L134	#, p, tmp254,
 906              	# kianv_stdlib.h:245:     while (!*((volatile uint32_t*) UART_READY))
 907 06c8 37070030 		li	a4,805306368		# tmp202,
 908              	.L135:
 909              	# kianv_stdlib.h:245:     while (!*((volatile uint32_t*) UART_READY))
 910 06cc 83270700 		lw	a5,0(a4)		# _3, MEM[(volatile uint32_t *)805306368B]
 911              	# kianv_stdlib.h:245:     while (!*((volatile uint32_t*) UART_READY))
 912 06d0 E38E07FE 		beq	a5,zero,.L135	#, _3,,
 913              	# kianv_stdlib.h:247:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 914 06d4 8347F6FF 		lbu	a5,-1(a2)	# MEM[(char *)p_16], MEM[(char *)p_16]
 915              	# kianv_stdlib.h:247:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 916 06d8 1306F6FF 		addi	a2,a2,-1	#, p, p
 917              	# kianv_stdlib.h:247:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 918 06dc 93870703 		addi	a5,a5,48	#, _7, MEM[(char *)p_16]
 919              	# kianv_stdlib.h:247:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 920 06e0 2320F700 		sw	a5,0(a4)	# _7, MEM[(volatile uint32_t *)805306368B]
 921              	# kianv_stdlib.h:244:   while (p != buffer) {
 922 06e4 E314C6FF 		bne	a2,t3,.L135	#, p, tmp254,
 923              	# kianv_stdlib.h:249: }
 924 06e8 13010102 		addi	sp,sp,32	#,,
 925 06ec 67800000 		jr	ra		#
 927              		.section	.rodata.str1.4,"aMS",@progbits,1
 928              		.align	2
 929              	.LC0:
 930 0000 30313233 		.string	"0123456789ABCDEF"
 930      34353637 
 930      38394142 
 930      43444546 
 930      00
 931              		.text
 932              		.align	2
 933              		.globl	print_hex
 935              	print_hex:
 936              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 937 06f0 9386F5FF 		addi	a3,a1,-1	#, tmp85, tmp98
 938              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 939 06f4 93962600 		slli	a3,a3,2	#, i, tmp85
 940              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 941 06f8 63CC0602 		blt	a3,zero,.L141	#, i,,
 942 06fc 37060000 		lui	a2,%hi(.LC0)	# tmp95,
 943 0700 9305C0FF 		li	a1,-4		# _8,
 944 0704 13060600 		addi	a2,a2,%lo(.LC0)	# tmp94, tmp95,
 945              	# kianv_stdlib.h:253:     while (!*((volatile uint32_t*) UART_READY))
 946 0708 37070030 		li	a4,805306368		# tmp87,
 947              	.L143:
 948              	# kianv_stdlib.h:253:     while (!*((volatile uint32_t*) UART_READY))
 949 070c 83270700 		lw	a5,0(a4)		# _2, MEM[(volatile uint32_t *)805306368B]
 950              	# kianv_stdlib.h:253:     while (!*((volatile uint32_t*) UART_READY))
 951 0710 E38E07FE 		beq	a5,zero,.L143	#, _2,,
 952              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 953 0714 B357D500 		srl	a5,a0,a3	# i, tmp90, val
 954              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 955 0718 93F7F700 		andi	a5,a5,15	#, tmp91, tmp90
 956              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 957 071c B307F600 		add	a5,a2,a5	# tmp91, tmp92, tmp94
 958 0720 83C70700 		lbu	a5,0(a5)	# _6, "0123456789ABCDEF"[_4]
 959              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 960 0724 9386C6FF 		addi	a3,a3,-4	#, i, i
 961              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 962 0728 2320F700 		sw	a5,0(a4)	# _6, MEM[(volatile uint32_t *)805306368B]
 963              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 964 072c E390D5FE 		bne	a1,a3,.L143	#, _8, i,
 965              	.L141:
 966              	# kianv_stdlib.h:257: }
 967 0730 67800000 		ret	
 969              		.align	2
 970              		.globl	setpixel
 972              	setpixel:
 973              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 974 0734 B7070100 		li	a5,65536		# tmp88,
 975 0738 9387F7FF 		addi	a5,a5,-1	#, tmp87, tmp88
 976 073c 93958500 		slli	a1,a1,8	#, tmp85, tmp94
 977 0740 B3F5F500 		and	a1,a1,a5	# tmp87, tmp86, tmp85
 978              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 979 0744 93960601 		slli	a3,a3,16	#, tmp89, tmp96
 980              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 981 0748 B3E5D500 		or	a1,a1,a3	# tmp89, tmp90, tmp86
 982              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 983 074c 1376F60F 		andi	a2,a2,0xff	# tmp91, tmp95
 984              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 985 0750 B3E5C500 		or	a1,a1,a2	# tmp91, _9, tmp90
 986              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 987 0754 B7070030 		li	a5,805306368		# tmp93,
 988 0758 23A4B700 		sw	a1,8(a5)	# _9, MEM[(volatile uint32_t *)805306376B]
 989              	# kianv_stdlib.h:272: }
 990 075c 67800000 		ret	
 992              		.align	2
 993              		.globl	draw_bresenham
 995              	draw_bresenham:
 996 0760 130101FE 		addi	sp,sp,-32	#,,
 997              	# kianv_stdlib.h:277:   int dx =  abs(x1 - x0);
 998 0764 3385B640 		sub	a0,a3,a1	#, x1, x0
 999              	# kianv_stdlib.h:275: {
 1000 0768 232E1100 		sw	ra,28(sp)	#,
 1001 076c 232C8100 		sw	s0,24(sp)	#,
 1002 0770 232A9100 		sw	s1,20(sp)	#,
 1003 0774 13840500 		mv	s0,a1	# x0, tmp114
 1004 0778 93040600 		mv	s1,a2	# y0, tmp115
 1005 077c 23282101 		sw	s2,16(sp)	#,
 1006 0780 23263101 		sw	s3,12(sp)	#,
 1007 0784 23244101 		sw	s4,8(sp)	#,
 1008 0788 93890700 		mv	s3,a5	# color, tmp118
 1009 078c 138A0600 		mv	s4,a3	# x1, tmp116
 1010 0790 23225101 		sw	s5,4(sp)	#,
 1011 0794 23206101 		sw	s6,0(sp)	#,
 1012              	# kianv_stdlib.h:275: {
 1013 0798 130B0700 		mv	s6,a4	# y1, tmp117
 1014              	# kianv_stdlib.h:277:   int dx =  abs(x1 - x0);
 1015 079c 97000000 		call	abs		#
 1015      E7800000 
 1016 07a4 13090500 		mv	s2,a0	# tmp119,
 1017              	# kianv_stdlib.h:279:   int dy = -abs(y1 - y0);
 1018 07a8 33059B40 		sub	a0,s6,s1	#, y1, y0
 1019 07ac 97000000 		call	abs		#
 1019      E7800000 
 1020              	# kianv_stdlib.h:278:   int sx = x0 < x1 ? 1 : -1;
 1021 07b4 B32A4401 		sgt	s5,s4,s0	# tmp109, x1, x0
 1022              	# kianv_stdlib.h:280:   int sy = y0 < y1 ? 1 : -1;
 1023 07b8 33AF6401 		sgt	t5,s6,s1	# tmp112, y1, y0
 1024              	# kianv_stdlib.h:278:   int sx = x0 < x1 ? 1 : -1;
 1025 07bc 939A1A00 		slli	s5,s5,1	#, iftmp.6_9, tmp109
 1026              	# kianv_stdlib.h:280:   int sy = y0 < y1 ? 1 : -1;
 1027 07c0 131F1F00 		slli	t5,t5,1	#, iftmp.7_10, tmp112
 1028              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1029 07c4 B7060100 		li	a3,65536		# tmp103,
 1030              	# kianv_stdlib.h:278:   int sx = x0 < x1 ? 1 : -1;
 1031 07c8 938AFAFF 		addi	s5,s5,-1	#, iftmp.6_9, iftmp.6_9
 1032              	# kianv_stdlib.h:279:   int dy = -abs(y1 - y0);
 1033 07cc B30EA040 		neg	t4,a0	# dy, _3
 1034              	# kianv_stdlib.h:280:   int sy = y0 < y1 ? 1 : -1;
 1035 07d0 130FFFFF 		addi	t5,t5,-1	#, iftmp.7_10, iftmp.7_10
 1036 07d4 3308A940 		sub	a6,s2,a0	# err, dx, _3
 1037              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1038 07d8 13930901 		slli	t1,s3,16	#, _33, color
 1039 07dc 93F8F40F 		andi	a7,s1,255	#, tmp106, y0
 1040 07e0 93158400 		slli	a1,s0,8	#, tmp107, x0
 1041              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1042 07e4 9386F6FF 		addi	a3,a3,-1	#, tmp102, tmp103
 1043              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1044 07e8 370E0030 		li	t3,805306368		# tmp105,
 1045              	.L152:
 1046              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1047 07ec B3E76800 		or	a5,a7,t1	# _33, tmp99, tmp106
 1048              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1049 07f0 33F6D500 		and	a2,a1,a3	# tmp102, tmp101, tmp107
 1050              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1051 07f4 B3E7C700 		or	a5,a5,a2	# tmp101, _40, tmp99
 1052              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1053 07f8 2324FE00 		sw	a5,8(t3)	# _40, MEM[(volatile uint32_t *)805306376B]
 1054              	# kianv_stdlib.h:286:     e2 = 2*err;
 1055 07fc 93171800 		slli	a5,a6,1	#, e2, err
 1056              	# kianv_stdlib.h:285:     if (x0 == x1 && y0 == y1) break;
 1057 0800 630E4403 		beq	s0,s4,.L160	#, x0, x1,
 1058              	.L153:
 1059              	# kianv_stdlib.h:287:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 1060 0804 63C8D701 		bgt	t4,a5,.L155	#, dy, e2,
 1061              	# kianv_stdlib.h:287:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 1062 0808 33045401 		add	s0,s0,s5	# iftmp.6_9, x0, x0
 1063 080c 3308A840 		sub	a6,a6,a0	# err, err, _3
 1064 0810 93158400 		slli	a1,s0,8	#, tmp107, x0
 1065              	.L155:
 1066              	# kianv_stdlib.h:288:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 1067 0814 E34CF9FC 		blt	s2,a5,.L152	#, dx, e2,
 1068              	# kianv_stdlib.h:288:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 1069 0818 B384E401 		add	s1,s1,t5	# iftmp.7_10, y0, y0
 1070 081c 93F8F40F 		andi	a7,s1,255	#, tmp106, y0
 1071              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1072 0820 B3E76800 		or	a5,a7,t1	# _33, tmp99, tmp106
 1073              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1074 0824 33F6D500 		and	a2,a1,a3	# tmp102, tmp101, tmp107
 1075              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1076 0828 B3E7C700 		or	a5,a5,a2	# tmp101, _40, tmp99
 1077              	# kianv_stdlib.h:288:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 1078 082c 33082801 		add	a6,a6,s2	# dx, err, err
 1079              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1080 0830 2324FE00 		sw	a5,8(t3)	# _40, MEM[(volatile uint32_t *)805306376B]
 1081              	# kianv_stdlib.h:286:     e2 = 2*err;
 1082 0834 93171800 		slli	a5,a6,1	#, e2, err
 1083              	# kianv_stdlib.h:285:     if (x0 == x1 && y0 == y1) break;
 1084 0838 E31644FD 		bne	s0,s4,.L153	#, x0, x1,
 1085              	.L160:
 1086              	# kianv_stdlib.h:285:     if (x0 == x1 && y0 == y1) break;
 1087 083c E39464FD 		bne	s1,s6,.L153	#, y0, y1,
 1088              	# kianv_stdlib.h:290: }
 1089 0840 8320C101 		lw	ra,28(sp)		#,
 1090 0844 03248101 		lw	s0,24(sp)		#,
 1091 0848 83244101 		lw	s1,20(sp)		#,
 1092 084c 03290101 		lw	s2,16(sp)		#,
 1093 0850 8329C100 		lw	s3,12(sp)		#,
 1094 0854 032A8100 		lw	s4,8(sp)		#,
 1095 0858 832A4100 		lw	s5,4(sp)		#,
 1096 085c 032B0100 		lw	s6,0(sp)		#,
 1097 0860 13010102 		addi	sp,sp,32	#,,
 1098 0864 67800000 		jr	ra		#
 1100              		.align	2
 1101              		.globl	time
 1103              	time:
 1104              	# stdlib.c:33: 	asm volatile ("rdcycle %0" : "=r"(cycles));
 1105              	 #APP
 1106              	# 33 "stdlib.c" 1
   1              	// This is free and unencumbered software released into the public domain.
   2              	//
   3              	// Anyone is free to copy, modify, publish, use, compile, sell, or
   4              	// distribute this software, either in source code form or as a compiled
   5              	// binary, for any purpose, commercial or non-commercial, and by any
   6              	// means.
   7              	
   8              	#ifndef KV_STDLIB_H
   9              	#define KV_STDLIB_H
  10              	
  11              	#include <stdarg.h>
  12              	#include <stdint.h>
  13              	#include "kianv_stdlib.h"
  14              	extern long time();
  15              	extern long insn();
  16              	
  17              	#if defined(NOT_USE_MYSTDLIB)
  18              	#else
  19              	extern char *malloc();
  20              	extern int printf(const char *format, ...);
  21              	
  22              	extern void *memcpy(void *dest, const void *src, long n);
  23              	extern char *strcpy(char *dest, const char *src);
  24              	extern int strcmp(const char *s1, const char *s2);
  25              	
  26              	char heap_memory[1024];
  27              	int heap_memory_used = 0;
  28              	#endif
  29              	
  30              	long time()
  31              	{
  32              		int cycles;
  33 0868 732500C0 		asm volatile ("rdcycle %0" : "=r"(cycles));
  34              		// printf("[time() -> %d]", cycles);
 1107              		rdcycle a0	# cycles
 1108              	# 0 "" 2
 1109              	# stdlib.c:36: }
 1110              	 #NO_APP
 1111 086c 67800000 		ret	
 1113              		.align	2
 1114              		.globl	insn
 1116              	insn:
 1117              	# stdlib.c:41: 	asm volatile ("rdinstret %0" : "=r"(insns));
 1118              	 #APP
 1119              	# 41 "stdlib.c" 1
  35              		return cycles;
  36              	}
  37              	
  38              	long insn()
  39              	{
  40              		int insns;
  41 0870 732520C0 		asm volatile ("rdinstret %0" : "=r"(insns));
  42              		// printf("[insn() -> %d]", insns);
 1120              		rdinstret a0	# insns
 1121              	# 0 "" 2
 1122              	# stdlib.c:44: }
 1123              	 #NO_APP
 1124 0874 67800000 		ret	
 1126              		.align	2
 1127              		.globl	printf
 1129              	printf:
 1130 0878 130101FA 		addi	sp,sp,-96	#,,
 1131 087c 232E8102 		sw	s0,60(sp)	#,
 1132              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1133 0880 03430500 		lbu	t1,0(a0)	# _14, *format_22(D)
 1134              	# stdlib.c:90: {
 1135 0884 232AF104 		sw	a5,84(sp)	#,
 1136              	# stdlib.c:94: 	va_start(ap, format);
 1137 0888 93074104 		addi	a5,sp,68	#, tmp119,
 1138              	# stdlib.c:90: {
 1139 088c 2322B104 		sw	a1,68(sp)	#,
 1140 0890 2324C104 		sw	a2,72(sp)	#,
 1141 0894 2326D104 		sw	a3,76(sp)	#,
 1142 0898 2328E104 		sw	a4,80(sp)	#,
 1143 089c 232C0105 		sw	a6,88(sp)	#,
 1144 08a0 232E1105 		sw	a7,92(sp)	#,
 1145              	# stdlib.c:94: 	va_start(ap, format);
 1146 08a4 2326F100 		sw	a5,12(sp)	# tmp119, MEM[(void * *)&ap]
 1147              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1148 08a8 630A0304 		beq	t1,zero,.L164	#, _14,,
 1149              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1150 08ac 93060000 		li	a3,0		# i,
 1151              	# stdlib.c:97: 		if (format[i] == '%') {
 1152 08b0 93035002 		li	t2,37		# tmp120,
 1153              	# stdlib.c:99: 				if (format[i] == 'c') {
 1154 08b4 93083006 		li	a7,99		# tmp205,
 1155              	# stdlib.c:103: 				if (format[i] == 's') {
 1156 08b8 130E3007 		li	t3,115		# tmp206,
 1157              	# stdlib.c:107: 				if (format[i] == 'd') {
 1158 08bc 930E4006 		li	t4,100		# tmp207,
 1159              	# stdlib.c:111: 				if (format[i] == 'u') {
 1160 08c0 130F5007 		li	t5,117		# tmp208,
 1161              	# stdlib.c:78: 	char *p = buffer;
 1162 08c4 930F0101 		addi	t6,sp,16	#, tmp213,
 1163              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 1164 08c8 9305A000 		li	a1,10		# tmp214,
 1165              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1166 08cc B7070030 		li	a5,805306368		# tmp215,
 1167              	# kianv_stdlib.h:195:    if (c == 13) {
 1168 08d0 9302D000 		li	t0,13		# tmp216,
 1169              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1170 08d4 1304D002 		li	s0,45		# tmp218,
 1171              	.L189:
 1172              	# stdlib.c:97: 		if (format[i] == '%') {
 1173 08d8 63027304 		beq	t1,t2,.L165	#, _14, tmp120,
 1174              	.L166:
 1175              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1176 08dc 03A70700 		lw	a4,0(a5)		# _42, MEM[(volatile uint32_t *)805306368B]
 1177              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1178 08e0 E30E07FE 		beq	a4,zero,.L166	#, _42,,
 1179              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1180 08e4 23A06700 		sw	t1,0(a5)	# _14, MEM[(volatile uint32_t *)805306368B]
 1181              	# kianv_stdlib.h:195:    if (c == 13) {
 1182 08e8 63085306 		beq	t1,t0,.L218	#, _14, tmp216,
 1183              	.L169:
 1184              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1185 08ec 93861600 		addi	a3,a3,1	#, i, i
 1186              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1187 08f0 3307D500 		add	a4,a0,a3	# i, tmp193, format
 1188 08f4 03430700 		lbu	t1,0(a4)	# _14, *_13
 1189              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1190 08f8 E31003FE 		bne	t1,zero,.L189	#, _14,,
 1191              	.L164:
 1192              	# stdlib.c:121: }
 1193 08fc 0324C103 		lw	s0,60(sp)		#,
 1194 0900 13050000 		li	a0,0		#,
 1195 0904 13010106 		addi	sp,sp,96	#,,
 1196 0908 67800000 		jr	ra		#
 1197              	.L188:
 1198              	# stdlib.c:99: 				if (format[i] == 'c') {
 1199 090c 63021703 		beq	a4,a7,.L219	#, _10, tmp205,
 1200              	# stdlib.c:103: 				if (format[i] == 's') {
 1201 0910 6308C705 		beq	a4,t3,.L220	#, _10, tmp206,
 1202              	# stdlib.c:107: 				if (format[i] == 'd') {
 1203 0914 6304D709 		beq	a4,t4,.L221	#, _10, tmp207,
 1204              	# stdlib.c:111: 				if (format[i] == 'u') {
 1205 0918 6300E711 		beq	a4,t5,.L222	#, _10, tmp208,
 1206              	.L165:
 1207              	# stdlib.c:98: 			while (format[++i]) {
 1208 091c 93861600 		addi	a3,a3,1	#, i, i
 1209              	# stdlib.c:98: 			while (format[++i]) {
 1210 0920 3307D500 		add	a4,a0,a3	# i, tmp187, format
 1211 0924 03470700 		lbu	a4,0(a4)	# _10, MEM[(const char *)_131]
 1212              	# stdlib.c:98: 			while (format[++i]) {
 1213 0928 E31207FE 		bne	a4,zero,.L188	#, _10,,
 1214 092c 6FF01FFC 		j	.L169		#
 1215              	.L219:
 1216              	# stdlib.c:100: 					printf_c(va_arg(ap,int));
 1217 0930 0327C100 		lw	a4,12(sp)		# D.2663, ap
 1218 0934 03260700 		lw	a2,0(a4)		# _4, MEM[(int *)_121]
 1219 0938 13074700 		addi	a4,a4,4	#, D.2664, D.2663
 1220 093c 2326E100 		sw	a4,12(sp)	# D.2664, ap
 1221              	# stdlib.c:49:     print_chr(c);
 1222 0940 1378F60F 		andi	a6,a2,0xff	# _33, _4
 1223              	.L168:
 1224              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1225 0944 03A70700 		lw	a4,0(a5)		# _34, MEM[(volatile uint32_t *)805306368B]
 1226              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1227 0948 E30E07FE 		beq	a4,zero,.L168	#, _34,,
 1228              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1229 094c 1376F60F 		andi	a2,a2,255	#, _36, _4
 1230 0950 23A0C700 		sw	a2,0(a5)	# _36, MEM[(volatile uint32_t *)805306368B]
 1231              	# kianv_stdlib.h:195:    if (c == 13) {
 1232 0954 E31C58F8 		bne	a6,t0,.L169	#, _33, tmp216,
 1233              	.L218:
 1234              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 1235 0958 23A0B700 		sw	a1,0(a5)	# tmp214,
 1236 095c 6FF01FF9 		j	.L169		#
 1237              	.L220:
 1238              	# stdlib.c:104: 					printf_s(va_arg(ap,char*));
 1239 0960 0327C100 		lw	a4,12(sp)		# D.2665, ap
 1240 0964 03280700 		lw	a6,0(a4)		# p, MEM[(char * *)_87]
 1241 0968 13074700 		addi	a4,a4,4	#, D.2666, D.2665
 1242 096c 2326E100 		sw	a4,12(sp)	# D.2666, ap
 1243              	.L217:
 1244              	# stdlib.c:54: 	while (*p)
 1245 0970 03460800 		lbu	a2,0(a6)	# _40,* p
 1246 0974 E30C06F6 		beq	a2,zero,.L169	#, _40,,
 1247              	.L174:
 1248              	# stdlib.c:56:     print_chr(*(p++));
 1249 0978 13081800 		addi	a6,a6,1	#, p, p
 1250              	.L171:
 1251              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1252 097c 03A70700 		lw	a4,0(a5)		# _39, MEM[(volatile uint32_t *)805306368B]
 1253              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1254 0980 E30E07FE 		beq	a4,zero,.L171	#, _39,,
 1255              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1256 0984 23A0C700 		sw	a2,0(a5)	# _40, MEM[(volatile uint32_t *)805306368B]
 1257              	# kianv_stdlib.h:195:    if (c == 13) {
 1258 0988 E31456FE 		bne	a2,t0,.L217	#, _40, tmp216,
 1259              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 1260 098c 23A0B700 		sw	a1,0(a5)	# tmp214, MEM[(volatile uint32_t *)805306368B]
 1261              	# stdlib.c:54: 	while (*p)
 1262 0990 03460800 		lbu	a2,0(a6)	# _40,* p
 1263 0994 E31206FE 		bne	a2,zero,.L174	#, _40,,
 1264 0998 6FF05FF5 		j	.L169		#
 1265              	.L221:
 1266              	# stdlib.c:108: 					printf_d(va_arg(ap,int));
 1267 099c 0326C100 		lw	a2,12(sp)		# D.2667, ap
 1268 09a0 03270600 		lw	a4,0(a2)		# val, MEM[(int *)_122]
 1269 09a4 13064600 		addi	a2,a2,4	#, D.2668, D.2667
 1270 09a8 2326C100 		sw	a2,12(sp)	# D.2668, ap
 1271              	# stdlib.c:63: 	if (val < 0) {
 1272 09ac 63440702 		blt	a4,zero,.L177	#, val,,
 1273              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1274 09b0 13860F00 		mv	a2,t6	# p, tmp213
 1275              	.L178:
 1276              	# stdlib.c:67: 	while (val || p == buffer) {
 1277 09b4 63140700 		bne	a4,zero,.L179	#, val,,
 1278 09b8 6310F605 		bne	a2,t6,.L182	#, p, tmp213,
 1279              	.L179:
 1280              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 1281 09bc 3368B702 		rem	a6,a4,a1	# tmp214, tmp145, val
 1282              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 1283 09c0 13061600 		addi	a2,a2,1	#, p, p
 1284              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 1285 09c4 13080803 		addi	a6,a6,48	#, tmp147, tmp145
 1286              	# stdlib.c:69: 		val = val / 10;
 1287 09c8 3347B702 		div	a4,a4,a1	# tmp214, val, val
 1288              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 1289 09cc A30F06FF 		sb	a6,-1(a2)	# tmp147, MEM[(char *)p_59 + 4294967295B]
 1290 09d0 6FF05FFE 		j	.L178		#
 1291              	.L177:
 1292              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1293 09d4 03A60700 		lw	a2,0(a5)		# _53, MEM[(volatile uint32_t *)805306368B]
 1294              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1295 09d8 E30E06FE 		beq	a2,zero,.L177	#, _53,,
 1296              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1297 09dc 23A08700 		sw	s0,0(a5)	# tmp218, MEM[(volatile uint32_t *)805306368B]
 1298              	# stdlib.c:65: 		val = -val;
 1299 09e0 3307E040 		neg	a4,a4	# val, val
 1300              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1301 09e4 13860F00 		mv	a2,t6	# p, tmp213
 1302 09e8 6FF0DFFC 		j	.L178		#
 1303              	.L224:
 1304              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1305 09ec 23A00701 		sw	a6,0(a5)	# _64, MEM[(volatile uint32_t *)805306368B]
 1306              	# kianv_stdlib.h:195:    if (c == 13) {
 1307 09f0 630E5800 		beq	a6,t0,.L223	#, _64, tmp216,
 1308              	# stdlib.c:71: 	while (p != buffer)
 1309 09f4 E30CF6EF 		beq	a2,t6,.L169	#, p, tmp213,
 1310              	.L182:
 1311              	# stdlib.c:72: 		printf_c(*(--p));
 1312 09f8 0348F6FF 		lbu	a6,-1(a2)	# _64, MEM[(char *)p_63]
 1313              	# stdlib.c:72: 		printf_c(*(--p));
 1314 09fc 1306F6FF 		addi	a2,a2,-1	#, p, p
 1315              	.L180:
 1316              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1317 0a00 03A70700 		lw	a4,0(a5)		# _65, MEM[(volatile uint32_t *)805306368B]
 1318              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1319 0a04 E30E07FE 		beq	a4,zero,.L180	#, _65,,
 1320 0a08 6FF05FFE 		j	.L224		#
 1321              	.L223:
 1322              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 1323 0a0c 23A0B700 		sw	a1,0(a5)	# tmp214, MEM[(volatile uint32_t *)805306368B]
 1324              	# stdlib.c:71: 	while (p != buffer)
 1325 0a10 E314F6FF 		bne	a2,t6,.L182	#, p, tmp213,
 1326 0a14 6FF09FED 		j	.L169		#
 1327              	.L222:
 1328              	# stdlib.c:112: 					printf_u(va_arg(ap,int));
 1329 0a18 0328C100 		lw	a6,12(sp)		# D.2669, ap
 1330              	# stdlib.c:78: 	char *p = buffer;
 1331 0a1c 13860F00 		mv	a2,t6	# p, tmp213
 1332              	# stdlib.c:80:   val = val >= 0 ? val : -val;
 1333 0a20 03270800 		lw	a4,0(a6)		# MEM[(int *)_125], MEM[(int *)_125]
 1334              	# stdlib.c:112: 					printf_u(va_arg(ap,int));
 1335 0a24 13084800 		addi	a6,a6,4	#, D.2670, D.2669
 1336 0a28 23260101 		sw	a6,12(sp)	# D.2670, ap
 1337              	# stdlib.c:80:   val = val >= 0 ? val : -val;
 1338 0a2c 1358F741 		srai	a6,a4,31	#, tmp163, MEM[(int *)_125]
 1339 0a30 3347E800 		xor	a4,a6,a4	# MEM[(int *)_125], val, tmp163
 1340 0a34 33070741 		sub	a4,a4,a6	# val, val, tmp163
 1341              	.L183:
 1342              	# stdlib.c:81: 	while (val || p == buffer) {
 1343 0a38 63140700 		bne	a4,zero,.L184	#, val,,
 1344 0a3c 6314F603 		bne	a2,t6,.L187	#, p, tmp213,
 1345              	.L184:
 1346              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 1347 0a40 3368B702 		rem	a6,a4,a1	# tmp214, tmp171, val
 1348              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 1349 0a44 13061600 		addi	a2,a2,1	#, p, p
 1350              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 1351 0a48 13080803 		addi	a6,a6,48	#, tmp173, tmp171
 1352              	# stdlib.c:83: 		val = val / 10;
 1353 0a4c 3347B702 		div	a4,a4,a1	# tmp214, val, val
 1354              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 1355 0a50 A30F06FF 		sb	a6,-1(a2)	# tmp173, MEM[(char *)p_75 + 4294967295B]
 1356 0a54 6FF05FFE 		j	.L183		#
 1357              	.L226:
 1358              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1359 0a58 23A00701 		sw	a6,0(a5)	# _80, MEM[(volatile uint32_t *)805306368B]
 1360              	# kianv_stdlib.h:195:    if (c == 13) {
 1361 0a5c 630E5800 		beq	a6,t0,.L225	#, _80, tmp216,
 1362              	# stdlib.c:85: 	while (p != buffer)
 1363 0a60 E306F6E9 		beq	a2,t6,.L169	#, p, tmp213,
 1364              	.L187:
 1365              	# stdlib.c:86: 		printf_c(*(--p));
 1366 0a64 0348F6FF 		lbu	a6,-1(a2)	# _80, MEM[(char *)p_79]
 1367              	# stdlib.c:86: 		printf_c(*(--p));
 1368 0a68 1306F6FF 		addi	a2,a2,-1	#, p, p
 1369              	.L185:
 1370              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1371 0a6c 03A70700 		lw	a4,0(a5)		# _81, MEM[(volatile uint32_t *)805306368B]
 1372              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1373 0a70 E30E07FE 		beq	a4,zero,.L185	#, _81,,
 1374 0a74 6FF05FFE 		j	.L226		#
 1375              	.L225:
 1376              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 1377 0a78 23A0B700 		sw	a1,0(a5)	# tmp214, MEM[(volatile uint32_t *)805306368B]
 1378              	# stdlib.c:85: 	while (p != buffer)
 1379 0a7c E314F6FF 		bne	a2,t6,.L187	#, p, tmp213,
 1380 0a80 6FF0DFE6 		j	.L169		#
 1382              		.align	2
 1383              		.globl	malloc
 1385              	malloc:
 1386              	# stdlib.c:126: 	char *p = heap_memory + heap_memory_used;
 1387 0a84 B7060000 		lui	a3,%hi(heap_memory_used)	# tmp77,
 1388 0a88 03A70600 		lw	a4,%lo(heap_memory_used)(a3)		# heap_memory_used.19_1, heap_memory_used
 1389              	# stdlib.c:128: 	heap_memory_used += size;
 1390 0a8c B307A700 		add	a5,a4,a0	# tmp83, _3, heap_memory_used.19_1
 1391              	# stdlib.c:126: 	char *p = heap_memory + heap_memory_used;
 1392 0a90 37050000 		lui	a0,%hi(.LANCHOR0)	# tmp79,
 1393              	# stdlib.c:128: 	heap_memory_used += size;
 1394 0a94 23A0F600 		sw	a5,%lo(heap_memory_used)(a3)	# _3, heap_memory_used
 1395              	# stdlib.c:126: 	char *p = heap_memory + heap_memory_used;
 1396 0a98 13050500 		addi	a0,a0,%lo(.LANCHOR0)	# tmp78, tmp79,
 1397              	# stdlib.c:129: 	if (heap_memory_used > 1024)
 1398 0a9c 93060040 		li	a3,1024		# tmp81,
 1399              	# stdlib.c:126: 	char *p = heap_memory + heap_memory_used;
 1400 0aa0 3305E500 		add	a0,a0,a4	# heap_memory_used.19_1, <retval>, tmp78
 1401              	# stdlib.c:129: 	if (heap_memory_used > 1024)
 1402 0aa4 63D4F600 		ble	a5,a3,.L227	#, _3, tmp81,
 1403              	# stdlib.c:130: 		asm volatile ("ebreak");
 1404              	 #APP
 1405              	# 130 "stdlib.c" 1
  43              		return insns;
  44              	}
  45              	
  46              	static void printf_c(int c)
  47              	{
  48              		//*((volatile int*)0x10000000) = c;
  49              	    print_chr(c);
  50              	}
  51              	
  52              	static void printf_s(char *p)
  53              	{
  54              		while (*p)
  55              			//*((volatile int*)0x10000000) = *(p++);
  56              	    print_chr(*(p++));
  57              	}
  58              	
  59              	static void printf_d(int val)
  60              	{
  61              		char buffer[32];
  62              		char *p = buffer;
  63              		if (val < 0) {
  64              			printf_c('-');
  65              			val = -val;
  66              		}
  67              		while (val || p == buffer) {
  68              			*(p++) = '0' + val % 10;
  69              			val = val / 10;
  70              		}
  71              		while (p != buffer)
  72              			printf_c(*(--p));
  73              	}
  74              	
  75              	static void printf_u(int val)
  76              	{
  77              		char buffer[32];
  78              		char *p = buffer;
  79              	
  80              	  val = val >= 0 ? val : -val;
  81              		while (val || p == buffer) {
  82              			*(p++) = '0' + val % 10;
  83              			val = val / 10;
  84              		}
  85              		while (p != buffer)
  86              			printf_c(*(--p));
  87              	}
  88              	
  89              	int printf(const char *format, ...)
  90              	{
  91              		int i;
  92              		va_list ap;
  93              	
  94              		va_start(ap, format);
  95              	
  96              		for (i = 0; format[i]; i++)
  97              			if (format[i] == '%') {
  98              				while (format[++i]) {
  99              					if (format[i] == 'c') {
 100              						printf_c(va_arg(ap,int));
 101              						break;
 102              					}
 103              					if (format[i] == 's') {
 104              						printf_s(va_arg(ap,char*));
 105              						break;
 106              					}
 107              					if (format[i] == 'd') {
 108              						printf_d(va_arg(ap,int));
 109              						break;
 110              					}
 111              					if (format[i] == 'u') {
 112              						printf_u(va_arg(ap,int));
 113              						break;
 114              					}
 115              				}
 116              			} else
 117              				printf_c(format[i]);
 118              	
 119              		va_end(ap);
 120              	  return 0;
 121              	}
 122              	
 123              	#if !defined(NOT_USE_MYSTDLIB)
 124              	char *malloc(int size)
 125              	{
 126              		char *p = heap_memory + heap_memory_used;
 127              		// printf("[malloc(%d) -> %d (%d..%d)]", size, (int)p, heap_memory_used, heap_memory_used + size);
 128              		heap_memory_used += size;
 129              		if (heap_memory_used > 1024)
 130 0aa8 73001000 			asm volatile ("ebreak");
 131              		return p;
 1406              		ebreak
 1407              	# 0 "" 2
 1408              	 #NO_APP
 1409              	.L227:
 1410              	# stdlib.c:132: }
 1411 0aac 67800000 		ret	
 1413              		.align	2
 1414              		.globl	memcpy
 1416              	memcpy:
 1417              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1418 0ab0 9308F6FF 		addi	a7,a2,-1	#, n, n
 1419              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1420 0ab4 6306060A 		beq	a2,zero,.L230	#, n,,
 1421 0ab8 13871500 		addi	a4,a1,1	#, bb, bb
 1422 0abc B307E540 		sub	a5,a0,a4	# tmp111, aa, bb
 1423 0ac0 93B73700 		sltiu	a5,a5,3	#, tmp114, tmp111
 1424 0ac4 93B67800 		sltiu	a3,a7,7	#, tmp117, n
 1425 0ac8 93C71700 		xori	a5,a5,1	#, tmp113, tmp114
 1426 0acc 93C61600 		xori	a3,a3,1	#, tmp116, tmp117
 1427 0ad0 B3F7D700 		and	a5,a5,a3	# tmp116, tmp120, tmp113
 1428 0ad4 63880706 		beq	a5,zero,.L231	#, tmp120,,
 1429 0ad8 B367B500 		or	a5,a0,a1	# bb, tmp121, aa
 1430 0adc 93F73700 		andi	a5,a5,3	#, tmp122, tmp121
 1431 0ae0 63920706 		bne	a5,zero,.L231	#, tmp122,,
 1432 0ae4 1378C6FF 		andi	a6,a2,-4	#, tmp127, n
 1433 0ae8 93870500 		mv	a5,a1	# ivtmp.316, bb
 1434 0aec 13070500 		mv	a4,a0	# ivtmp.319, aa
 1435 0af0 3308B800 		add	a6,a6,a1	# bb, _77, tmp127
 1436              	.L232:
 1437              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1438 0af4 83A60700 		lw	a3,0(a5)		# vect__1.302, MEM <const vector(4) char> [(const char *)_43]
 1439 0af8 93874700 		addi	a5,a5,4	#, ivtmp.316, ivtmp.316
 1440 0afc 13074700 		addi	a4,a4,4	#, ivtmp.319, ivtmp.319
 1441              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1442 0b00 232ED7FE 		sw	a3,-4(a4)	# vect__1.302, MEM <vector(4) char> [(char *)_45]
 1443 0b04 E39807FF 		bne	a5,a6,.L232	#, ivtmp.316, _77,
 1444 0b08 9377C6FF 		andi	a5,a2,-4	#, niters_vector_mult_vf.296, n
 1445 0b0c 3307F500 		add	a4,a0,a5	# niters_vector_mult_vf.296, tmp.297, aa
 1446 0b10 B385F500 		add	a1,a1,a5	# niters_vector_mult_vf.296, tmp.298, bb
 1447 0b14 B388F840 		sub	a7,a7,a5	# tmp.299, n, niters_vector_mult_vf.296
 1448 0b18 6304F604 		beq	a2,a5,.L230	#, n, niters_vector_mult_vf.296,
 1449              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1450 0b1c 83C70500 		lbu	a5,0(a1)	# _10, *tmp.298_55
 1451              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1452 0b20 2300F700 		sb	a5,0(a4)	# _10, *tmp.297_54
 1453              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1454 0b24 638E0802 		beq	a7,zero,.L230	#, tmp.299,,
 1455              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1456 0b28 83C61500 		lbu	a3,1(a1)	# _72, MEM[(const char *)tmp.298_55 + 1B]
 1457              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1458 0b2c 93071000 		li	a5,1		# tmp128,
 1459              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1460 0b30 A300D700 		sb	a3,1(a4)	# _72, MEM[(char *)tmp.297_54 + 1B]
 1461              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1462 0b34 6386F802 		beq	a7,a5,.L230	#, tmp.299, tmp128,
 1463              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1464 0b38 83C72500 		lbu	a5,2(a1)	# _48, MEM[(const char *)tmp.298_55 + 2B]
 1465              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1466 0b3c 2301F700 		sb	a5,2(a4)	# _48, MEM[(char *)tmp.297_54 + 2B]
 1467 0b40 67800000 		ret	
 1468              	.L231:
 1469 0b44 3306C500 		add	a2,a0,a2	# n, _23, aa
 1470              	# stdlib.c:138: 	char *a = (char *) aa;
 1471 0b48 93070500 		mv	a5,a0	# a, aa
 1472              	.L234:
 1473              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1474 0b4c 8346F7FF 		lbu	a3,-1(a4)	# _37, MEM[(const char *)b_35 + 4294967295B]
 1475              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1476 0b50 93871700 		addi	a5,a5,1	#, a, a
 1477 0b54 13071700 		addi	a4,a4,1	#, bb, bb
 1478              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1479 0b58 A38FD7FE 		sb	a3,-1(a5)	# _37, MEM[(char *)a_36 + 4294967295B]
 1480              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1481 0b5c E318F6FE 		bne	a2,a5,.L234	#, _23, a,
 1482              	.L230:
 1483              	# stdlib.c:142: }
 1484 0b60 67800000 		ret	
 1486              		.align	2
 1487              		.globl	strcpy
 1489              	strcpy:
 1490              	# stdlib.c:148: 	while ((((uint32_t)dst | (uint32_t)src) & 3) != 0)
 1491 0b64 93070500 		mv	a5,a0	# dst, dst
 1492 0b68 6F008001 		j	.L251		#
 1493              	.L253:
 1494              	# stdlib.c:150: 		char c = *(src++);
 1495 0b6c 03C70500 		lbu	a4,0(a1)	# c, MEM[(const char *)src_40 + 4294967295B]
 1496              	# stdlib.c:151: 		*(dst++) = c;
 1497 0b70 93871700 		addi	a5,a5,1	#, dst, dst
 1498              	# stdlib.c:150: 		char c = *(src++);
 1499 0b74 93851500 		addi	a1,a1,1	#, src, src
 1500              	# stdlib.c:151: 		*(dst++) = c;
 1501 0b78 A38FE7FE 		sb	a4,-1(a5)	# c, MEM[(char *)dst_42 + 4294967295B]
 1502              	# stdlib.c:152: 		if (!c) return r;
 1503 0b7c 63040708 		beq	a4,zero,.L255	#, c,,
 1504              	.L251:
 1505              	# stdlib.c:148: 	while ((((uint32_t)dst | (uint32_t)src) & 3) != 0)
 1506 0b80 33E7B700 		or	a4,a5,a1	# src, tmp101, dst
 1507              	# stdlib.c:148: 	while ((((uint32_t)dst | (uint32_t)src) & 3) != 0)
 1508 0b84 13773700 		andi	a4,a4,3	#, tmp102, tmp101
 1509              	# stdlib.c:148: 	while ((((uint32_t)dst | (uint32_t)src) & 3) != 0)
 1510 0b88 E31207FE 		bne	a4,zero,.L253	#, tmp102,,
 1511              	# stdlib.c:157: 		uint32_t v = *(uint32_t*)src;
 1512 0b8c 83A60500 		lw	a3,0(a1)		# v, MEM[(uint32_t *)src_20]
 1513              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1514 0b90 B708FFFE 		li	a7,-16842752		# tmp105,
 1515 0b94 9388F8EF 		addi	a7,a7,-257	#, tmp104, tmp105
 1516 0b98 33871601 		add	a4,a3,a7	# tmp104, tmp103, v
 1517              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1518 0b9c 13C6F6FF 		not	a2,a3	# tmp106, v
 1519              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1520 0ba0 37888080 		li	a6,-2139062272		# tmp110,
 1521              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1522 0ba4 3377C700 		and	a4,a4,a2	# tmp106, tmp107, tmp103
 1523              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1524 0ba8 13080808 		addi	a6,a6,128	#, tmp109, tmp110
 1525 0bac 33770701 		and	a4,a4,a6	# tmp109, tmp108, tmp107
 1526              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1527 0bb0 63140702 		bne	a4,zero,.L256	#, tmp108,,
 1528              	.L254:
 1529              	# stdlib.c:180: 		*(uint32_t*)dst = v;
 1530 0bb4 23A0D700 		sw	a3,0(a5)	# v, MEM[(uint32_t *)dst_51]
 1531              	# stdlib.c:157: 		uint32_t v = *(uint32_t*)src;
 1532 0bb8 83A64500 		lw	a3,4(a1)		# v, MEM[(uint32_t *)src_31]
 1533              	# stdlib.c:182: 		dst += 4;
 1534 0bbc 93874700 		addi	a5,a5,4	#, dst, dst
 1535              	# stdlib.c:181: 		src += 4;
 1536 0bc0 93854500 		addi	a1,a1,4	#, src, src
 1537              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1538 0bc4 33871601 		add	a4,a3,a7	# tmp104, tmp115, v
 1539              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1540 0bc8 13C6F6FF 		not	a2,a3	# tmp118, v
 1541              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1542 0bcc 3377C700 		and	a4,a4,a2	# tmp118, tmp119, tmp115
 1543              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1544 0bd0 33770701 		and	a4,a4,a6	# tmp109, tmp120, tmp119
 1545              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1546 0bd4 E30007FE 		beq	a4,zero,.L254	#, tmp120,,
 1547              	.L256:
 1548              	# stdlib.c:161: 			dst[0] = v & 0xff;
 1549 0bd8 2380D700 		sb	a3,0(a5)	# v, *dst_50
 1550              	# stdlib.c:162: 			if ((v & 0xff) == 0)
 1551 0bdc 13F7F60F 		andi	a4,a3,255	#, tmp111, v
 1552              	# stdlib.c:162: 			if ((v & 0xff) == 0)
 1553 0be0 63020702 		beq	a4,zero,.L255	#, tmp111,,
 1554              	# stdlib.c:164: 			v = v >> 8;
 1555 0be4 13D78600 		srli	a4,a3,8	#, v, v
 1556              	# stdlib.c:166: 			dst[1] = v & 0xff;
 1557 0be8 A380E700 		sb	a4,1(a5)	# v, MEM[(char *)dst_50 + 1B]
 1558              	# stdlib.c:167: 			if ((v & 0xff) == 0)
 1559 0bec 1377F70F 		andi	a4,a4,255	#, tmp112, v
 1560              	# stdlib.c:167: 			if ((v & 0xff) == 0)
 1561 0bf0 630A0700 		beq	a4,zero,.L255	#, tmp112,,
 1562              	# stdlib.c:169: 			v = v >> 8;
 1563 0bf4 13D70601 		srli	a4,a3,16	#, v, v
 1564              	# stdlib.c:171: 			dst[2] = v & 0xff;
 1565 0bf8 2381E700 		sb	a4,2(a5)	# v, MEM[(char *)dst_50 + 2B]
 1566              	# stdlib.c:172: 			if ((v & 0xff) == 0)
 1567 0bfc 1377F70F 		andi	a4,a4,255	#, tmp113, v
 1568              	# stdlib.c:172: 			if ((v & 0xff) == 0)
 1569 0c00 63140700 		bne	a4,zero,.L271	#, tmp113,,
 1570              	.L255:
 1571              	# stdlib.c:184: }
 1572 0c04 67800000 		ret	
 1573              	.L271:
 1574              	# stdlib.c:174: 			v = v >> 8;
 1575 0c08 93D68601 		srli	a3,a3,24	#, v, v
 1576              	# stdlib.c:176: 			dst[3] = v & 0xff;
 1577 0c0c A381D700 		sb	a3,3(a5)	# v, MEM[(char *)dst_50 + 3B]
 1578              	# stdlib.c:177: 			return r;
 1579 0c10 67800000 		ret	
 1581              		.align	2
 1582              		.globl	strcmp
 1584              	strcmp:
 1585              	# stdlib.c:188: 	while ((((uint32_t)s1 | (uint32_t)s2) & 3) != 0)
 1586 0c14 6F00C001 		j	.L273		#
 1587              	.L277:
 1588              	# stdlib.c:190: 		char c1 = *(s1++);
 1589 0c18 83470500 		lbu	a5,0(a0)	# c1, MEM[(const char *)s1_48 + 4294967295B]
 1590              	# stdlib.c:191: 		char c2 = *(s2++);
 1591 0c1c 03C70500 		lbu	a4,0(a1)	# c2, MEM[(const char *)s2_50 + 4294967295B]
 1592              	# stdlib.c:190: 		char c1 = *(s1++);
 1593 0c20 13051500 		addi	a0,a0,1	#, s1, s1
 1594              	# stdlib.c:191: 		char c2 = *(s2++);
 1595 0c24 93851500 		addi	a1,a1,1	#, s2, s2
 1596              	# stdlib.c:193: 		if (c1 != c2)
 1597 0c28 6392E706 		bne	a5,a4,.L302	#, c1, c2,
 1598              	# stdlib.c:195: 		else if (!c1)
 1599 0c2c 638C0704 		beq	a5,zero,.L292	#, c1,,
 1600              	.L273:
 1601              	# stdlib.c:188: 	while ((((uint32_t)s1 | (uint32_t)s2) & 3) != 0)
 1602 0c30 B367B500 		or	a5,a0,a1	# s2, tmp101, s1
 1603              	# stdlib.c:188: 	while ((((uint32_t)s1 | (uint32_t)s2) & 3) != 0)
 1604 0c34 93F73700 		andi	a5,a5,3	#, tmp102, tmp101
 1605              	# stdlib.c:188: 	while ((((uint32_t)s1 | (uint32_t)s2) & 3) != 0)
 1606 0c38 E39007FE 		bne	a5,zero,.L277	#, tmp102,,
 1607              	# stdlib.c:201: 		uint32_t v1 = *(uint32_t*)s1;
 1608 0c3c 83270500 		lw	a5,0(a0)		# v1, MEM[(uint32_t *)s1_14]
 1609              	# stdlib.c:202: 		uint32_t v2 = *(uint32_t*)s2;
 1610 0c40 03A70500 		lw	a4,0(a1)		# v2, MEM[(uint32_t *)s2_16]
 1611              	# stdlib.c:204: 		if (__builtin_expect(v1 != v2, 0))
 1612 0c44 639CE704 		bne	a5,a4,.L282	#, v1, v2,
 1613              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1614 0c48 3706FFFE 		li	a2,-16842752		# tmp111,
 1615              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1616 0c4c B7868080 		li	a3,-2139062272		# tmp116,
 1617              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1618 0c50 1306F6EF 		addi	a2,a2,-257	#, tmp110, tmp111
 1619              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1620 0c54 93860608 		addi	a3,a3,128	#, tmp115, tmp116
 1621 0c58 6F000001 		j	.L278		#
 1622              	.L303:
 1623              	# stdlib.c:201: 		uint32_t v1 = *(uint32_t*)s1;
 1624 0c5c 83270500 		lw	a5,0(a0)		# v1, MEM[(uint32_t *)s1_29]
 1625              	# stdlib.c:202: 		uint32_t v2 = *(uint32_t*)s2;
 1626 0c60 03A70500 		lw	a4,0(a1)		# v2, MEM[(uint32_t *)s2_30]
 1627              	# stdlib.c:204: 		if (__builtin_expect(v1 != v2, 0))
 1628 0c64 639CE702 		bne	a5,a4,.L282	#, v1, v2,
 1629              	.L278:
 1630              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1631 0c68 3387C700 		add	a4,a5,a2	# tmp110, tmp109, v1
 1632              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1633 0c6c 93C7F7FF 		not	a5,a5	# tmp112, v1
 1634              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1635 0c70 B377F700 		and	a5,a4,a5	# tmp112, tmp113, tmp109
 1636              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1637 0c74 B3F7D700 		and	a5,a5,a3	# tmp115, tmp114, tmp113
 1638              	# stdlib.c:231: 		s1 += 4;
 1639 0c78 13054500 		addi	a0,a0,4	#, s1, s1
 1640              	# stdlib.c:232: 		s2 += 4;
 1641 0c7c 93854500 		addi	a1,a1,4	#, s2, s2
 1642              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1643 0c80 E38E07FC 		beq	a5,zero,.L303	#, tmp114,,
 1644              	.L292:
 1645              	# stdlib.c:196: 			return 0;
 1646 0c84 13050000 		li	a0,0		# <retval>,
 1647              	.L272:
 1648              	# stdlib.c:234: }
 1649 0c88 67800000 		ret	
 1650              	.L302:
 1651              	# stdlib.c:194: 			return c1 < c2 ? -1 : +1;
 1652 0c8c 33B5E700 		sltu	a0,a5,a4	# c2, tmp119, c1
 1653 0c90 3305A040 		neg	a0,a0	# tmp120, tmp119
 1654 0c94 13651500 		ori	a0,a0,1	#, <retval>, tmp120
 1655 0c98 67800000 		ret	
 1656              	.L282:
 1657              	# stdlib.c:208: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1658 0c9c 93F6F70F 		andi	a3,a5,0xff	# c1, v1
 1659              	# stdlib.c:208: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1660 0ca0 1376F70F 		andi	a2,a4,0xff	# c2, v2
 1661              	# stdlib.c:209: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1662 0ca4 639AC604 		bne	a3,a2,.L300	#, c1, c2,
 1663              	# stdlib.c:196: 			return 0;
 1664 0ca8 13050000 		li	a0,0		# <retval>,
 1665              	# stdlib.c:210: 			if (!c1) return 0;
 1666 0cac E38E06FC 		beq	a3,zero,.L272	#, c1,,
 1667              	# stdlib.c:211: 			v1 = v1 >> 8, v2 = v2 >> 8;
 1668 0cb0 93D68700 		srli	a3,a5,8	#, v1, v1
 1669              	# stdlib.c:211: 			v1 = v1 >> 8, v2 = v2 >> 8;
 1670 0cb4 13568700 		srli	a2,a4,8	#, v2, v2
 1671              	# stdlib.c:213: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1672 0cb8 93F6F60F 		andi	a3,a3,0xff	# c1, v1
 1673              	# stdlib.c:213: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1674 0cbc 1376F60F 		andi	a2,a2,0xff	# c2, v2
 1675              	# stdlib.c:214: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1676 0cc0 639CC602 		bne	a3,a2,.L300	#, c1, c2,
 1677              	# stdlib.c:215: 			if (!c1) return 0;
 1678 0cc4 E38206FC 		beq	a3,zero,.L272	#, c1,,
 1679              	# stdlib.c:216: 			v1 = v1 >> 8, v2 = v2 >> 8;
 1680 0cc8 93D60701 		srli	a3,a5,16	#, v1, v1
 1681              	# stdlib.c:216: 			v1 = v1 >> 8, v2 = v2 >> 8;
 1682 0ccc 13560701 		srli	a2,a4,16	#, v2, v2
 1683              	# stdlib.c:218: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1684 0cd0 93F6F60F 		andi	a3,a3,0xff	# c1, v1
 1685              	# stdlib.c:218: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1686 0cd4 1376F60F 		andi	a2,a2,0xff	# c2, v2
 1687              	# stdlib.c:219: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1688 0cd8 6390C602 		bne	a3,a2,.L300	#, c1, c2,
 1689              	# stdlib.c:220: 			if (!c1) return 0;
 1690 0cdc E38606FA 		beq	a3,zero,.L272	#, c1,,
 1691              	# stdlib.c:223: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1692 0ce0 93D78701 		srli	a5,a5,24	#, c1, v1
 1693              	# stdlib.c:223: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1694 0ce4 13578701 		srli	a4,a4,24	#, c2, v2
 1695              	# stdlib.c:224: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1696 0ce8 E380E7FA 		beq	a5,a4,.L272	#, c1, c2,
 1697              	# stdlib.c:194: 			return c1 < c2 ? -1 : +1;
 1698 0cec 13051000 		li	a0,1		# <retval>,
 1699              	# stdlib.c:224: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1700 0cf0 E3FCE7F8 		bgeu	a5,a4,.L272	#, c1, c2,
 1701 0cf4 6F00C000 		j	.L298		#
 1702              	.L300:
 1703              	# stdlib.c:194: 			return c1 < c2 ? -1 : +1;
 1704 0cf8 13051000 		li	a0,1		# <retval>,
 1705              	# stdlib.c:219: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1706 0cfc E3F6C6F8 		bgeu	a3,a2,.L272	#, c1, c2,
 1707              	.L298:
 1708              	# stdlib.c:194: 			return c1 < c2 ? -1 : +1;
 1709 0d00 1305F0FF 		li	a0,-1		# <retval>,
 1710 0d04 67800000 		ret	
 1712              		.align	2
 1713              		.globl	sin1
 1715              	sin1:
 1716              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1717 0d08 635A0500 		bge	a0,zero,.L305	#, angle,,
 1718              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1719 0d0c B787FFFF 		li	a5,-32768		# tmp96,
 1720 0d10 3305F500 		add	a0,a0,a5	# tmp96, tmp98, angle
 1721 0d14 13150501 		slli	a0,a0,16	#, angle, tmp98
 1722 0d18 13550541 		srai	a0,a0,16	#, angle, angle
 1723              	.L305:
 1724              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 1725 0d1c 93578540 		srai	a5,a0,8	#, v0, angle
 1726              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1727 0d20 93960701 		slli	a3,a5,16	#, v0.41_4, v0
 1728              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1729 0d24 13F70702 		andi	a4,a5,32	#, tmp102, v0
 1730              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1731 0d28 93D60601 		srli	a3,a3,16	#, v0.41_4, v0.41_4
 1732              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1733 0d2c 630A0700 		beq	a4,zero,.L306	#, tmp102,,
 1734              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1735 0d30 93C7F7FF 		not	a5,a5	# tmp104, v0
 1736 0d34 93970701 		slli	a5,a5,16	#, v0, tmp104
 1737 0d38 93D70741 		srai	a5,a5,16	#, v0, v0
 1738              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1739 0d3c 1345F5FF 		not	a0,a0	# angle, angle
 1740              	.L306:
 1741              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1742 0d40 93F7F701 		andi	a5,a5,31	#, _6, v0
 1743              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1744 0d44 13861700 		addi	a2,a5,1	#, tmp114, _6
 1745              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1746 0d48 37070000 		lui	a4,%hi(.LANCHOR1)	# tmp109,
 1747 0d4c 13070700 		addi	a4,a4,%lo(.LANCHOR1)	# tmp108, tmp109,
 1748              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1749 0d50 13161600 		slli	a2,a2,1	#, tmp115, tmp114
 1750              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1751 0d54 93971700 		slli	a5,a5,1	#, tmp110, _6
 1752 0d58 B307F700 		add	a5,a4,a5	# tmp110, tmp111, tmp108
 1753              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1754 0d5c 3307C700 		add	a4,a4,a2	# tmp115, tmp116, tmp108
 1755              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1756 0d60 03960700 		lh	a2,0(a5)		# _7, sin90[_6]
 1757              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1758 0d64 83170700 		lh	a5,0(a4)		# sin90[_9], sin90[_9]
 1759              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1760 0d68 1377F50F 		andi	a4,a0,0xff	# tmp121, angle
 1761              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1762 0d6c 93F60604 		andi	a3,a3,64	#, tmp129, v0.41_4
 1763              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1764 0d70 3385C740 		sub	a0,a5,a2	# tmp118, sin90[_9], _7
 1765              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1766 0d74 3305E502 		mul	a0,a0,a4	# tmp122, tmp118, tmp121
 1767              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1768 0d78 13558540 		srai	a0,a0,8	#, tmp123, tmp122
 1769              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1770 0d7c 3305C500 		add	a0,a0,a2	# _7, tmp126, tmp123
 1771 0d80 13150501 		slli	a0,a0,16	#, _5, tmp126
 1772 0d84 13550501 		srli	a0,a0,16	#, _5, _5
 1773              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1774 0d88 63880600 		beq	a3,zero,.L307	#, tmp129,,
 1775              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1776 0d8c 3305A040 		neg	a0,a0	# tmp131, _5
 1777 0d90 13150501 		slli	a0,a0,16	#, _5, tmp131
 1778 0d94 13550501 		srli	a0,a0,16	#, _5, _5
 1779              	.L307:
 1780              	# gfx_lib_hdmi.h:94: }
 1781 0d98 13150501 		slli	a0,a0,16	#,, _5
 1782 0d9c 13550541 		srai	a0,a0,16	#,,
 1783 0da0 67800000 		ret	
 1785              		.align	2
 1786              		.globl	cos1
 1788              	cos1:
 1789              	# gfx_lib_hdmi.h:108:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1790 0da4 13160501 		slli	a2,a0,16	#, prephitmp_78, angle
 1791 0da8 13560601 		srli	a2,a2,16	#, prephitmp_78, prephitmp_78
 1792              	# gfx_lib_hdmi.h:108:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1793 0dac 63560500 		bge	a0,zero,.L315	#, angle,,
 1794              	# gfx_lib_hdmi.h:108:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1795 0db0 B7870000 		li	a5,32768		# tmp98,
 1796 0db4 3346F600 		xor	a2,a2,a5	# tmp98, prephitmp_78, prephitmp_78
 1797              	.L315:
 1798              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 1799 0db8 B7A7FFFF 		li	a5,-24576		# tmp101,
 1800 0dbc 93871700 		addi	a5,a5,1	#, tmp100, tmp101
 1801 0dc0 B307F600 		add	a5,a2,a5	# tmp100, tmp99, prephitmp_78
 1802              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 1803 0dc4 93960701 		slli	a3,a5,16	#, angle, tmp99
 1804              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 1805 0dc8 13970701 		slli	a4,a5,16	#, _4, tmp99
 1806              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 1807 0dcc 93D60641 		srai	a3,a3,16	#, angle, angle
 1808              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 1809 0dd0 13570701 		srli	a4,a4,16	#, _4, _4
 1810              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1811 0dd4 63D00602 		bge	a3,zero,.L316	#, angle,,
 1812              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1813 0dd8 B7270000 		li	a5,8192		# tmp104,
 1814 0ddc 93871700 		addi	a5,a5,1	#, tmp103, tmp104
 1815 0de0 3306F600 		add	a2,a2,a5	# tmp103, tmp102, prephitmp_78
 1816 0de4 13170601 		slli	a4,a2,16	#, _4, tmp102
 1817 0de8 93160601 		slli	a3,a2,16	#, angle, tmp102
 1818 0dec 13570701 		srli	a4,a4,16	#, _4, _4
 1819 0df0 93D60641 		srai	a3,a3,16	#, angle, angle
 1820              	.L316:
 1821              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 1822 0df4 93D78640 		srai	a5,a3,8	#, v0, angle
 1823              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1824 0df8 13960701 		slli	a2,a5,16	#, v0.41_16, v0
 1825              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1826 0dfc 93F50702 		andi	a1,a5,32	#, tmp108, v0
 1827              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1828 0e00 13560601 		srli	a2,a2,16	#, v0.41_16, v0.41_16
 1829              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1830 0e04 638A0500 		beq	a1,zero,.L317	#, tmp108,,
 1831              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1832 0e08 93C6F6FF 		not	a3,a3	# tmp112, angle
 1833              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1834 0e0c 13970601 		slli	a4,a3,16	#, _4, tmp112
 1835              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1836 0e10 93C7F7FF 		not	a5,a5	# v0, v0
 1837              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1838 0e14 13570701 		srli	a4,a4,16	#, _4, _4
 1839              	.L317:
 1840              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1841 0e18 93F7F701 		andi	a5,a5,31	#, _22, v0
 1842              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1843 0e1c 93851700 		addi	a1,a5,1	#, tmp120, _22
 1844              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1845 0e20 B7060000 		lui	a3,%hi(.LANCHOR1)	# tmp115,
 1846 0e24 93860600 		addi	a3,a3,%lo(.LANCHOR1)	# tmp114, tmp115,
 1847              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1848 0e28 93951500 		slli	a1,a1,1	#, tmp121, tmp120
 1849              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1850 0e2c 93971700 		slli	a5,a5,1	#, tmp116, _22
 1851 0e30 B387F600 		add	a5,a3,a5	# tmp116, tmp117, tmp114
 1852              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1853 0e34 B386B600 		add	a3,a3,a1	# tmp121, tmp122, tmp114
 1854 0e38 03950600 		lh	a0,0(a3)		# sin90[_25], sin90[_25]
 1855              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1856 0e3c 83950700 		lh	a1,0(a5)		# _23, sin90[_22]
 1857              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1858 0e40 9377F70F 		andi	a5,a4,0xff	# tmp126, _4
 1859              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1860 0e44 13770604 		andi	a4,a2,64	#, tmp134, v0.41_16
 1861              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1862 0e48 3305B540 		sub	a0,a0,a1	# tmp124, sin90[_25], _23
 1863              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1864 0e4c 3305F502 		mul	a0,a0,a5	# tmp127, tmp124, tmp126
 1865              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1866 0e50 13558540 		srai	a0,a0,8	#, tmp128, tmp127
 1867              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1868 0e54 3305B500 		add	a0,a0,a1	# _23, tmp131, tmp128
 1869 0e58 13150501 		slli	a0,a0,16	#, _37, tmp131
 1870 0e5c 13550501 		srli	a0,a0,16	#, _37, _37
 1871              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1872 0e60 63080700 		beq	a4,zero,.L318	#, tmp134,,
 1873              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1874 0e64 3305A040 		neg	a0,a0	# tmp136, _37
 1875 0e68 13150501 		slli	a0,a0,16	#, _37, tmp136
 1876 0e6c 13550501 		srli	a0,a0,16	#, _37, _37
 1877              	.L318:
 1878              	# gfx_lib_hdmi.h:110: }
 1879 0e70 13150501 		slli	a0,a0,16	#,, _37
 1880 0e74 13550541 		srai	a0,a0,16	#,,
 1881 0e78 67800000 		ret	
 1883              		.align	2
 1884              		.globl	oled_spi_tx
 1886              	oled_spi_tx:
 1887              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1888 0e7c 93958500 		slli	a1,a1,8	#, tmp80, tmp85
 1889 0e80 93F50510 		andi	a1,a1,256	#, tmp81, tmp80
 1890              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1891 0e84 B3E5A500 		or	a1,a1,a0	# tmp84, _6, tmp81
 1892              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1893 0e88 B7070030 		li	a5,805306368		# tmp83,
 1894 0e8c 23A6B700 		sw	a1,12(a5)	# _6, MEM[(volatile uint32_t *)805306380B]
 1895              	# gfx_lib_hdmi.h:115: }
 1896 0e90 67800000 		ret	
 1898              		.align	2
 1899              		.globl	oled_max_window
 1901              	oled_max_window:
 1902              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1903 0e94 B7070030 		li	a5,805306368		# tmp73,
 1904 0e98 13075001 		li	a4,21		# tmp74,
 1905 0e9c 23A6E700 		sw	a4,12(a5)	# tmp74, MEM[(volatile uint32_t *)805306380B]
 1906 0ea0 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
 1907 0ea4 1307F005 		li	a4,95		# tmp79,
 1908 0ea8 23A6E700 		sw	a4,12(a5)	# tmp79, MEM[(volatile uint32_t *)805306380B]
 1909 0eac 13075007 		li	a4,117		# tmp82,
 1910 0eb0 23A6E700 		sw	a4,12(a5)	# tmp82, MEM[(volatile uint32_t *)805306380B]
 1911 0eb4 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
 1912 0eb8 1307F003 		li	a4,63		# tmp87,
 1913 0ebc 23A6E700 		sw	a4,12(a5)	# tmp87, MEM[(volatile uint32_t *)805306380B]
 1914              	# gfx_lib_hdmi.h:120: }
 1915 0ec0 67800000 		ret	
 1917              		.align	2
 1918              		.globl	oled_show_fb_8or16
 1920              	oled_show_fb_8or16:
 1921 0ec4 B7560000 		li	a3,20480		# tmp79,
 1922 0ec8 938606B0 		addi	a3,a3,-1280	#, tmp78, tmp79
 1923 0ecc B306D500 		add	a3,a0,a3	# tmp78, _20, framebuffer
 1924              	.L328:
 1925              	# gfx_lib_hdmi.h:127:     *p++ = *framebuffer++;
 1926 0ed0 03270500 		lw	a4,0(a0)		# _1, MEM[(uint32_t *)framebuffer_9 + 4294967292B]
 1927              	# gfx_lib_hdmi.h:127:     *p++ = *framebuffer++;
 1928 0ed4 13054500 		addi	a0,a0,4	#, framebuffer, framebuffer
 1929              	# gfx_lib_hdmi.h:127:     *p++ = *framebuffer++;
 1930 0ed8 93854500 		addi	a1,a1,4	#, target_fb, target_fb
 1931              	# gfx_lib_hdmi.h:127:     *p++ = *framebuffer++;
 1932 0edc 23AEE5FE 		sw	a4,-4(a1)	# _1, *p_5
 1933              	# gfx_lib_hdmi.h:126:   for (int i = 0; i < (VRES*HRES); i++) {
 1934 0ee0 E318D5FE 		bne	a0,a3,.L328	#, framebuffer, _20,
 1935              	# gfx_lib_hdmi.h:132: }
 1936 0ee4 67800000 		ret	
 1938              		.align	2
 1939              		.globl	init_oled8bit_colors
 1941              	init_oled8bit_colors:
 1942 0ee8 B7070000 		lui	a5,%hi(.LANCHOR2)	# tmp78,
 1943 0eec 93870700 		addi	a5,a5,%lo(.LANCHOR2)	# ivtmp.387, tmp78,
 1944 0ef0 13865702 		addi	a2,a5,37	#, _15, ivtmp.387
 1945              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1946 0ef4 B7060030 		li	a3,805306368		# tmp80,
 1947              	.L331:
 1948              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1949 0ef8 03C70700 		lbu	a4,0(a5)	# _7, MEM[(char *)_13]
 1950              	# gfx_lib_hdmi.h:192:   for (int i = 0; i < sizeof(oled_8bit_init_seq)/
 1951 0efc 93871700 		addi	a5,a5,1	#, ivtmp.387, ivtmp.387
 1952              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1953 0f00 23A6E600 		sw	a4,12(a3)	# _7, MEM[(volatile uint32_t *)805306380B]
 1954              	# gfx_lib_hdmi.h:192:   for (int i = 0; i < sizeof(oled_8bit_init_seq)/
 1955 0f04 E39AC7FE 		bne	a5,a2,.L331	#, ivtmp.387, _15,
 1956              	# gfx_lib_hdmi.h:198: }
 1957 0f08 67800000 		ret	
 1959              		.align	2
 1960              		.globl	fb_setpixel
 1962              	fb_setpixel:
 1963              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 1964 0f0c 9307F004 		li	a5,79		# tmp84,
 1965 0f10 63E4B702 		bgtu	a1,a5,.L333	#, x, tmp84,
 1966              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 1967 0f14 9307B003 		li	a5,59		# tmp85,
 1968 0f18 63E0C702 		bgtu	a2,a5,.L333	#, y, tmp85,
 1969              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 1970 0f1c 93172600 		slli	a5,a2,2	#, tmp87, y
 1971 0f20 B387C700 		add	a5,a5,a2	# y, tmp88, tmp87
 1972 0f24 93974700 		slli	a5,a5,4	#, tmp89, tmp88
 1973 0f28 B387B700 		add	a5,a5,a1	# x, tmp90, tmp89
 1974              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 1975 0f2c 93972700 		slli	a5,a5,2	#, tmp91, tmp90
 1976 0f30 3305F500 		add	a0,a0,a5	# tmp91, tmp92, fb
 1977 0f34 2320D500 		sw	a3,0(a0)	# color, *_12
 1978              	.L333:
 1979              	# gfx_lib_hdmi.h:207: }
 1980 0f38 67800000 		ret	
 1982              		.align	2
 1983              		.globl	fb_draw_bresenham
 1985              	fb_draw_bresenham:
 1986 0f3c 130101FD 		addi	sp,sp,-48	#,,
 1987 0f40 232C4101 		sw	s4,24(sp)	#,
 1988 0f44 130A0500 		mv	s4,a0	# tmp116, fb
 1989              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 1990 0f48 3385B640 		sub	a0,a3,a1	#, x1, x0
 1991              	# gfx_lib_hdmi.h:210: {
 1992 0f4c 23261102 		sw	ra,44(sp)	#,
 1993 0f50 23248102 		sw	s0,40(sp)	#,
 1994 0f54 23229102 		sw	s1,36(sp)	#,
 1995 0f58 13040600 		mv	s0,a2	# y0, tmp118
 1996 0f5c 93840500 		mv	s1,a1	# x0, tmp117
 1997 0f60 23202103 		sw	s2,32(sp)	#,
 1998 0f64 232E3101 		sw	s3,28(sp)	#,
 1999 0f68 232A5101 		sw	s5,20(sp)	#,
 2000 0f6c 93890600 		mv	s3,a3	# x1, tmp119
 2001 0f70 23286101 		sw	s6,16(sp)	#,
 2002 0f74 23267101 		sw	s7,12(sp)	#,
 2003              	# gfx_lib_hdmi.h:210: {
 2004 0f78 130B0700 		mv	s6,a4	# y1, tmp120
 2005 0f7c 938B0700 		mv	s7,a5	# color, tmp121
 2006              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 2007 0f80 97000000 		call	abs		#
 2007      E7800000 
 2008 0f88 13090500 		mv	s2,a0	# tmp122,
 2009              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 2010 0f8c 33058B40 		sub	a0,s6,s0	#, y1, y0
 2011 0f90 97000000 		call	abs		#
 2011      E7800000 
 2012              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 2013 0f98 B3AA3401 		sgt	s5,s3,s1	# tmp107, x1, x0
 2014              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 2015 0f9c 332E6401 		sgt	t3,s6,s0	# tmp111, y1, y0
 2016              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 2017 0fa0 939A1A00 		slli	s5,s5,1	#, iftmp.50_9, tmp107
 2018              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 2019 0fa4 131E1E00 		slli	t3,t3,1	#, iftmp.51_10, tmp111
 2020              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 2021 0fa8 938AFAFF 		addi	s5,s5,-1	#, iftmp.50_9, iftmp.50_9
 2022              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 2023 0fac B308A040 		neg	a7,a0	# dy, _3
 2024              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 2025 0fb0 130EFEFF 		addi	t3,t3,-1	#, iftmp.51_10, iftmp.51_10
 2026 0fb4 3306A940 		sub	a2,s2,a0	# err, dx, _3
 2027              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 2028 0fb8 9306F004 		li	a3,79		# tmp97,
 2029              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 2030 0fbc 1303B003 		li	t1,59		# tmp115,
 2031              	.L338:
 2032              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 2033 0fc0 13182400 		slli	a6,s0,2	#, tmp100, y0
 2034 0fc4 33088800 		add	a6,a6,s0	# y0, tmp101, tmp100
 2035 0fc8 13184800 		slli	a6,a6,4	#, tmp102, tmp101
 2036 0fcc 33089800 		add	a6,a6,s1	# x0, tmp103, tmp102
 2037              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 2038 0fd0 13182800 		slli	a6,a6,2	#, tmp104, tmp103
 2039              	# gfx_lib_hdmi.h:220:     e2 = 2*err;
 2040 0fd4 93151600 		slli	a1,a2,1	#, e2, err
 2041              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 2042 0fd8 33080A01 		add	a6,s4,a6	# tmp104, tmp105, fb
 2043              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 2044 0fdc 63E69600 		bgtu	s1,a3,.L339	#, x0, tmp97,
 2045              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 2046 0fe0 63648300 		bgtu	s0,t1,.L339	#, y0, tmp115,
 2047              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 2048 0fe4 23207801 		sw	s7,0(a6)	# color, *_38
 2049              	.L339:
 2050              	# gfx_lib_hdmi.h:218:     if (x0 == x1 && y0 == y1) break;
 2051 0fe8 63803403 		beq	s1,s3,.L347	#, x0, x1,
 2052              	.L340:
 2053              	# gfx_lib_hdmi.h:221:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 2054 0fec 63C61501 		bgt	a7,a1,.L342	#, dy, e2,
 2055 0ff0 3306A640 		sub	a2,a2,a0	# err, err, _3
 2056              	# gfx_lib_hdmi.h:221:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 2057 0ff4 B3845401 		add	s1,s1,s5	# iftmp.50_9, x0, x0
 2058              	.L342:
 2059              	# gfx_lib_hdmi.h:222:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 2060 0ff8 E344B9FC 		blt	s2,a1,.L338	#, dx, e2,
 2061              	# gfx_lib_hdmi.h:222:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 2062 0ffc 33062601 		add	a2,a2,s2	# dx, err, err
 2063              	# gfx_lib_hdmi.h:222:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 2064 1000 3304C401 		add	s0,s0,t3	# iftmp.51_10, y0, y0
 2065 1004 6FF0DFFB 		j	.L338		#
 2066              	.L347:
 2067              	# gfx_lib_hdmi.h:218:     if (x0 == x1 && y0 == y1) break;
 2068 1008 E31264FF 		bne	s0,s6,.L340	#, y0, y1,
 2069              	# gfx_lib_hdmi.h:224: }
 2070 100c 8320C102 		lw	ra,44(sp)		#,
 2071 1010 03248102 		lw	s0,40(sp)		#,
 2072 1014 83244102 		lw	s1,36(sp)		#,
 2073 1018 03290102 		lw	s2,32(sp)		#,
 2074 101c 8329C101 		lw	s3,28(sp)		#,
 2075 1020 032A8101 		lw	s4,24(sp)		#,
 2076 1024 832A4101 		lw	s5,20(sp)		#,
 2077 1028 032B0101 		lw	s6,16(sp)		#,
 2078 102c 832BC100 		lw	s7,12(sp)		#,
 2079 1030 13010103 		addi	sp,sp,48	#,,
 2080 1034 67800000 		jr	ra		#
 2082              		.align	2
 2083              		.globl	fill_oled
 2085              	fill_oled:
 2086              	# gfx_lib_hdmi.h:228:     framebuffer[i] = 0x000f01<< (i % 16);//i<< (i % 16);//rgb;
 2087 1038 B7160000 		li	a3,4096		# tmp83,
 2088 103c 138616F0 		addi	a2,a3,-255	#, tmp82, tmp83
 2089              	# gfx_lib_hdmi.h:227:   for (int i = 0; i < (VRES*HRES); i++) {
 2090 1040 93070000 		li	a5,0		# i,
 2091              	# gfx_lib_hdmi.h:227:   for (int i = 0; i < (VRES*HRES); i++) {
 2092 1044 9386062C 		addi	a3,a3,704	#, tmp84, tmp83
 2093              	.L349:
 2094              	# gfx_lib_hdmi.h:228:     framebuffer[i] = 0x000f01<< (i % 16);//i<< (i % 16);//rgb;
 2095 1048 13F7F700 		andi	a4,a5,15	#, tmp80, i
 2096 104c 3317E600 		sll	a4,a2,a4	# tmp80, tmp81, tmp82
 2097              	# gfx_lib_hdmi.h:228:     framebuffer[i] = 0x000f01<< (i % 16);//i<< (i % 16);//rgb;
 2098 1050 2320E500 		sw	a4,0(a0)	# tmp81, MEM[(uint32_t *)_14]
 2099              	# gfx_lib_hdmi.h:227:   for (int i = 0; i < (VRES*HRES); i++) {
 2100 1054 93871700 		addi	a5,a5,1	#, i, i
 2101              	# gfx_lib_hdmi.h:227:   for (int i = 0; i < (VRES*HRES); i++) {
 2102 1058 13054500 		addi	a0,a0,4	#, ivtmp.402, ivtmp.402
 2103 105c E396D7FE 		bne	a5,a3,.L349	#, i, tmp84,
 2104              	# gfx_lib_hdmi.h:233: }
 2105 1060 67800000 		ret	
 2107              		.align	2
 2108              		.globl	mirror_x_axis
 2110              	mirror_x_axis:
 2111              	# gfx_lib_hdmi.h:236:   point transformed = {p->x, 1.0 * p->y};
 2112 1064 03A74500 		lw	a4,4(a1)		# vect__1.409, MEM[(int *)p_4(D) + 4B]
 2113              	# gfx_lib_hdmi.h:237:   return transformed;
 2114 1068 83A60500 		lw	a3,0(a1)		# MEM[(int *)p_4(D)], MEM[(int *)p_4(D)]
 2115 106c 23240500 		sw	zero,8(a0)	#, <retval>.z
 2116 1070 2322E500 		sw	a4,4(a0)	# vect__1.409, MEM[(int *)&<retval> + 4B]
 2117 1074 2320D500 		sw	a3,0(a0)	# MEM[(int *)p_4(D)], MEM[(int *)&<retval>]
 2118              	# gfx_lib_hdmi.h:238: }
 2119 1078 67800000 		ret	
 2121              		.globl	__floatsidf
 2122              		.globl	__fixdfsi
 2123              		.align	2
 2124              		.globl	mirror_y_axis
 2126              	mirror_y_axis:
 2127 107c 130101FF 		addi	sp,sp,-16	#,,
 2128 1080 23248100 		sw	s0,8(sp)	#,
 2129 1084 13040500 		mv	s0,a0	# tmp88, .result_ptr
 2130              	# gfx_lib_hdmi.h:241:   point transformed = {-1.0 * p->x, p->y};
 2131 1088 03A50500 		lw	a0,0(a1)		#, p_7(D)->x
 2132              	# gfx_lib_hdmi.h:240: point mirror_y_axis(point *p) {
 2133 108c 23261100 		sw	ra,12(sp)	#,
 2134 1090 23229100 		sw	s1,4(sp)	#,
 2135              	# gfx_lib_hdmi.h:241:   point transformed = {-1.0 * p->x, p->y};
 2136 1094 83A44500 		lw	s1,4(a1)		# _5, p_7(D)->y
 2137              	# gfx_lib_hdmi.h:241:   point transformed = {-1.0 * p->x, p->y};
 2138 1098 97000000 		call	__floatsidf		#
 2138      E7800000 
 2139              	# gfx_lib_hdmi.h:241:   point transformed = {-1.0 * p->x, p->y};
 2140 10a0 B7070080 		li	a5,-2147483648		# tmp81,
 2141 10a4 13070500 		mv	a4,a0	# tmp93, tmp90
 2142 10a8 B3C7B700 		xor	a5,a5,a1	# tmp91, tmp94, tmp81
 2143 10ac 13050700 		mv	a0,a4	# tmp95, tmp93
 2144 10b0 93850700 		mv	a1,a5	#, tmp94
 2145 10b4 97000000 		call	__fixdfsi		#
 2145      E7800000 
 2146 10bc 2320A400 		sw	a0,0(s0)	# tmp92, <retval>.x
 2147              	# gfx_lib_hdmi.h:242:   return transformed;
 2148 10c0 23229400 		sw	s1,4(s0)	# _5, <retval>.y
 2149              	# gfx_lib_hdmi.h:243: }
 2150 10c4 8320C100 		lw	ra,12(sp)		#,
 2151              	# gfx_lib_hdmi.h:242:   return transformed;
 2152 10c8 23240400 		sw	zero,8(s0)	#, <retval>.z
 2153              	# gfx_lib_hdmi.h:243: }
 2154 10cc 13050400 		mv	a0,s0	#, .result_ptr
 2155 10d0 03248100 		lw	s0,8(sp)		#,
 2156 10d4 83244100 		lw	s1,4(sp)		#,
 2157 10d8 13010101 		addi	sp,sp,16	#,,
 2158 10dc 67800000 		jr	ra		#
 2160              		.align	2
 2161              		.globl	mirror_z_axis
 2163              	mirror_z_axis:
 2164 10e0 130101FF 		addi	sp,sp,-16	#,,
 2165 10e4 23248100 		sw	s0,8(sp)	#,
 2166 10e8 13040500 		mv	s0,a0	# tmp89, .result_ptr
 2167              	# gfx_lib_hdmi.h:246:   point transformed = {p->x, p->y, -1.0 * p->z};
 2168 10ec 03A58500 		lw	a0,8(a1)		#, p_8(D)->z
 2169              	# gfx_lib_hdmi.h:245: point mirror_z_axis(point *p) {
 2170 10f0 23261100 		sw	ra,12(sp)	#,
 2171 10f4 23229100 		sw	s1,4(sp)	#,
 2172 10f8 23202101 		sw	s2,0(sp)	#,
 2173              	# gfx_lib_hdmi.h:245: point mirror_z_axis(point *p) {
 2174 10fc 93840500 		mv	s1,a1	# p, tmp90
 2175              	# gfx_lib_hdmi.h:246:   point transformed = {p->x, p->y, -1.0 * p->z};
 2176 1100 03A94500 		lw	s2,4(a1)		# vect__1.421, MEM[(int *)p_8(D) + 4B]
 2177              	# gfx_lib_hdmi.h:246:   point transformed = {p->x, p->y, -1.0 * p->z};
 2178 1104 97000000 		call	__floatsidf		#
 2178      E7800000 
 2179              	# gfx_lib_hdmi.h:246:   point transformed = {p->x, p->y, -1.0 * p->z};
 2180 110c B7070080 		li	a5,-2147483648		# tmp82,
 2181 1110 B3C7B700 		xor	a5,a5,a1	# tmp92, tmp95, tmp82
 2182 1114 13070500 		mv	a4,a0	# tmp94, tmp91
 2183 1118 93850700 		mv	a1,a5	#, tmp95
 2184 111c 13050700 		mv	a0,a4	# tmp96, tmp94
 2185 1120 97000000 		call	__fixdfsi		#
 2185      E7800000 
 2186              	# gfx_lib_hdmi.h:247:   return transformed;
 2187 1128 83A70400 		lw	a5,0(s1)		# MEM[(int *)p_8(D)], MEM[(int *)p_8(D)]
 2188 112c 23222401 		sw	s2,4(s0)	# vect__1.421, MEM[(int *)&<retval> + 4B]
 2189 1130 2324A400 		sw	a0,8(s0)	# tmp93, <retval>.z
 2190              	# gfx_lib_hdmi.h:248: }
 2191 1134 8320C100 		lw	ra,12(sp)		#,
 2192              	# gfx_lib_hdmi.h:247:   return transformed;
 2193 1138 2320F400 		sw	a5,0(s0)	# MEM[(int *)p_8(D)], MEM[(int *)&<retval>]
 2194              	# gfx_lib_hdmi.h:248: }
 2195 113c 13050400 		mv	a0,s0	#, .result_ptr
 2196 1140 03248100 		lw	s0,8(sp)		#,
 2197 1144 83244100 		lw	s1,4(sp)		#,
 2198 1148 03290100 		lw	s2,0(sp)		#,
 2199 114c 13010101 		addi	sp,sp,16	#,,
 2200 1150 67800000 		jr	ra		#
 2202              		.globl	__floatsisf
 2203              		.globl	__mulsf3
 2204              		.globl	__fixsfsi
 2205              		.align	2
 2206              		.globl	scale
 2208              	scale:
 2209 1154 130101FE 		addi	sp,sp,-32	#,,
 2210 1158 232C8100 		sw	s0,24(sp)	#,
 2211 115c 13040500 		mv	s0,a0	# tmp96, .result_ptr
 2212              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2213 1160 03A54500 		lw	a0,4(a1)		#, p_14(D)->y
 2214              	# gfx_lib_hdmi.h:250: point scale(point *p, float sx, float sy, float sz) {
 2215 1164 232E1100 		sw	ra,28(sp)	#,
 2216 1168 232A9100 		sw	s1,20(sp)	#,
 2217 116c 23282101 		sw	s2,16(sp)	#,
 2218 1170 23263101 		sw	s3,12(sp)	#,
 2219 1174 13890600 		mv	s2,a3	# sy, tmp99
 2220 1178 93090600 		mv	s3,a2	# sx, tmp98
 2221 117c 23244101 		sw	s4,8(sp)	#,
 2222              	# gfx_lib_hdmi.h:250: point scale(point *p, float sx, float sy, float sz) {
 2223 1180 93840500 		mv	s1,a1	# p, tmp97
 2224 1184 130A0700 		mv	s4,a4	# sz, tmp100
 2225              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2226 1188 97000000 		call	__floatsisf		#
 2226      E7800000 
 2227 1190 93050900 		mv	a1,s2	#, sy
 2228 1194 97000000 		call	__mulsf3		#
 2228      E7800000 
 2229              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2230 119c 97000000 		call	__fixsfsi		#
 2230      E7800000 
 2231 11a4 13090500 		mv	s2,a0	# tmp101,
 2232              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2233 11a8 03A58400 		lw	a0,8(s1)		#, p_14(D)->z
 2234 11ac 97000000 		call	__floatsisf		#
 2234      E7800000 
 2235 11b4 93050A00 		mv	a1,s4	#, sz
 2236 11b8 97000000 		call	__mulsf3		#
 2236      E7800000 
 2237              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2238 11c0 97000000 		call	__fixsfsi		#
 2238      E7800000 
 2239 11c8 93070500 		mv	a5,a0	# tmp102,
 2240              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2241 11cc 03A50400 		lw	a0,0(s1)		#, p_14(D)->x
 2242              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2243 11d0 93840700 		mv	s1,a5	# _12, tmp102
 2244              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2245 11d4 97000000 		call	__floatsisf		#
 2245      E7800000 
 2246 11dc 93850900 		mv	a1,s3	#, sx
 2247 11e0 97000000 		call	__mulsf3		#
 2247      E7800000 
 2248              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2249 11e8 97000000 		call	__fixsfsi		#
 2249      E7800000 
 2250 11f0 2320A400 		sw	a0,0(s0)	# tmp103, <retval>.x
 2251              	# gfx_lib_hdmi.h:252:   return transformed;
 2252 11f4 23222401 		sw	s2,4(s0)	# _8, <retval>.y
 2253 11f8 23249400 		sw	s1,8(s0)	# _12, <retval>.z
 2254              	# gfx_lib_hdmi.h:253: }
 2255 11fc 8320C101 		lw	ra,28(sp)		#,
 2256 1200 13050400 		mv	a0,s0	#, .result_ptr
 2257 1204 03248101 		lw	s0,24(sp)		#,
 2258 1208 83244101 		lw	s1,20(sp)		#,
 2259 120c 03290101 		lw	s2,16(sp)		#,
 2260 1210 8329C100 		lw	s3,12(sp)		#,
 2261 1214 032A8100 		lw	s4,8(sp)		#,
 2262 1218 13010102 		addi	sp,sp,32	#,,
 2263 121c 67800000 		jr	ra		#
 2265              		.align	2
 2266              		.globl	translate
 2268              	translate:
 2269              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2270 1220 83A84500 		lw	a7,4(a1)		# p_8(D)->y, p_8(D)->y
 2271              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2272 1224 03A88500 		lw	a6,8(a1)		# p_8(D)->z, p_8(D)->z
 2273              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2274 1228 83A50500 		lw	a1,0(a1)		# p_8(D)->x, p_8(D)->x
 2275              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2276 122c B3861601 		add	a3,a3,a7	# p_8(D)->y, _4, tmp90
 2277              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2278 1230 33070701 		add	a4,a4,a6	# p_8(D)->z, _6, tmp91
 2279              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2280 1234 B385C500 		add	a1,a1,a2	# tmp89, tmp85, p_8(D)->x
 2281              	# gfx_lib_hdmi.h:257:   return transformed;
 2282 1238 2320B500 		sw	a1,0(a0)	# tmp85, <retval>.x
 2283 123c 2322D500 		sw	a3,4(a0)	# _4, <retval>.y
 2284 1240 2324E500 		sw	a4,8(a0)	# _6, <retval>.z
 2285              	# gfx_lib_hdmi.h:258: }
 2286 1244 67800000 		ret	
 2288              		.globl	__muldf3
 2289              		.globl	__divdf3
 2290              		.globl	__truncdfsf2
 2291              		.globl	__subsf3
 2292              		.globl	__addsf3
 2293              		.align	2
 2294              		.globl	rotateX_pivot
 2296              	rotateX_pivot:
 2297 1248 130101FD 		addi	sp,sp,-48	#,,
 2298 124c 23248102 		sw	s0,40(sp)	#,
 2299 1250 13040500 		mv	s0,a0	# tmp259, .result_ptr
 2300              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2301 1254 13850600 		mv	a0,a3	#, tmp262
 2302              	# gfx_lib_hdmi.h:261: point rotateX_pivot(point *p, point *pivot, int angle) {
 2303 1258 23261102 		sw	ra,44(sp)	#,
 2304 125c 23229102 		sw	s1,36(sp)	#,
 2305 1260 23202103 		sw	s2,32(sp)	#,
 2306              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2307 1264 83A48500 		lw	s1,8(a1)		# p_32(D)->z, p_32(D)->z
 2308              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2309 1268 03A94500 		lw	s2,4(a1)		# p_32(D)->y, p_32(D)->y
 2310              	# gfx_lib_hdmi.h:261: point rotateX_pivot(point *p, point *pivot, int angle) {
 2311 126c 232E3101 		sw	s3,28(sp)	#,
 2312 1270 232C4101 		sw	s4,24(sp)	#,
 2313              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2314 1274 83298600 		lw	s3,8(a2)		# _6, pivot_33(D)->z
 2315              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2316 1278 032A4600 		lw	s4,4(a2)		# _3, pivot_33(D)->y
 2317              	# gfx_lib_hdmi.h:261: point rotateX_pivot(point *p, point *pivot, int angle) {
 2318 127c 23286101 		sw	s6,16(sp)	#,
 2319 1280 23248101 		sw	s8,8(sp)	#,
 2320              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2321 1284 03AB0500 		lw	s6,0(a1)		# _1, p_32(D)->x
 2322              	# gfx_lib_hdmi.h:261: point rotateX_pivot(point *p, point *pivot, int angle) {
 2323 1288 232A5101 		sw	s5,20(sp)	#,
 2324 128c 23267101 		sw	s7,12(sp)	#,
 2325 1290 23229101 		sw	s9,4(sp)	#,
 2326              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2327 1294 97000000 		call	__floatsidf		#
 2327      E7800000 
 2328 129c B7070000 		lui	a5,%hi(.LC1)	# tmp156,
 2329 12a0 03A60700 		lw	a2,%lo(.LC1)(a5)		#,
 2330 12a4 83A64700 		lw	a3,%lo(.LC1+4)(a5)		#,
 2331              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2332 12a8 33094941 		sub	s2,s2,s4	# _4, p_32(D)->y, _3
 2333              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2334 12ac B3843441 		sub	s1,s1,s3	# _7, p_32(D)->z, _6
 2335              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2336 12b0 97000000 		call	__muldf3		#
 2336      E7800000 
 2337 12b8 B7070000 		lui	a5,%hi(.LC2)	# tmp158,
 2338 12bc 03A60700 		lw	a2,%lo(.LC2)(a5)		#,
 2339 12c0 83A64700 		lw	a3,%lo(.LC2+4)(a5)		#,
 2340 12c4 97000000 		call	__divdf3		#
 2340      E7800000 
 2341 12cc 97000000 		call	__fixdfsi		#
 2341      E7800000 
 2342 12d4 13170501 		slli	a4,a0,16	#, angle, tmp263
 2343              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2344 12d8 131C0501 		slli	s8,a0,16	#, prephitmp_203, tmp263
 2345              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2346 12dc 13570741 		srai	a4,a4,16	#, angle, angle
 2347              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2348 12e0 135C0C01 		srli	s8,s8,16	#, prephitmp_203, prephitmp_203
 2349              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2350 12e4 635A0700 		bge	a4,zero,.L360	#, angle,,
 2351              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2352 12e8 B7870000 		li	a5,32768		# tmp163,
 2353 12ec 334CFC00 		xor	s8,s8,a5	# tmp163, prephitmp_203, prephitmp_203
 2354 12f0 13170C01 		slli	a4,s8,16	#, angle, prephitmp_203
 2355 12f4 13570741 		srai	a4,a4,16	#, angle, angle
 2356              	.L360:
 2357              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 2358 12f8 93578740 		srai	a5,a4,8	#, v0, angle
 2359              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2360 12fc 13960701 		slli	a2,a5,16	#, v0.41_53, v0
 2361              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2362 1300 93F50702 		andi	a1,a5,32	#, tmp167, v0
 2363              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2364 1304 13560601 		srli	a2,a2,16	#, v0.41_53, v0.41_53
 2365 1308 93060C00 		mv	a3,s8	# _235, prephitmp_203
 2366              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2367 130c 638A0500 		beq	a1,zero,.L361	#, tmp167,,
 2368              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2369 1310 1347F7FF 		not	a4,a4	# tmp171, angle
 2370              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2371 1314 93160701 		slli	a3,a4,16	#, _235, tmp171
 2372              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2373 1318 93C7F7FF 		not	a5,a5	# v0, v0
 2374              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2375 131c 93D60601 		srli	a3,a3,16	#, _235, _235
 2376              	.L361:
 2377              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2378 1320 93F7F701 		andi	a5,a5,31	#, _59, v0
 2379              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2380 1324 13871700 		addi	a4,a5,1	#, tmp179, _59
 2381              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2382 1328 B70B0000 		lui	s7,%hi(.LANCHOR1)	# tmp256,
 2383 132c 938B0B00 		addi	s7,s7,%lo(.LANCHOR1)	# tmp258, tmp256,
 2384 1330 93971700 		slli	a5,a5,1	#, tmp175, _59
 2385              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2386 1334 13171700 		slli	a4,a4,1	#, tmp180, tmp179
 2387              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2388 1338 B387FB00 		add	a5,s7,a5	# tmp175, tmp176, tmp258
 2389              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2390 133c 3387EB00 		add	a4,s7,a4	# tmp180, tmp181, tmp258
 2391              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2392 1340 83950700 		lh	a1,0(a5)		# _60, sin90[_59]
 2393              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2394 1344 03150700 		lh	a0,0(a4)		# sin90[_62], sin90[_62]
 2395              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2396 1348 93F6F60F 		andi	a3,a3,0xff	# tmp185, _235
 2397              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2398 134c 93770604 		andi	a5,a2,64	#, tmp193, v0.41_53
 2399              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2400 1350 3305B540 		sub	a0,a0,a1	# tmp183, sin90[_62], _60
 2401              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2402 1354 3305D502 		mul	a0,a0,a3	# tmp186, tmp183, tmp185
 2403              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2404 1358 13558540 		srai	a0,a0,8	#, tmp187, tmp186
 2405              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2406 135c 3305B500 		add	a0,a0,a1	# _60, tmp190, tmp187
 2407 1360 13150501 		slli	a0,a0,16	#, _74, tmp190
 2408 1364 13550501 		srli	a0,a0,16	#, _74, _74
 2409              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2410 1368 63880700 		beq	a5,zero,.L362	#, tmp193,,
 2411              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2412 136c 3305A040 		neg	a0,a0	# tmp195, _74
 2413 1370 13150501 		slli	a0,a0,16	#, _74, tmp195
 2414 1374 13550501 		srli	a0,a0,16	#, _74, _74
 2415              	.L362:
 2416              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2417 1378 13150501 		slli	a0,a0,16	#,, _74
 2418 137c 13550541 		srai	a0,a0,16	#,,
 2419 1380 97000000 		call	__floatsidf		#
 2419      E7800000 
 2420 1388 B70A0000 		lui	s5,%hi(.LC3)	# tmp257,
 2421 138c 83A64A00 		lw	a3,%lo(.LC3+4)(s5)		#,
 2422 1390 03A60A00 		lw	a2,%lo(.LC3)(s5)		#,
 2423 1394 97000000 		call	__muldf3		#
 2423      E7800000 
 2424              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2425 139c 97000000 		call	__truncdfsf2		#
 2425      E7800000 
 2426              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2427 13a4 B7A7FFFF 		li	a5,-24576		# tmp203,
 2428 13a8 93871700 		addi	a5,a5,1	#, tmp202, tmp203
 2429 13ac B307FC00 		add	a5,s8,a5	# tmp202, tmp201, prephitmp_203
 2430              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2431 13b0 93960701 		slli	a3,a5,16	#, angle, tmp201
 2432              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2433 13b4 13970701 		slli	a4,a5,16	#, _42, tmp201
 2434              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2435 13b8 93D60641 		srai	a3,a3,16	#, angle, angle
 2436              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2437 13bc 930C0500 		mv	s9,a0	# sin_theta, tmp264
 2438              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2439 13c0 13570701 		srli	a4,a4,16	#, _42, _42
 2440              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2441 13c4 63D00602 		bge	a3,zero,.L363	#, angle,,
 2442              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2443 13c8 B7270000 		li	a5,8192		# tmp206,
 2444 13cc 93871700 		addi	a5,a5,1	#, tmp205, tmp206
 2445 13d0 330CFC00 		add	s8,s8,a5	# tmp205, tmp204, prephitmp_203
 2446 13d4 13170C01 		slli	a4,s8,16	#, _42, tmp204
 2447 13d8 93160C01 		slli	a3,s8,16	#, angle, tmp204
 2448 13dc 13570701 		srli	a4,a4,16	#, _42, _42
 2449 13e0 93D60641 		srai	a3,a3,16	#, angle, angle
 2450              	.L363:
 2451              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 2452 13e4 93D78640 		srai	a5,a3,8	#, v0, angle
 2453              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2454 13e8 13960701 		slli	a2,a5,16	#, v0.41_84, v0
 2455              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2456 13ec 93F50702 		andi	a1,a5,32	#, tmp210, v0
 2457              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2458 13f0 13560601 		srli	a2,a2,16	#, v0.41_84, v0.41_84
 2459              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2460 13f4 638A0500 		beq	a1,zero,.L364	#, tmp210,,
 2461              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2462 13f8 93C6F6FF 		not	a3,a3	# tmp214, angle
 2463              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2464 13fc 13970601 		slli	a4,a3,16	#, _42, tmp214
 2465              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2466 1400 93C7F7FF 		not	a5,a5	# v0, v0
 2467              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2468 1404 13570701 		srli	a4,a4,16	#, _42, _42
 2469              	.L364:
 2470              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2471 1408 93F7F701 		andi	a5,a5,31	#, _90, v0
 2472              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2473 140c 93861700 		addi	a3,a5,1	#, tmp222, _90
 2474 1410 93961600 		slli	a3,a3,1	#, tmp223, tmp222
 2475              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2476 1414 93971700 		slli	a5,a5,1	#, tmp218, _90
 2477 1418 B387FB00 		add	a5,s7,a5	# tmp218, tmp219, tmp258
 2478              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2479 141c B38BDB00 		add	s7,s7,a3	# tmp223, tmp224, tmp258
 2480              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2481 1420 83950700 		lh	a1,0(a5)		# _91, sin90[_90]
 2482              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2483 1424 83970B00 		lh	a5,0(s7)		# sin90[_93], sin90[_93]
 2484              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2485 1428 1377F70F 		andi	a4,a4,0xff	# tmp228, _42
 2486              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2487 142c 93760604 		andi	a3,a2,64	#, tmp236, v0.41_84
 2488              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2489 1430 B387B740 		sub	a5,a5,a1	# tmp226, sin90[_93], _91
 2490              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2491 1434 B387E702 		mul	a5,a5,a4	# tmp229, tmp226, tmp228
 2492              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2493 1438 93D78740 		srai	a5,a5,8	#, tmp230, tmp229
 2494              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2495 143c B387B700 		add	a5,a5,a1	# _91, tmp233, tmp230
 2496 1440 93970701 		slli	a5,a5,16	#, _105, tmp233
 2497 1444 93D70701 		srli	a5,a5,16	#, _105, _105
 2498              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2499 1448 63880600 		beq	a3,zero,.L365	#, tmp236,,
 2500              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2501 144c B307F040 		neg	a5,a5	# tmp238, _105
 2502 1450 93970701 		slli	a5,a5,16	#, _105, tmp238
 2503 1454 93D70701 		srli	a5,a5,16	#, _105, _105
 2504              	.L365:
 2505              	# gfx_lib_hdmi.h:267:   float cos_theta = COS_FAST(angle);
 2506 1458 13950701 		slli	a0,a5,16	#,, _105
 2507 145c 13550541 		srai	a0,a0,16	#,,
 2508 1460 97000000 		call	__floatsidf		#
 2508      E7800000 
 2509 1468 03A60A00 		lw	a2,%lo(.LC3)(s5)		#,
 2510 146c 83A64A00 		lw	a3,%lo(.LC3+4)(s5)		#,
 2511 1470 97000000 		call	__muldf3		#
 2511      E7800000 
 2512              	# gfx_lib_hdmi.h:267:   float cos_theta = COS_FAST(angle);
 2513 1478 97000000 		call	__truncdfsf2		#
 2513      E7800000 
 2514 1480 93070500 		mv	a5,a0	# tmp265,
 2515              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2516 1484 13050900 		mv	a0,s2	#, _4
 2517              	# gfx_lib_hdmi.h:267:   float cos_theta = COS_FAST(angle);
 2518 1488 13890700 		mv	s2,a5	# tmp243, tmp265
 2519              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2520 148c 97000000 		call	__floatsisf		#
 2520      E7800000 
 2521 1494 930A0500 		mv	s5,a0	# tmp266,
 2522              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2523 1498 13850400 		mv	a0,s1	#, _7
 2524 149c 97000000 		call	__floatsisf		#
 2524      E7800000 
 2525 14a4 93040500 		mv	s1,a0	# tmp267,
 2526              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2527 14a8 93050900 		mv	a1,s2	#, tmp243
 2528              	# gfx_lib_hdmi.h:273:   return transformed;
 2529 14ac 23206401 		sw	s6,0(s0)	# _1, <retval>.x
 2530              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2531 14b0 13850A00 		mv	a0,s5	#, _18
 2532 14b4 97000000 		call	__mulsf3		#
 2532      E7800000 
 2533 14bc 130B0500 		mv	s6,a0	# tmp244, tmp268
 2534              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2535 14c0 93850C00 		mv	a1,s9	#, sin_theta
 2536 14c4 13850400 		mv	a0,s1	#, _20
 2537 14c8 97000000 		call	__mulsf3		#
 2537      E7800000 
 2538 14d0 93050500 		mv	a1,a0	# tmp269,
 2539              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2540 14d4 13050B00 		mv	a0,s6	#, tmp244
 2541 14d8 97000000 		call	__subsf3		#
 2541      E7800000 
 2542 14e0 130B0500 		mv	s6,a0	# tmp246, tmp270
 2543              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2544 14e4 13050A00 		mv	a0,s4	#, _3
 2545 14e8 97000000 		call	__floatsisf		#
 2545      E7800000 
 2546 14f0 93050500 		mv	a1,a0	# tmp271,
 2547 14f4 13050B00 		mv	a0,s6	#, tmp246
 2548 14f8 97000000 		call	__addsf3		#
 2548      E7800000 
 2549              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2550 1500 97000000 		call	__fixsfsi		#
 2550      E7800000 
 2551              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 2552 1508 93850C00 		mv	a1,s9	#, sin_theta
 2553              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2554 150c 2322A400 		sw	a0,4(s0)	# tmp272, <retval>.y
 2555              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 2556 1510 13850A00 		mv	a0,s5	#, _18
 2557 1514 97000000 		call	__mulsf3		#
 2557      E7800000 
 2558 151c 130A0500 		mv	s4,a0	# tmp250, tmp273
 2559              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 2560 1520 93050900 		mv	a1,s2	#, tmp243
 2561 1524 13850400 		mv	a0,s1	#, _20
 2562 1528 97000000 		call	__mulsf3		#
 2562      E7800000 
 2563 1530 93050500 		mv	a1,a0	# tmp274,
 2564              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 2565 1534 13050A00 		mv	a0,s4	#, tmp250
 2566 1538 97000000 		call	__addsf3		#
 2566      E7800000 
 2567 1540 93040500 		mv	s1,a0	# tmp252, tmp275
 2568              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 2569 1544 13850900 		mv	a0,s3	#, _6
 2570 1548 97000000 		call	__floatsisf		#
 2570      E7800000 
 2571 1550 93050500 		mv	a1,a0	# tmp276,
 2572 1554 13850400 		mv	a0,s1	#, tmp252
 2573 1558 97000000 		call	__addsf3		#
 2573      E7800000 
 2574              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 2575 1560 97000000 		call	__fixsfsi		#
 2575      E7800000 
 2576 1568 2324A400 		sw	a0,8(s0)	# tmp277, <retval>.z
 2577              	# gfx_lib_hdmi.h:274: }
 2578 156c 8320C102 		lw	ra,44(sp)		#,
 2579 1570 13050400 		mv	a0,s0	#, .result_ptr
 2580 1574 03248102 		lw	s0,40(sp)		#,
 2581 1578 83244102 		lw	s1,36(sp)		#,
 2582 157c 03290102 		lw	s2,32(sp)		#,
 2583 1580 8329C101 		lw	s3,28(sp)		#,
 2584 1584 032A8101 		lw	s4,24(sp)		#,
 2585 1588 832A4101 		lw	s5,20(sp)		#,
 2586 158c 032B0101 		lw	s6,16(sp)		#,
 2587 1590 832BC100 		lw	s7,12(sp)		#,
 2588 1594 032C8100 		lw	s8,8(sp)		#,
 2589 1598 832C4100 		lw	s9,4(sp)		#,
 2590 159c 13010103 		addi	sp,sp,48	#,,
 2591 15a0 67800000 		jr	ra		#
 2593              		.align	2
 2594              		.globl	rotateY_pivot
 2596              	rotateY_pivot:
 2597 15a4 130101FD 		addi	sp,sp,-48	#,,
 2598 15a8 23248102 		sw	s0,40(sp)	#,
 2599 15ac 13040500 		mv	s0,a0	# tmp259, .result_ptr
 2600              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2601 15b0 13850600 		mv	a0,a3	#, tmp262
 2602              	# gfx_lib_hdmi.h:276: point rotateY_pivot(point *p, point *pivot, int angle) {
 2603 15b4 23261102 		sw	ra,44(sp)	#,
 2604 15b8 23229102 		sw	s1,36(sp)	#,
 2605 15bc 23202103 		sw	s2,32(sp)	#,
 2606              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2607 15c0 83A48500 		lw	s1,8(a1)		# p_32(D)->z, p_32(D)->z
 2608              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2609 15c4 03A90500 		lw	s2,0(a1)		# p_32(D)->x, p_32(D)->x
 2610              	# gfx_lib_hdmi.h:276: point rotateY_pivot(point *p, point *pivot, int angle) {
 2611 15c8 232E3101 		sw	s3,28(sp)	#,
 2612 15cc 232C4101 		sw	s4,24(sp)	#,
 2613              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2614 15d0 83298600 		lw	s3,8(a2)		# _6, pivot_33(D)->z
 2615              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2616 15d4 032A0600 		lw	s4,0(a2)		# _2, pivot_33(D)->x
 2617              	# gfx_lib_hdmi.h:276: point rotateY_pivot(point *p, point *pivot, int angle) {
 2618 15d8 23286101 		sw	s6,16(sp)	#,
 2619 15dc 23248101 		sw	s8,8(sp)	#,
 2620              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2621 15e0 03AB4500 		lw	s6,4(a1)		# _4, p_32(D)->y
 2622              	# gfx_lib_hdmi.h:276: point rotateY_pivot(point *p, point *pivot, int angle) {
 2623 15e4 232A5101 		sw	s5,20(sp)	#,
 2624 15e8 23267101 		sw	s7,12(sp)	#,
 2625 15ec 23229101 		sw	s9,4(sp)	#,
 2626              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2627 15f0 97000000 		call	__floatsidf		#
 2627      E7800000 
 2628 15f8 B7070000 		lui	a5,%hi(.LC1)	# tmp156,
 2629 15fc 03A60700 		lw	a2,%lo(.LC1)(a5)		#,
 2630 1600 83A64700 		lw	a3,%lo(.LC1+4)(a5)		#,
 2631              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2632 1604 33094941 		sub	s2,s2,s4	# _3, p_32(D)->x, _2
 2633              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2634 1608 B3843441 		sub	s1,s1,s3	# _7, p_32(D)->z, _6
 2635              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2636 160c 97000000 		call	__muldf3		#
 2636      E7800000 
 2637 1614 B7070000 		lui	a5,%hi(.LC2)	# tmp158,
 2638 1618 03A60700 		lw	a2,%lo(.LC2)(a5)		#,
 2639 161c 83A64700 		lw	a3,%lo(.LC2+4)(a5)		#,
 2640 1620 97000000 		call	__divdf3		#
 2640      E7800000 
 2641 1628 97000000 		call	__fixdfsi		#
 2641      E7800000 
 2642 1630 13170501 		slli	a4,a0,16	#, angle, tmp263
 2643              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2644 1634 131C0501 		slli	s8,a0,16	#, prephitmp_203, tmp263
 2645              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2646 1638 13570741 		srai	a4,a4,16	#, angle, angle
 2647              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2648 163c 135C0C01 		srli	s8,s8,16	#, prephitmp_203, prephitmp_203
 2649              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2650 1640 635A0700 		bge	a4,zero,.L379	#, angle,,
 2651              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2652 1644 B7870000 		li	a5,32768		# tmp163,
 2653 1648 334CFC00 		xor	s8,s8,a5	# tmp163, prephitmp_203, prephitmp_203
 2654 164c 13170C01 		slli	a4,s8,16	#, angle, prephitmp_203
 2655 1650 13570741 		srai	a4,a4,16	#, angle, angle
 2656              	.L379:
 2657              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 2658 1654 93578740 		srai	a5,a4,8	#, v0, angle
 2659              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2660 1658 13960701 		slli	a2,a5,16	#, v0.41_53, v0
 2661              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2662 165c 93F50702 		andi	a1,a5,32	#, tmp167, v0
 2663              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2664 1660 13560601 		srli	a2,a2,16	#, v0.41_53, v0.41_53
 2665 1664 93060C00 		mv	a3,s8	# _235, prephitmp_203
 2666              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2667 1668 638A0500 		beq	a1,zero,.L380	#, tmp167,,
 2668              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2669 166c 1347F7FF 		not	a4,a4	# tmp171, angle
 2670              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2671 1670 93160701 		slli	a3,a4,16	#, _235, tmp171
 2672              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2673 1674 93C7F7FF 		not	a5,a5	# v0, v0
 2674              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2675 1678 93D60601 		srli	a3,a3,16	#, _235, _235
 2676              	.L380:
 2677              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2678 167c 93F7F701 		andi	a5,a5,31	#, _59, v0
 2679              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2680 1680 13871700 		addi	a4,a5,1	#, tmp179, _59
 2681              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2682 1684 B70B0000 		lui	s7,%hi(.LANCHOR1)	# tmp256,
 2683 1688 938B0B00 		addi	s7,s7,%lo(.LANCHOR1)	# tmp258, tmp256,
 2684 168c 93971700 		slli	a5,a5,1	#, tmp175, _59
 2685              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2686 1690 13171700 		slli	a4,a4,1	#, tmp180, tmp179
 2687              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2688 1694 B387FB00 		add	a5,s7,a5	# tmp175, tmp176, tmp258
 2689              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2690 1698 3387EB00 		add	a4,s7,a4	# tmp180, tmp181, tmp258
 2691              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2692 169c 83950700 		lh	a1,0(a5)		# _60, sin90[_59]
 2693              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2694 16a0 03150700 		lh	a0,0(a4)		# sin90[_62], sin90[_62]
 2695              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2696 16a4 93F6F60F 		andi	a3,a3,0xff	# tmp185, _235
 2697              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2698 16a8 93770604 		andi	a5,a2,64	#, tmp193, v0.41_53
 2699              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2700 16ac 3305B540 		sub	a0,a0,a1	# tmp183, sin90[_62], _60
 2701              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2702 16b0 3305D502 		mul	a0,a0,a3	# tmp186, tmp183, tmp185
 2703              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2704 16b4 13558540 		srai	a0,a0,8	#, tmp187, tmp186
 2705              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2706 16b8 3305B500 		add	a0,a0,a1	# _60, tmp190, tmp187
 2707 16bc 13150501 		slli	a0,a0,16	#, _74, tmp190
 2708 16c0 13550501 		srli	a0,a0,16	#, _74, _74
 2709              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2710 16c4 63880700 		beq	a5,zero,.L381	#, tmp193,,
 2711              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2712 16c8 3305A040 		neg	a0,a0	# tmp195, _74
 2713 16cc 13150501 		slli	a0,a0,16	#, _74, tmp195
 2714 16d0 13550501 		srli	a0,a0,16	#, _74, _74
 2715              	.L381:
 2716              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2717 16d4 13150501 		slli	a0,a0,16	#,, _74
 2718 16d8 13550541 		srai	a0,a0,16	#,,
 2719 16dc 97000000 		call	__floatsidf		#
 2719      E7800000 
 2720 16e4 B70A0000 		lui	s5,%hi(.LC3)	# tmp257,
 2721 16e8 83A64A00 		lw	a3,%lo(.LC3+4)(s5)		#,
 2722 16ec 03A60A00 		lw	a2,%lo(.LC3)(s5)		#,
 2723 16f0 97000000 		call	__muldf3		#
 2723      E7800000 
 2724              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2725 16f8 97000000 		call	__truncdfsf2		#
 2725      E7800000 
 2726              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2727 1700 B7A7FFFF 		li	a5,-24576		# tmp203,
 2728 1704 93871700 		addi	a5,a5,1	#, tmp202, tmp203
 2729 1708 B307FC00 		add	a5,s8,a5	# tmp202, tmp201, prephitmp_203
 2730              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2731 170c 93960701 		slli	a3,a5,16	#, angle, tmp201
 2732              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2733 1710 13970701 		slli	a4,a5,16	#, _42, tmp201
 2734              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2735 1714 93D60641 		srai	a3,a3,16	#, angle, angle
 2736              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2737 1718 930C0500 		mv	s9,a0	# sin_theta, tmp264
 2738              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2739 171c 13570701 		srli	a4,a4,16	#, _42, _42
 2740              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2741 1720 63D00602 		bge	a3,zero,.L382	#, angle,,
 2742              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2743 1724 B7270000 		li	a5,8192		# tmp206,
 2744 1728 93871700 		addi	a5,a5,1	#, tmp205, tmp206
 2745 172c 330CFC00 		add	s8,s8,a5	# tmp205, tmp204, prephitmp_203
 2746 1730 13170C01 		slli	a4,s8,16	#, _42, tmp204
 2747 1734 93160C01 		slli	a3,s8,16	#, angle, tmp204
 2748 1738 13570701 		srli	a4,a4,16	#, _42, _42
 2749 173c 93D60641 		srai	a3,a3,16	#, angle, angle
 2750              	.L382:
 2751              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 2752 1740 93D78640 		srai	a5,a3,8	#, v0, angle
 2753              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2754 1744 13960701 		slli	a2,a5,16	#, v0.41_84, v0
 2755              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2756 1748 93F50702 		andi	a1,a5,32	#, tmp210, v0
 2757              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2758 174c 13560601 		srli	a2,a2,16	#, v0.41_84, v0.41_84
 2759              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2760 1750 638A0500 		beq	a1,zero,.L383	#, tmp210,,
 2761              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2762 1754 93C6F6FF 		not	a3,a3	# tmp214, angle
 2763              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2764 1758 13970601 		slli	a4,a3,16	#, _42, tmp214
 2765              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2766 175c 93C7F7FF 		not	a5,a5	# v0, v0
 2767              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2768 1760 13570701 		srli	a4,a4,16	#, _42, _42
 2769              	.L383:
 2770              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2771 1764 93F7F701 		andi	a5,a5,31	#, _90, v0
 2772              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2773 1768 93861700 		addi	a3,a5,1	#, tmp222, _90
 2774 176c 93961600 		slli	a3,a3,1	#, tmp223, tmp222
 2775              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2776 1770 93971700 		slli	a5,a5,1	#, tmp218, _90
 2777 1774 B387FB00 		add	a5,s7,a5	# tmp218, tmp219, tmp258
 2778              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2779 1778 B38BDB00 		add	s7,s7,a3	# tmp223, tmp224, tmp258
 2780              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2781 177c 83950700 		lh	a1,0(a5)		# _91, sin90[_90]
 2782              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2783 1780 83970B00 		lh	a5,0(s7)		# sin90[_93], sin90[_93]
 2784              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2785 1784 1377F70F 		andi	a4,a4,0xff	# tmp228, _42
 2786              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2787 1788 93760604 		andi	a3,a2,64	#, tmp236, v0.41_84
 2788              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2789 178c B387B740 		sub	a5,a5,a1	# tmp226, sin90[_93], _91
 2790              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2791 1790 B387E702 		mul	a5,a5,a4	# tmp229, tmp226, tmp228
 2792              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2793 1794 93D78740 		srai	a5,a5,8	#, tmp230, tmp229
 2794              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2795 1798 B387B700 		add	a5,a5,a1	# _91, tmp233, tmp230
 2796 179c 93970701 		slli	a5,a5,16	#, _105, tmp233
 2797 17a0 93D70701 		srli	a5,a5,16	#, _105, _105
 2798              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2799 17a4 63880600 		beq	a3,zero,.L384	#, tmp236,,
 2800              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2801 17a8 B307F040 		neg	a5,a5	# tmp238, _105
 2802 17ac 93970701 		slli	a5,a5,16	#, _105, tmp238
 2803 17b0 93D70701 		srli	a5,a5,16	#, _105, _105
 2804              	.L384:
 2805              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 2806 17b4 13950701 		slli	a0,a5,16	#,, _105
 2807 17b8 13550541 		srai	a0,a0,16	#,,
 2808 17bc 97000000 		call	__floatsidf		#
 2808      E7800000 
 2809 17c4 03A60A00 		lw	a2,%lo(.LC3)(s5)		#,
 2810 17c8 83A64A00 		lw	a3,%lo(.LC3+4)(s5)		#,
 2811 17cc 97000000 		call	__muldf3		#
 2811      E7800000 
 2812              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 2813 17d4 97000000 		call	__truncdfsf2		#
 2813      E7800000 
 2814 17dc 930A0500 		mv	s5,a0	# tmp265,
 2815              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2816 17e0 13050900 		mv	a0,s2	#, _3
 2817 17e4 97000000 		call	__floatsisf		#
 2817      E7800000 
 2818 17ec 93070500 		mv	a5,a0	# tmp266,
 2819              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2820 17f0 13850400 		mv	a0,s1	#, _7
 2821              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2822 17f4 93840700 		mv	s1,a5	# _18, tmp266
 2823              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2824 17f8 97000000 		call	__floatsisf		#
 2824      E7800000 
 2825 1800 13090500 		mv	s2,a0	# tmp267,
 2826              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2827 1804 93850A00 		mv	a1,s5	#, tmp243
 2828 1808 13850400 		mv	a0,s1	#, _18
 2829 180c 97000000 		call	__mulsf3		#
 2829      E7800000 
 2830 1814 930B0500 		mv	s7,a0	# tmp244, tmp268
 2831              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2832 1818 93850C00 		mv	a1,s9	#, sin_theta
 2833 181c 13050900 		mv	a0,s2	#, _20
 2834 1820 97000000 		call	__mulsf3		#
 2834      E7800000 
 2835 1828 93050500 		mv	a1,a0	# tmp269,
 2836              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2837 182c 13850B00 		mv	a0,s7	#, tmp244
 2838 1830 97000000 		call	__addsf3		#
 2838      E7800000 
 2839 1838 930B0500 		mv	s7,a0	# tmp246, tmp270
 2840              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2841 183c 13050A00 		mv	a0,s4	#, _2
 2842 1840 97000000 		call	__floatsisf		#
 2842      E7800000 
 2843 1848 93050500 		mv	a1,a0	# tmp271,
 2844 184c 13850B00 		mv	a0,s7	#, tmp246
 2845 1850 97000000 		call	__addsf3		#
 2845      E7800000 
 2846              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2847 1858 97000000 		call	__fixsfsi		#
 2847      E7800000 
 2848              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 2849 1860 93850A00 		mv	a1,s5	#, tmp243
 2850              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2851 1864 2320A400 		sw	a0,0(s0)	# tmp272, <retval>.x
 2852              	# gfx_lib_hdmi.h:288:   return transformed;
 2853 1868 23226401 		sw	s6,4(s0)	# _4, <retval>.y
 2854              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 2855 186c 13050900 		mv	a0,s2	#, _20
 2856 1870 97000000 		call	__mulsf3		#
 2856      E7800000 
 2857 1878 13090500 		mv	s2,a0	# tmp250, tmp273
 2858              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 2859 187c 93850C00 		mv	a1,s9	#, sin_theta
 2860 1880 13850400 		mv	a0,s1	#, _18
 2861 1884 97000000 		call	__mulsf3		#
 2861      E7800000 
 2862 188c 93050500 		mv	a1,a0	# tmp274,
 2863              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 2864 1890 13050900 		mv	a0,s2	#, tmp250
 2865 1894 97000000 		call	__subsf3		#
 2865      E7800000 
 2866 189c 93040500 		mv	s1,a0	# tmp252, tmp275
 2867              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 2868 18a0 13850900 		mv	a0,s3	#, _6
 2869 18a4 97000000 		call	__floatsisf		#
 2869      E7800000 
 2870 18ac 93050500 		mv	a1,a0	# tmp276,
 2871 18b0 13850400 		mv	a0,s1	#, tmp252
 2872 18b4 97000000 		call	__addsf3		#
 2872      E7800000 
 2873              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 2874 18bc 97000000 		call	__fixsfsi		#
 2874      E7800000 
 2875 18c4 2324A400 		sw	a0,8(s0)	# tmp277, <retval>.z
 2876              	# gfx_lib_hdmi.h:289: }
 2877 18c8 8320C102 		lw	ra,44(sp)		#,
 2878 18cc 13050400 		mv	a0,s0	#, .result_ptr
 2879 18d0 03248102 		lw	s0,40(sp)		#,
 2880 18d4 83244102 		lw	s1,36(sp)		#,
 2881 18d8 03290102 		lw	s2,32(sp)		#,
 2882 18dc 8329C101 		lw	s3,28(sp)		#,
 2883 18e0 032A8101 		lw	s4,24(sp)		#,
 2884 18e4 832A4101 		lw	s5,20(sp)		#,
 2885 18e8 032B0101 		lw	s6,16(sp)		#,
 2886 18ec 832BC100 		lw	s7,12(sp)		#,
 2887 18f0 032C8100 		lw	s8,8(sp)		#,
 2888 18f4 832C4100 		lw	s9,4(sp)		#,
 2889 18f8 13010103 		addi	sp,sp,48	#,,
 2890 18fc 67800000 		jr	ra		#
 2892              		.align	2
 2893              		.globl	rotateZ_pivot
 2895              	rotateZ_pivot:
 2896 1900 130101FD 		addi	sp,sp,-48	#,,
 2897 1904 23248102 		sw	s0,40(sp)	#,
 2898 1908 13040500 		mv	s0,a0	# tmp259, .result_ptr
 2899              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2900 190c 13850600 		mv	a0,a3	#, tmp262
 2901              	# gfx_lib_hdmi.h:291: point rotateZ_pivot(point *p, point *pivot, int angle) {
 2902 1910 23261102 		sw	ra,44(sp)	#,
 2903 1914 23229102 		sw	s1,36(sp)	#,
 2904 1918 23202103 		sw	s2,32(sp)	#,
 2905              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2906 191c 83A44500 		lw	s1,4(a1)		# p_32(D)->y, p_32(D)->y
 2907              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2908 1920 03A90500 		lw	s2,0(a1)		# p_32(D)->x, p_32(D)->x
 2909              	# gfx_lib_hdmi.h:291: point rotateZ_pivot(point *p, point *pivot, int angle) {
 2910 1924 232E3101 		sw	s3,28(sp)	#,
 2911 1928 232C4101 		sw	s4,24(sp)	#,
 2912              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2913 192c 83294600 		lw	s3,4(a2)		# _5, pivot_33(D)->y
 2914              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2915 1930 032A0600 		lw	s4,0(a2)		# _2, pivot_33(D)->x
 2916              	# gfx_lib_hdmi.h:291: point rotateZ_pivot(point *p, point *pivot, int angle) {
 2917 1934 23286101 		sw	s6,16(sp)	#,
 2918 1938 23248101 		sw	s8,8(sp)	#,
 2919              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2920 193c 03AB8500 		lw	s6,8(a1)		# _7, p_32(D)->z
 2921              	# gfx_lib_hdmi.h:291: point rotateZ_pivot(point *p, point *pivot, int angle) {
 2922 1940 232A5101 		sw	s5,20(sp)	#,
 2923 1944 23267101 		sw	s7,12(sp)	#,
 2924 1948 23229101 		sw	s9,4(sp)	#,
 2925              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2926 194c 97000000 		call	__floatsidf		#
 2926      E7800000 
 2927 1954 B7070000 		lui	a5,%hi(.LC1)	# tmp156,
 2928 1958 03A60700 		lw	a2,%lo(.LC1)(a5)		#,
 2929 195c 83A64700 		lw	a3,%lo(.LC1+4)(a5)		#,
 2930              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2931 1960 33094941 		sub	s2,s2,s4	# _3, p_32(D)->x, _2
 2932              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2933 1964 B3843441 		sub	s1,s1,s3	# _6, p_32(D)->y, _5
 2934              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2935 1968 97000000 		call	__muldf3		#
 2935      E7800000 
 2936 1970 B7070000 		lui	a5,%hi(.LC2)	# tmp158,
 2937 1974 03A60700 		lw	a2,%lo(.LC2)(a5)		#,
 2938 1978 83A64700 		lw	a3,%lo(.LC2+4)(a5)		#,
 2939 197c 97000000 		call	__divdf3		#
 2939      E7800000 
 2940 1984 97000000 		call	__fixdfsi		#
 2940      E7800000 
 2941 198c 13170501 		slli	a4,a0,16	#, angle, tmp263
 2942              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2943 1990 131C0501 		slli	s8,a0,16	#, prephitmp_203, tmp263
 2944              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2945 1994 13570741 		srai	a4,a4,16	#, angle, angle
 2946              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2947 1998 135C0C01 		srli	s8,s8,16	#, prephitmp_203, prephitmp_203
 2948              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2949 199c 635A0700 		bge	a4,zero,.L398	#, angle,,
 2950              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2951 19a0 B7870000 		li	a5,32768		# tmp163,
 2952 19a4 334CFC00 		xor	s8,s8,a5	# tmp163, prephitmp_203, prephitmp_203
 2953 19a8 13170C01 		slli	a4,s8,16	#, angle, prephitmp_203
 2954 19ac 13570741 		srai	a4,a4,16	#, angle, angle
 2955              	.L398:
 2956              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 2957 19b0 93578740 		srai	a5,a4,8	#, v0, angle
 2958              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2959 19b4 13960701 		slli	a2,a5,16	#, v0.41_53, v0
 2960              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2961 19b8 93F50702 		andi	a1,a5,32	#, tmp167, v0
 2962              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2963 19bc 13560601 		srli	a2,a2,16	#, v0.41_53, v0.41_53
 2964 19c0 93060C00 		mv	a3,s8	# _235, prephitmp_203
 2965              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2966 19c4 638A0500 		beq	a1,zero,.L399	#, tmp167,,
 2967              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2968 19c8 1347F7FF 		not	a4,a4	# tmp171, angle
 2969              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2970 19cc 93160701 		slli	a3,a4,16	#, _235, tmp171
 2971              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2972 19d0 93C7F7FF 		not	a5,a5	# v0, v0
 2973              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2974 19d4 93D60601 		srli	a3,a3,16	#, _235, _235
 2975              	.L399:
 2976              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2977 19d8 93F7F701 		andi	a5,a5,31	#, _59, v0
 2978              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2979 19dc 13871700 		addi	a4,a5,1	#, tmp179, _59
 2980              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2981 19e0 B70B0000 		lui	s7,%hi(.LANCHOR1)	# tmp256,
 2982 19e4 938B0B00 		addi	s7,s7,%lo(.LANCHOR1)	# tmp258, tmp256,
 2983 19e8 93971700 		slli	a5,a5,1	#, tmp175, _59
 2984              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2985 19ec 13171700 		slli	a4,a4,1	#, tmp180, tmp179
 2986              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2987 19f0 B387FB00 		add	a5,s7,a5	# tmp175, tmp176, tmp258
 2988              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2989 19f4 3387EB00 		add	a4,s7,a4	# tmp180, tmp181, tmp258
 2990              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2991 19f8 83950700 		lh	a1,0(a5)		# _60, sin90[_59]
 2992              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2993 19fc 03150700 		lh	a0,0(a4)		# sin90[_62], sin90[_62]
 2994              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2995 1a00 93F6F60F 		andi	a3,a3,0xff	# tmp185, _235
 2996              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2997 1a04 93770604 		andi	a5,a2,64	#, tmp193, v0.41_53
 2998              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2999 1a08 3305B540 		sub	a0,a0,a1	# tmp183, sin90[_62], _60
 3000              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3001 1a0c 3305D502 		mul	a0,a0,a3	# tmp186, tmp183, tmp185
 3002              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3003 1a10 13558540 		srai	a0,a0,8	#, tmp187, tmp186
 3004              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3005 1a14 3305B500 		add	a0,a0,a1	# _60, tmp190, tmp187
 3006 1a18 13150501 		slli	a0,a0,16	#, _74, tmp190
 3007 1a1c 13550501 		srli	a0,a0,16	#, _74, _74
 3008              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 3009 1a20 63880700 		beq	a5,zero,.L400	#, tmp193,,
 3010              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 3011 1a24 3305A040 		neg	a0,a0	# tmp195, _74
 3012 1a28 13150501 		slli	a0,a0,16	#, _74, tmp195
 3013 1a2c 13550501 		srli	a0,a0,16	#, _74, _74
 3014              	.L400:
 3015              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 3016 1a30 13150501 		slli	a0,a0,16	#,, _74
 3017 1a34 13550541 		srai	a0,a0,16	#,,
 3018 1a38 97000000 		call	__floatsidf		#
 3018      E7800000 
 3019 1a40 B70A0000 		lui	s5,%hi(.LC3)	# tmp257,
 3020 1a44 83A64A00 		lw	a3,%lo(.LC3+4)(s5)		#,
 3021 1a48 03A60A00 		lw	a2,%lo(.LC3)(s5)		#,
 3022 1a4c 97000000 		call	__muldf3		#
 3022      E7800000 
 3023              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 3024 1a54 97000000 		call	__truncdfsf2		#
 3024      E7800000 
 3025              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3026 1a5c B7A7FFFF 		li	a5,-24576		# tmp203,
 3027 1a60 93871700 		addi	a5,a5,1	#, tmp202, tmp203
 3028 1a64 B307FC00 		add	a5,s8,a5	# tmp202, tmp201, prephitmp_203
 3029              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3030 1a68 93960701 		slli	a3,a5,16	#, angle, tmp201
 3031              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3032 1a6c 13970701 		slli	a4,a5,16	#, _42, tmp201
 3033              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3034 1a70 93D60641 		srai	a3,a3,16	#, angle, angle
 3035              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 3036 1a74 930C0500 		mv	s9,a0	# sin_theta, tmp264
 3037              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3038 1a78 13570701 		srli	a4,a4,16	#, _42, _42
 3039              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 3040 1a7c 63D00602 		bge	a3,zero,.L401	#, angle,,
 3041              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 3042 1a80 B7270000 		li	a5,8192		# tmp206,
 3043 1a84 93871700 		addi	a5,a5,1	#, tmp205, tmp206
 3044 1a88 330CFC00 		add	s8,s8,a5	# tmp205, tmp204, prephitmp_203
 3045 1a8c 13170C01 		slli	a4,s8,16	#, _42, tmp204
 3046 1a90 93160C01 		slli	a3,s8,16	#, angle, tmp204
 3047 1a94 13570701 		srli	a4,a4,16	#, _42, _42
 3048 1a98 93D60641 		srai	a3,a3,16	#, angle, angle
 3049              	.L401:
 3050              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 3051 1a9c 93D78640 		srai	a5,a3,8	#, v0, angle
 3052              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3053 1aa0 13960701 		slli	a2,a5,16	#, v0.41_84, v0
 3054              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3055 1aa4 93F50702 		andi	a1,a5,32	#, tmp210, v0
 3056              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3057 1aa8 13560601 		srli	a2,a2,16	#, v0.41_84, v0.41_84
 3058              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3059 1aac 638A0500 		beq	a1,zero,.L402	#, tmp210,,
 3060              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3061 1ab0 93C6F6FF 		not	a3,a3	# tmp214, angle
 3062              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3063 1ab4 13970601 		slli	a4,a3,16	#, _42, tmp214
 3064              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3065 1ab8 93C7F7FF 		not	a5,a5	# v0, v0
 3066              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3067 1abc 13570701 		srli	a4,a4,16	#, _42, _42
 3068              	.L402:
 3069              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3070 1ac0 93F7F701 		andi	a5,a5,31	#, _90, v0
 3071              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3072 1ac4 93861700 		addi	a3,a5,1	#, tmp222, _90
 3073 1ac8 93961600 		slli	a3,a3,1	#, tmp223, tmp222
 3074              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3075 1acc 93971700 		slli	a5,a5,1	#, tmp218, _90
 3076 1ad0 B387FB00 		add	a5,s7,a5	# tmp218, tmp219, tmp258
 3077              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3078 1ad4 B38BDB00 		add	s7,s7,a3	# tmp223, tmp224, tmp258
 3079              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3080 1ad8 83950700 		lh	a1,0(a5)		# _91, sin90[_90]
 3081              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3082 1adc 83970B00 		lh	a5,0(s7)		# sin90[_93], sin90[_93]
 3083              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3084 1ae0 1377F70F 		andi	a4,a4,0xff	# tmp228, _42
 3085              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 3086 1ae4 93760604 		andi	a3,a2,64	#, tmp236, v0.41_84
 3087              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3088 1ae8 B387B740 		sub	a5,a5,a1	# tmp226, sin90[_93], _91
 3089              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3090 1aec B387E702 		mul	a5,a5,a4	# tmp229, tmp226, tmp228
 3091              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3092 1af0 93D78740 		srai	a5,a5,8	#, tmp230, tmp229
 3093              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3094 1af4 B387B700 		add	a5,a5,a1	# _91, tmp233, tmp230
 3095 1af8 93970701 		slli	a5,a5,16	#, _105, tmp233
 3096 1afc 93D70701 		srli	a5,a5,16	#, _105, _105
 3097              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 3098 1b00 63880600 		beq	a3,zero,.L403	#, tmp236,,
 3099              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 3100 1b04 B307F040 		neg	a5,a5	# tmp238, _105
 3101 1b08 93970701 		slli	a5,a5,16	#, _105, tmp238
 3102 1b0c 93D70701 		srli	a5,a5,16	#, _105, _105
 3103              	.L403:
 3104              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 3105 1b10 13950701 		slli	a0,a5,16	#,, _105
 3106 1b14 13550541 		srai	a0,a0,16	#,,
 3107 1b18 97000000 		call	__floatsidf		#
 3107      E7800000 
 3108 1b20 03A60A00 		lw	a2,%lo(.LC3)(s5)		#,
 3109 1b24 83A64A00 		lw	a3,%lo(.LC3+4)(s5)		#,
 3110 1b28 97000000 		call	__muldf3		#
 3110      E7800000 
 3111              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 3112 1b30 97000000 		call	__truncdfsf2		#
 3112      E7800000 
 3113 1b38 93070500 		mv	a5,a0	# tmp265,
 3114              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3115 1b3c 13050900 		mv	a0,s2	#, _3
 3116              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 3117 1b40 13890700 		mv	s2,a5	# tmp243, tmp265
 3118              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3119 1b44 97000000 		call	__floatsisf		#
 3119      E7800000 
 3120 1b4c 930A0500 		mv	s5,a0	# tmp266,
 3121              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3122 1b50 13850400 		mv	a0,s1	#, _6
 3123 1b54 97000000 		call	__floatsisf		#
 3123      E7800000 
 3124 1b5c 93040500 		mv	s1,a0	# tmp267,
 3125              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3126 1b60 93050900 		mv	a1,s2	#, tmp243
 3127 1b64 13850A00 		mv	a0,s5	#, _18
 3128 1b68 97000000 		call	__mulsf3		#
 3128      E7800000 
 3129 1b70 930B0500 		mv	s7,a0	# tmp244, tmp268
 3130              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3131 1b74 93850C00 		mv	a1,s9	#, sin_theta
 3132 1b78 13850400 		mv	a0,s1	#, _20
 3133 1b7c 97000000 		call	__mulsf3		#
 3133      E7800000 
 3134 1b84 93050500 		mv	a1,a0	# tmp269,
 3135              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3136 1b88 13850B00 		mv	a0,s7	#, tmp244
 3137 1b8c 97000000 		call	__subsf3		#
 3137      E7800000 
 3138 1b94 930B0500 		mv	s7,a0	# tmp246, tmp270
 3139              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3140 1b98 13050A00 		mv	a0,s4	#, _2
 3141 1b9c 97000000 		call	__floatsisf		#
 3141      E7800000 
 3142 1ba4 93050500 		mv	a1,a0	# tmp271,
 3143 1ba8 13850B00 		mv	a0,s7	#, tmp246
 3144 1bac 97000000 		call	__addsf3		#
 3144      E7800000 
 3145              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3146 1bb4 97000000 		call	__fixsfsi		#
 3146      E7800000 
 3147              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3148 1bbc 93850C00 		mv	a1,s9	#, sin_theta
 3149              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3150 1bc0 2320A400 		sw	a0,0(s0)	# tmp272, <retval>.x
 3151              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3152 1bc4 13850A00 		mv	a0,s5	#, _18
 3153 1bc8 97000000 		call	__mulsf3		#
 3153      E7800000 
 3154 1bd0 130A0500 		mv	s4,a0	# tmp250, tmp273
 3155              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3156 1bd4 93050900 		mv	a1,s2	#, tmp243
 3157 1bd8 13850400 		mv	a0,s1	#, _20
 3158 1bdc 97000000 		call	__mulsf3		#
 3158      E7800000 
 3159 1be4 93050500 		mv	a1,a0	# tmp274,
 3160              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3161 1be8 13050A00 		mv	a0,s4	#, tmp250
 3162 1bec 97000000 		call	__addsf3		#
 3162      E7800000 
 3163 1bf4 93040500 		mv	s1,a0	# tmp252, tmp275
 3164              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3165 1bf8 13850900 		mv	a0,s3	#, _5
 3166 1bfc 97000000 		call	__floatsisf		#
 3166      E7800000 
 3167 1c04 93050500 		mv	a1,a0	# tmp276,
 3168 1c08 13850400 		mv	a0,s1	#, tmp252
 3169 1c0c 97000000 		call	__addsf3		#
 3169      E7800000 
 3170              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3171 1c14 97000000 		call	__fixsfsi		#
 3171      E7800000 
 3172 1c1c 2322A400 		sw	a0,4(s0)	# tmp277, <retval>.y
 3173              	# gfx_lib_hdmi.h:303:   return transformed;
 3174 1c20 23246401 		sw	s6,8(s0)	# _7, <retval>.z
 3175              	# gfx_lib_hdmi.h:304: }
 3176 1c24 8320C102 		lw	ra,44(sp)		#,
 3177 1c28 13050400 		mv	a0,s0	#, .result_ptr
 3178 1c2c 03248102 		lw	s0,40(sp)		#,
 3179 1c30 83244102 		lw	s1,36(sp)		#,
 3180 1c34 03290102 		lw	s2,32(sp)		#,
 3181 1c38 8329C101 		lw	s3,28(sp)		#,
 3182 1c3c 032A8101 		lw	s4,24(sp)		#,
 3183 1c40 832A4101 		lw	s5,20(sp)		#,
 3184 1c44 032B0101 		lw	s6,16(sp)		#,
 3185 1c48 832BC100 		lw	s7,12(sp)		#,
 3186 1c4c 032C8100 		lw	s8,8(sp)		#,
 3187 1c50 832C4100 		lw	s9,4(sp)		#,
 3188 1c54 13010103 		addi	sp,sp,48	#,,
 3189 1c58 67800000 		jr	ra		#
 3191              		.align	2
 3192              		.globl	render_pixels
 3194              	render_pixels:
 3195              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3196 1c5c B7070000 		lui	a5,%hi(.LANCHOR0)	# tmp382,
 3197 1c60 93870700 		addi	a5,a5,%lo(.LANCHOR0)	# tmp383, tmp382,
 3198 1c64 83A60740 		lw	a3,1024(a5)		# _5, pixels[0].x
 3199              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3200 1c68 1307F004 		li	a4,79		# tmp194,
 3201 1c6c 636CD702 		bgtu	a3,a4,.L417	#, _5, tmp194,
 3202              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3203 1c70 03A64740 		lw	a2,1028(a5)		# _17, pixels[0].y
 3204              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3205 1c74 1307B003 		li	a4,59		# tmp197,
 3206 1c78 6366C702 		bgtu	a2,a4,.L417	#, _17, tmp197,
 3207              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3208 1c7c 13172600 		slli	a4,a2,2	#, tmp199, _17
 3209 1c80 3307C700 		add	a4,a4,a2	# _17, tmp200, tmp199
 3210 1c84 13174700 		slli	a4,a4,4	#, tmp201, tmp200
 3211 1c88 3307D700 		add	a4,a4,a3	# _5, tmp202, tmp201
 3212              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3213 1c8c 03960741 		lh	a2,1040(a5)		# pixels[0].color, pixels[0].color
 3214 1c90 B7060000 		lui	a3,%hi(framebuffer)	# tmp206,
 3215 1c94 13172700 		slli	a4,a4,2	#, tmp203, tmp202
 3216 1c98 93860600 		addi	a3,a3,%lo(framebuffer)	# tmp205, tmp206,
 3217 1c9c 3307D700 		add	a4,a4,a3	# tmp205, tmp204, tmp203
 3218 1ca0 2320C700 		sw	a2,0(a4)	# pixels[0].color, *_33
 3219              	.L417:
 3220              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3221 1ca4 83A64741 		lw	a3,1044(a5)		# _43, pixels[1].x
 3222              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3223 1ca8 1307F004 		li	a4,79		# tmp213,
 3224 1cac 636CD702 		bgtu	a3,a4,.L418	#, _43, tmp213,
 3225              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3226 1cb0 03A68741 		lw	a2,1048(a5)		# _45, pixels[1].y
 3227              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3228 1cb4 1307B003 		li	a4,59		# tmp216,
 3229 1cb8 6366C702 		bgtu	a2,a4,.L418	#, _45, tmp216,
 3230              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3231 1cbc 13172600 		slli	a4,a2,2	#, tmp218, _45
 3232 1cc0 3307C700 		add	a4,a4,a2	# _45, tmp219, tmp218
 3233 1cc4 13174700 		slli	a4,a4,4	#, tmp220, tmp219
 3234 1cc8 3307D700 		add	a4,a4,a3	# _43, tmp221, tmp220
 3235              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3236 1ccc 03964742 		lh	a2,1060(a5)		# pixels[1].color, pixels[1].color
 3237 1cd0 B7060000 		lui	a3,%hi(framebuffer)	# tmp225,
 3238 1cd4 13172700 		slli	a4,a4,2	#, tmp222, tmp221
 3239 1cd8 93860600 		addi	a3,a3,%lo(framebuffer)	# tmp224, tmp225,
 3240 1cdc 3307D700 		add	a4,a4,a3	# tmp224, tmp223, tmp222
 3241 1ce0 2320C700 		sw	a2,0(a4)	# pixels[1].color, *_52
 3242              	.L418:
 3243              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3244 1ce4 83A68742 		lw	a3,1064(a5)		# _62, pixels[2].x
 3245              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3246 1ce8 1307F004 		li	a4,79		# tmp232,
 3247 1cec 636CD702 		bgtu	a3,a4,.L419	#, _62, tmp232,
 3248              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3249 1cf0 03A6C742 		lw	a2,1068(a5)		# _64, pixels[2].y
 3250              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3251 1cf4 1307B003 		li	a4,59		# tmp235,
 3252 1cf8 6366C702 		bgtu	a2,a4,.L419	#, _64, tmp235,
 3253              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3254 1cfc 13172600 		slli	a4,a2,2	#, tmp237, _64
 3255 1d00 3307C700 		add	a4,a4,a2	# _64, tmp238, tmp237
 3256 1d04 13174700 		slli	a4,a4,4	#, tmp239, tmp238
 3257 1d08 3307D700 		add	a4,a4,a3	# _62, tmp240, tmp239
 3258              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3259 1d0c 03968743 		lh	a2,1080(a5)		# pixels[2].color, pixels[2].color
 3260 1d10 B7060000 		lui	a3,%hi(framebuffer)	# tmp244,
 3261 1d14 13172700 		slli	a4,a4,2	#, tmp241, tmp240
 3262 1d18 93860600 		addi	a3,a3,%lo(framebuffer)	# tmp243, tmp244,
 3263 1d1c 3307D700 		add	a4,a4,a3	# tmp243, tmp242, tmp241
 3264 1d20 2320C700 		sw	a2,0(a4)	# pixels[2].color, *_71
 3265              	.L419:
 3266              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3267 1d24 83A6C743 		lw	a3,1084(a5)		# _81, pixels[3].x
 3268              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3269 1d28 1307F004 		li	a4,79		# tmp251,
 3270 1d2c 636CD702 		bgtu	a3,a4,.L420	#, _81, tmp251,
 3271              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3272 1d30 03A60744 		lw	a2,1088(a5)		# _83, pixels[3].y
 3273              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3274 1d34 1307B003 		li	a4,59		# tmp254,
 3275 1d38 6366C702 		bgtu	a2,a4,.L420	#, _83, tmp254,
 3276              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3277 1d3c 13172600 		slli	a4,a2,2	#, tmp256, _83
 3278 1d40 3307C700 		add	a4,a4,a2	# _83, tmp257, tmp256
 3279 1d44 13174700 		slli	a4,a4,4	#, tmp258, tmp257
 3280 1d48 3307D700 		add	a4,a4,a3	# _81, tmp259, tmp258
 3281              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3282 1d4c 0396C744 		lh	a2,1100(a5)		# pixels[3].color, pixels[3].color
 3283 1d50 B7060000 		lui	a3,%hi(framebuffer)	# tmp263,
 3284 1d54 13172700 		slli	a4,a4,2	#, tmp260, tmp259
 3285 1d58 93860600 		addi	a3,a3,%lo(framebuffer)	# tmp262, tmp263,
 3286 1d5c 3307D700 		add	a4,a4,a3	# tmp262, tmp261, tmp260
 3287 1d60 2320C700 		sw	a2,0(a4)	# pixels[3].color, *_90
 3288              	.L420:
 3289              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3290 1d64 83A60745 		lw	a3,1104(a5)		# _100, pixels[4].x
 3291              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3292 1d68 1307F004 		li	a4,79		# tmp270,
 3293 1d6c 636CD702 		bgtu	a3,a4,.L421	#, _100, tmp270,
 3294              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3295 1d70 03A64745 		lw	a2,1108(a5)		# _102, pixels[4].y
 3296              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3297 1d74 1307B003 		li	a4,59		# tmp273,
 3298 1d78 6366C702 		bgtu	a2,a4,.L421	#, _102, tmp273,
 3299              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3300 1d7c 13172600 		slli	a4,a2,2	#, tmp275, _102
 3301 1d80 3307C700 		add	a4,a4,a2	# _102, tmp276, tmp275
 3302 1d84 13174700 		slli	a4,a4,4	#, tmp277, tmp276
 3303 1d88 3307D700 		add	a4,a4,a3	# _100, tmp278, tmp277
 3304              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3305 1d8c 03960746 		lh	a2,1120(a5)		# pixels[4].color, pixels[4].color
 3306 1d90 B7060000 		lui	a3,%hi(framebuffer)	# tmp282,
 3307 1d94 13172700 		slli	a4,a4,2	#, tmp279, tmp278
 3308 1d98 93860600 		addi	a3,a3,%lo(framebuffer)	# tmp281, tmp282,
 3309 1d9c 3307D700 		add	a4,a4,a3	# tmp281, tmp280, tmp279
 3310 1da0 2320C700 		sw	a2,0(a4)	# pixels[4].color, *_109
 3311              	.L421:
 3312              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3313 1da4 83A64746 		lw	a3,1124(a5)		# _119, pixels[5].x
 3314              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3315 1da8 1307F004 		li	a4,79		# tmp289,
 3316 1dac 636CD702 		bgtu	a3,a4,.L422	#, _119, tmp289,
 3317              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3318 1db0 03A68746 		lw	a2,1128(a5)		# _121, pixels[5].y
 3319              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3320 1db4 1307B003 		li	a4,59		# tmp292,
 3321 1db8 6366C702 		bgtu	a2,a4,.L422	#, _121, tmp292,
 3322              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3323 1dbc 13172600 		slli	a4,a2,2	#, tmp294, _121
 3324 1dc0 3307C700 		add	a4,a4,a2	# _121, tmp295, tmp294
 3325 1dc4 13174700 		slli	a4,a4,4	#, tmp296, tmp295
 3326 1dc8 3307D700 		add	a4,a4,a3	# _119, tmp297, tmp296
 3327              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3328 1dcc 03964747 		lh	a2,1140(a5)		# pixels[5].color, pixels[5].color
 3329 1dd0 B7060000 		lui	a3,%hi(framebuffer)	# tmp301,
 3330 1dd4 13172700 		slli	a4,a4,2	#, tmp298, tmp297
 3331 1dd8 93860600 		addi	a3,a3,%lo(framebuffer)	# tmp300, tmp301,
 3332 1ddc 3307D700 		add	a4,a4,a3	# tmp300, tmp299, tmp298
 3333 1de0 2320C700 		sw	a2,0(a4)	# pixels[5].color, *_128
 3334              	.L422:
 3335              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3336 1de4 83A68747 		lw	a3,1144(a5)		# _138, pixels[6].x
 3337              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3338 1de8 1307F004 		li	a4,79		# tmp308,
 3339 1dec 636CD702 		bgtu	a3,a4,.L423	#, _138, tmp308,
 3340              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3341 1df0 03A6C747 		lw	a2,1148(a5)		# _140, pixels[6].y
 3342              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3343 1df4 1307B003 		li	a4,59		# tmp311,
 3344 1df8 6366C702 		bgtu	a2,a4,.L423	#, _140, tmp311,
 3345              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3346 1dfc 13172600 		slli	a4,a2,2	#, tmp313, _140
 3347 1e00 3307C700 		add	a4,a4,a2	# _140, tmp314, tmp313
 3348 1e04 13174700 		slli	a4,a4,4	#, tmp315, tmp314
 3349 1e08 3307D700 		add	a4,a4,a3	# _138, tmp316, tmp315
 3350              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3351 1e0c 03968748 		lh	a2,1160(a5)		# pixels[6].color, pixels[6].color
 3352 1e10 B7060000 		lui	a3,%hi(framebuffer)	# tmp320,
 3353 1e14 13172700 		slli	a4,a4,2	#, tmp317, tmp316
 3354 1e18 93860600 		addi	a3,a3,%lo(framebuffer)	# tmp319, tmp320,
 3355 1e1c 3307D700 		add	a4,a4,a3	# tmp319, tmp318, tmp317
 3356 1e20 2320C700 		sw	a2,0(a4)	# pixels[6].color, *_147
 3357              	.L423:
 3358              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3359 1e24 83A6C748 		lw	a3,1164(a5)		# _157, pixels[7].x
 3360              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3361 1e28 1307F004 		li	a4,79		# tmp327,
 3362 1e2c 636CD702 		bgtu	a3,a4,.L424	#, _157, tmp327,
 3363              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3364 1e30 03A60749 		lw	a2,1168(a5)		# _159, pixels[7].y
 3365              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3366 1e34 1307B003 		li	a4,59		# tmp330,
 3367 1e38 6366C702 		bgtu	a2,a4,.L424	#, _159, tmp330,
 3368              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3369 1e3c 13172600 		slli	a4,a2,2	#, tmp332, _159
 3370 1e40 3307C700 		add	a4,a4,a2	# _159, tmp333, tmp332
 3371 1e44 13174700 		slli	a4,a4,4	#, tmp334, tmp333
 3372 1e48 3307D700 		add	a4,a4,a3	# _157, tmp335, tmp334
 3373              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3374 1e4c 0396C749 		lh	a2,1180(a5)		# pixels[7].color, pixels[7].color
 3375 1e50 B7060000 		lui	a3,%hi(framebuffer)	# tmp339,
 3376 1e54 13172700 		slli	a4,a4,2	#, tmp336, tmp335
 3377 1e58 93860600 		addi	a3,a3,%lo(framebuffer)	# tmp338, tmp339,
 3378 1e5c 3307D700 		add	a4,a4,a3	# tmp338, tmp337, tmp336
 3379 1e60 2320C700 		sw	a2,0(a4)	# pixels[7].color, *_166
 3380              	.L424:
 3381              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3382 1e64 83A6074A 		lw	a3,1184(a5)		# _176, pixels[8].x
 3383              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3384 1e68 1307F004 		li	a4,79		# tmp346,
 3385 1e6c 636CD702 		bgtu	a3,a4,.L425	#, _176, tmp346,
 3386              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3387 1e70 03A6474A 		lw	a2,1188(a5)		# _178, pixels[8].y
 3388              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3389 1e74 1307B003 		li	a4,59		# tmp349,
 3390 1e78 6366C702 		bgtu	a2,a4,.L425	#, _178, tmp349,
 3391              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3392 1e7c 13172600 		slli	a4,a2,2	#, tmp351, _178
 3393 1e80 3307C700 		add	a4,a4,a2	# _178, tmp352, tmp351
 3394 1e84 13174700 		slli	a4,a4,4	#, tmp353, tmp352
 3395 1e88 3307D700 		add	a4,a4,a3	# _176, tmp354, tmp353
 3396              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3397 1e8c 0396074B 		lh	a2,1200(a5)		# pixels[8].color, pixels[8].color
 3398 1e90 B7060000 		lui	a3,%hi(framebuffer)	# tmp358,
 3399 1e94 13172700 		slli	a4,a4,2	#, tmp355, tmp354
 3400 1e98 93860600 		addi	a3,a3,%lo(framebuffer)	# tmp357, tmp358,
 3401 1e9c 3307D700 		add	a4,a4,a3	# tmp357, tmp356, tmp355
 3402 1ea0 2320C700 		sw	a2,0(a4)	# pixels[8].color, *_185
 3403              	.L425:
 3404              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3405 1ea4 83A6474B 		lw	a3,1204(a5)		# _1, pixels[9].x
 3406              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3407 1ea8 1307F004 		li	a4,79		# tmp365,
 3408 1eac 636CD702 		bgtu	a3,a4,.L416	#, _1, tmp365,
 3409              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3410 1eb0 03A6874B 		lw	a2,1208(a5)		# _2, pixels[9].y
 3411              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3412 1eb4 1307B003 		li	a4,59		# tmp368,
 3413 1eb8 6366C702 		bgtu	a2,a4,.L416	#, _2, tmp368,
 3414              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3415 1ebc 13172600 		slli	a4,a2,2	#, tmp370, _2
 3416 1ec0 3307C700 		add	a4,a4,a2	# _2, tmp371, tmp370
 3417 1ec4 13174700 		slli	a4,a4,4	#, tmp372, tmp371
 3418              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3419 1ec8 0396474C 		lh	a2,1220(a5)		# pixels[9].color, pixels[9].color
 3420              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3421 1ecc B307D700 		add	a5,a4,a3	# _1, tmp373, tmp372
 3422              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3423 1ed0 37070000 		lui	a4,%hi(framebuffer)	# tmp377,
 3424 1ed4 93972700 		slli	a5,a5,2	#, tmp374, tmp373
 3425 1ed8 13070700 		addi	a4,a4,%lo(framebuffer)	# tmp376, tmp377,
 3426 1edc B387E700 		add	a5,a5,a4	# tmp376, tmp375, tmp374
 3427 1ee0 23A0C700 		sw	a2,0(a5)	# pixels[9].color, *_15
 3428              	.L416:
 3429              	# main_balls_hdmi.c:28: }
 3430 1ee4 67800000 		ret	
 3432              		.align	2
 3433              		.globl	move_pixels
 3435              	move_pixels:
 3436              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3437 1ee8 B7070000 		lui	a5,%hi(.LANCHOR0)	# tmp493,
 3438 1eec 93870700 		addi	a5,a5,%lo(.LANCHOR0)	# tmp492, tmp493,
 3439 1ef0 03A50740 		lw	a0,1024(a5)		# _31, MEM <struct pixel[10]> [(int *)&pixels][0].x
 3440              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3441 1ef4 1307E004 		li	a4,78		# tmp194,
 3442 1ef8 6378A700 		bleu	a0,a4,.L428	#, _31, tmp194,
 3443              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3444 1efc 03A78740 		lw	a4,1032(a5)		# MEM <struct pixel[10]> [(int *)&pixels][0].xdelta, MEM <struct pixel[10]> [(int 
 3445 1f00 3307E040 		neg	a4,a4	# tmp199, MEM <struct pixel[10]> [(int *)&pixels][0].xdelta
 3446 1f04 23A4E740 		sw	a4,1032(a5)	# tmp199, MEM <struct pixel[10]> [(int *)&pixels][0].xdelta
 3447              	.L428:
 3448              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3449 1f08 03A64740 		lw	a2,1028(a5)		# _52, MEM <struct pixel[10]> [(int *)&pixels][0].y
 3450              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3451 1f0c 1307A003 		li	a4,58		# tmp203,
 3452 1f10 6378C700 		bleu	a2,a4,.L429	#, _52, tmp203,
 3453              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3454 1f14 03A7C740 		lw	a4,1036(a5)		# MEM <struct pixel[10]> [(int *)&pixels][0].ydelta, MEM <struct pixel[10]> [(int 
 3455 1f18 3307E040 		neg	a4,a4	# tmp208, MEM <struct pixel[10]> [(int *)&pixels][0].ydelta
 3456 1f1c 23A6E740 		sw	a4,1036(a5)	# tmp208, MEM <struct pixel[10]> [(int *)&pixels][0].ydelta
 3457              	.L429:
 3458              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3459 1f20 83A68740 		lw	a3,1032(a5)		# MEM <struct pixel[10]> [(int *)&pixels][0].xdelta, MEM <struct pixel[10]> [(int 
 3460              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3461 1f24 03A7C740 		lw	a4,1036(a5)		# MEM <struct pixel[10]> [(int *)&pixels][0].ydelta, MEM <struct pixel[10]> [(int 
 3462              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3463 1f28 83A54741 		lw	a1,1044(a5)		# _54, MEM <struct pixel[10]> [(int *)&pixels][1].x
 3464              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3465 1f2c B386A600 		add	a3,a3,a0	# _31, tmp214, MEM <struct pixel[10]> [(int *)&pixels][0].xdelta
 3466              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3467 1f30 3307C700 		add	a4,a4,a2	# _52, tmp220, MEM <struct pixel[10]> [(int *)&pixels][0].ydelta
 3468 1f34 23A2E740 		sw	a4,1028(a5)	# tmp220, MEM <struct pixel[10]> [(int *)&pixels][0].y
 3469              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3470 1f38 23A0D740 		sw	a3,1024(a5)	# tmp214, MEM <struct pixel[10]> [(int *)&pixels][0].x
 3471              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3472 1f3c 1307E004 		li	a4,78		# tmp224,
 3473 1f40 6378B700 		bleu	a1,a4,.L430	#, _54, tmp224,
 3474              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3475 1f44 03A7C741 		lw	a4,1052(a5)		# MEM <struct pixel[10]> [(int *)&pixels][1].xdelta, MEM <struct pixel[10]> [(int 
 3476 1f48 3307E040 		neg	a4,a4	# tmp229, MEM <struct pixel[10]> [(int *)&pixels][1].xdelta
 3477 1f4c 23AEE740 		sw	a4,1052(a5)	# tmp229, MEM <struct pixel[10]> [(int *)&pixels][1].xdelta
 3478              	.L430:
 3479              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3480 1f50 03A68741 		lw	a2,1048(a5)		# _57, MEM <struct pixel[10]> [(int *)&pixels][1].y
 3481              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3482 1f54 1307A003 		li	a4,58		# tmp233,
 3483 1f58 6378C700 		bleu	a2,a4,.L431	#, _57, tmp233,
 3484              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3485 1f5c 03A70742 		lw	a4,1056(a5)		# MEM <struct pixel[10]> [(int *)&pixels][1].ydelta, MEM <struct pixel[10]> [(int 
 3486 1f60 3307E040 		neg	a4,a4	# tmp238, MEM <struct pixel[10]> [(int *)&pixels][1].ydelta
 3487 1f64 23A0E742 		sw	a4,1056(a5)	# tmp238, MEM <struct pixel[10]> [(int *)&pixels][1].ydelta
 3488              	.L431:
 3489              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3490 1f68 83A6C741 		lw	a3,1052(a5)		# MEM <struct pixel[10]> [(int *)&pixels][1].xdelta, MEM <struct pixel[10]> [(int 
 3491              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3492 1f6c 03A70742 		lw	a4,1056(a5)		# MEM <struct pixel[10]> [(int *)&pixels][1].ydelta, MEM <struct pixel[10]> [(int 
 3493              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3494 1f70 03A58742 		lw	a0,1064(a5)		# _74, MEM <struct pixel[10]> [(int *)&pixels][2].x
 3495              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3496 1f74 B386B600 		add	a3,a3,a1	# _54, tmp244, MEM <struct pixel[10]> [(int *)&pixels][1].xdelta
 3497              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3498 1f78 3307C700 		add	a4,a4,a2	# _57, tmp250, MEM <struct pixel[10]> [(int *)&pixels][1].ydelta
 3499 1f7c 23ACE740 		sw	a4,1048(a5)	# tmp250, MEM <struct pixel[10]> [(int *)&pixels][1].y
 3500              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3501 1f80 23AAD740 		sw	a3,1044(a5)	# tmp244, MEM <struct pixel[10]> [(int *)&pixels][1].x
 3502              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3503 1f84 1307E004 		li	a4,78		# tmp254,
 3504 1f88 6378A700 		bleu	a0,a4,.L432	#, _74, tmp254,
 3505              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3506 1f8c 03A70743 		lw	a4,1072(a5)		# MEM <struct pixel[10]> [(int *)&pixels][2].xdelta, MEM <struct pixel[10]> [(int 
 3507 1f90 3307E040 		neg	a4,a4	# tmp259, MEM <struct pixel[10]> [(int *)&pixels][2].xdelta
 3508 1f94 23A8E742 		sw	a4,1072(a5)	# tmp259, MEM <struct pixel[10]> [(int *)&pixels][2].xdelta
 3509              	.L432:
 3510              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3511 1f98 03A6C742 		lw	a2,1068(a5)		# _80, MEM <struct pixel[10]> [(int *)&pixels][2].y
 3512              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3513 1f9c 1307A003 		li	a4,58		# tmp263,
 3514 1fa0 6378C700 		bleu	a2,a4,.L433	#, _80, tmp263,
 3515              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3516 1fa4 03A74743 		lw	a4,1076(a5)		# MEM <struct pixel[10]> [(int *)&pixels][2].ydelta, MEM <struct pixel[10]> [(int 
 3517 1fa8 3307E040 		neg	a4,a4	# tmp268, MEM <struct pixel[10]> [(int *)&pixels][2].ydelta
 3518 1fac 23AAE742 		sw	a4,1076(a5)	# tmp268, MEM <struct pixel[10]> [(int *)&pixels][2].ydelta
 3519              	.L433:
 3520              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3521 1fb0 83A60743 		lw	a3,1072(a5)		# MEM <struct pixel[10]> [(int *)&pixels][2].xdelta, MEM <struct pixel[10]> [(int 
 3522              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3523 1fb4 03A74743 		lw	a4,1076(a5)		# MEM <struct pixel[10]> [(int *)&pixels][2].ydelta, MEM <struct pixel[10]> [(int 
 3524              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3525 1fb8 83A5C743 		lw	a1,1084(a5)		# _97, MEM <struct pixel[10]> [(int *)&pixels][3].x
 3526              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3527 1fbc B386A600 		add	a3,a3,a0	# _74, tmp274, MEM <struct pixel[10]> [(int *)&pixels][2].xdelta
 3528              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3529 1fc0 3307C700 		add	a4,a4,a2	# _80, tmp280, MEM <struct pixel[10]> [(int *)&pixels][2].ydelta
 3530 1fc4 23A6E742 		sw	a4,1068(a5)	# tmp280, MEM <struct pixel[10]> [(int *)&pixels][2].y
 3531              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3532 1fc8 23A4D742 		sw	a3,1064(a5)	# tmp274, MEM <struct pixel[10]> [(int *)&pixels][2].x
 3533              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3534 1fcc 1307E004 		li	a4,78		# tmp284,
 3535 1fd0 6378B700 		bleu	a1,a4,.L434	#, _97, tmp284,
 3536              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3537 1fd4 03A74744 		lw	a4,1092(a5)		# MEM <struct pixel[10]> [(int *)&pixels][3].xdelta, MEM <struct pixel[10]> [(int 
 3538 1fd8 3307E040 		neg	a4,a4	# tmp289, MEM <struct pixel[10]> [(int *)&pixels][3].xdelta
 3539 1fdc 23A2E744 		sw	a4,1092(a5)	# tmp289, MEM <struct pixel[10]> [(int *)&pixels][3].xdelta
 3540              	.L434:
 3541              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3542 1fe0 03A60744 		lw	a2,1088(a5)		# _103, MEM <struct pixel[10]> [(int *)&pixels][3].y
 3543              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3544 1fe4 1307A003 		li	a4,58		# tmp293,
 3545 1fe8 6378C700 		bleu	a2,a4,.L435	#, _103, tmp293,
 3546              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3547 1fec 03A78744 		lw	a4,1096(a5)		# MEM <struct pixel[10]> [(int *)&pixels][3].ydelta, MEM <struct pixel[10]> [(int 
 3548 1ff0 3307E040 		neg	a4,a4	# tmp298, MEM <struct pixel[10]> [(int *)&pixels][3].ydelta
 3549 1ff4 23A4E744 		sw	a4,1096(a5)	# tmp298, MEM <struct pixel[10]> [(int *)&pixels][3].ydelta
 3550              	.L435:
 3551              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3552 1ff8 83A64744 		lw	a3,1092(a5)		# MEM <struct pixel[10]> [(int *)&pixels][3].xdelta, MEM <struct pixel[10]> [(int 
 3553              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3554 1ffc 03A78744 		lw	a4,1096(a5)		# MEM <struct pixel[10]> [(int *)&pixels][3].ydelta, MEM <struct pixel[10]> [(int 
 3555              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3556 2000 03A50745 		lw	a0,1104(a5)		# _120, MEM <struct pixel[10]> [(int *)&pixels][4].x
 3557              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3558 2004 B386B600 		add	a3,a3,a1	# _97, tmp304, MEM <struct pixel[10]> [(int *)&pixels][3].xdelta
 3559              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3560 2008 3307C700 		add	a4,a4,a2	# _103, tmp310, MEM <struct pixel[10]> [(int *)&pixels][3].ydelta
 3561 200c 23A0E744 		sw	a4,1088(a5)	# tmp310, MEM <struct pixel[10]> [(int *)&pixels][3].y
 3562              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3563 2010 23AED742 		sw	a3,1084(a5)	# tmp304, MEM <struct pixel[10]> [(int *)&pixels][3].x
 3564              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3565 2014 1307E004 		li	a4,78		# tmp314,
 3566 2018 6378A700 		bleu	a0,a4,.L436	#, _120, tmp314,
 3567              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3568 201c 03A78745 		lw	a4,1112(a5)		# MEM <struct pixel[10]> [(int *)&pixels][4].xdelta, MEM <struct pixel[10]> [(int 
 3569 2020 3307E040 		neg	a4,a4	# tmp319, MEM <struct pixel[10]> [(int *)&pixels][4].xdelta
 3570 2024 23ACE744 		sw	a4,1112(a5)	# tmp319, MEM <struct pixel[10]> [(int *)&pixels][4].xdelta
 3571              	.L436:
 3572              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3573 2028 03A64745 		lw	a2,1108(a5)		# _126, MEM <struct pixel[10]> [(int *)&pixels][4].y
 3574              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3575 202c 1307A003 		li	a4,58		# tmp323,
 3576 2030 6378C700 		bleu	a2,a4,.L437	#, _126, tmp323,
 3577              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3578 2034 03A7C745 		lw	a4,1116(a5)		# MEM <struct pixel[10]> [(int *)&pixels][4].ydelta, MEM <struct pixel[10]> [(int 
 3579 2038 3307E040 		neg	a4,a4	# tmp328, MEM <struct pixel[10]> [(int *)&pixels][4].ydelta
 3580 203c 23AEE744 		sw	a4,1116(a5)	# tmp328, MEM <struct pixel[10]> [(int *)&pixels][4].ydelta
 3581              	.L437:
 3582              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3583 2040 83A68745 		lw	a3,1112(a5)		# MEM <struct pixel[10]> [(int *)&pixels][4].xdelta, MEM <struct pixel[10]> [(int 
 3584              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3585 2044 03A7C745 		lw	a4,1116(a5)		# MEM <struct pixel[10]> [(int *)&pixels][4].ydelta, MEM <struct pixel[10]> [(int 
 3586              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3587 2048 83A54746 		lw	a1,1124(a5)		# _143, MEM <struct pixel[10]> [(int *)&pixels][5].x
 3588              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3589 204c B386A600 		add	a3,a3,a0	# _120, tmp334, MEM <struct pixel[10]> [(int *)&pixels][4].xdelta
 3590              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3591 2050 3307C700 		add	a4,a4,a2	# _126, tmp340, MEM <struct pixel[10]> [(int *)&pixels][4].ydelta
 3592 2054 23AAE744 		sw	a4,1108(a5)	# tmp340, MEM <struct pixel[10]> [(int *)&pixels][4].y
 3593              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3594 2058 23A8D744 		sw	a3,1104(a5)	# tmp334, MEM <struct pixel[10]> [(int *)&pixels][4].x
 3595              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3596 205c 1307E004 		li	a4,78		# tmp344,
 3597 2060 6378B700 		bleu	a1,a4,.L438	#, _143, tmp344,
 3598              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3599 2064 03A7C746 		lw	a4,1132(a5)		# MEM <struct pixel[10]> [(int *)&pixels][5].xdelta, MEM <struct pixel[10]> [(int 
 3600 2068 3307E040 		neg	a4,a4	# tmp349, MEM <struct pixel[10]> [(int *)&pixels][5].xdelta
 3601 206c 23A6E746 		sw	a4,1132(a5)	# tmp349, MEM <struct pixel[10]> [(int *)&pixels][5].xdelta
 3602              	.L438:
 3603              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3604 2070 03A68746 		lw	a2,1128(a5)		# _149, MEM <struct pixel[10]> [(int *)&pixels][5].y
 3605              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3606 2074 1307A003 		li	a4,58		# tmp353,
 3607 2078 6378C700 		bleu	a2,a4,.L439	#, _149, tmp353,
 3608              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3609 207c 03A70747 		lw	a4,1136(a5)		# MEM <struct pixel[10]> [(int *)&pixels][5].ydelta, MEM <struct pixel[10]> [(int 
 3610 2080 3307E040 		neg	a4,a4	# tmp358, MEM <struct pixel[10]> [(int *)&pixels][5].ydelta
 3611 2084 23A8E746 		sw	a4,1136(a5)	# tmp358, MEM <struct pixel[10]> [(int *)&pixels][5].ydelta
 3612              	.L439:
 3613              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3614 2088 83A6C746 		lw	a3,1132(a5)		# MEM <struct pixel[10]> [(int *)&pixels][5].xdelta, MEM <struct pixel[10]> [(int 
 3615              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3616 208c 03A70747 		lw	a4,1136(a5)		# MEM <struct pixel[10]> [(int *)&pixels][5].ydelta, MEM <struct pixel[10]> [(int 
 3617              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3618 2090 03A58747 		lw	a0,1144(a5)		# _166, MEM <struct pixel[10]> [(int *)&pixels][6].x
 3619              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3620 2094 B386B600 		add	a3,a3,a1	# _143, tmp364, MEM <struct pixel[10]> [(int *)&pixels][5].xdelta
 3621              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3622 2098 3307C700 		add	a4,a4,a2	# _149, tmp370, MEM <struct pixel[10]> [(int *)&pixels][5].ydelta
 3623 209c 23A4E746 		sw	a4,1128(a5)	# tmp370, MEM <struct pixel[10]> [(int *)&pixels][5].y
 3624              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3625 20a0 23A2D746 		sw	a3,1124(a5)	# tmp364, MEM <struct pixel[10]> [(int *)&pixels][5].x
 3626              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3627 20a4 1307E004 		li	a4,78		# tmp374,
 3628 20a8 6378A700 		bleu	a0,a4,.L440	#, _166, tmp374,
 3629              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3630 20ac 03A70748 		lw	a4,1152(a5)		# MEM <struct pixel[10]> [(int *)&pixels][6].xdelta, MEM <struct pixel[10]> [(int 
 3631 20b0 3307E040 		neg	a4,a4	# tmp379, MEM <struct pixel[10]> [(int *)&pixels][6].xdelta
 3632 20b4 23A0E748 		sw	a4,1152(a5)	# tmp379, MEM <struct pixel[10]> [(int *)&pixels][6].xdelta
 3633              	.L440:
 3634              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3635 20b8 03A6C747 		lw	a2,1148(a5)		# _172, MEM <struct pixel[10]> [(int *)&pixels][6].y
 3636              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3637 20bc 1307A003 		li	a4,58		# tmp383,
 3638 20c0 6378C700 		bleu	a2,a4,.L441	#, _172, tmp383,
 3639              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3640 20c4 03A74748 		lw	a4,1156(a5)		# MEM <struct pixel[10]> [(int *)&pixels][6].ydelta, MEM <struct pixel[10]> [(int 
 3641 20c8 3307E040 		neg	a4,a4	# tmp388, MEM <struct pixel[10]> [(int *)&pixels][6].ydelta
 3642 20cc 23A2E748 		sw	a4,1156(a5)	# tmp388, MEM <struct pixel[10]> [(int *)&pixels][6].ydelta
 3643              	.L441:
 3644              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3645 20d0 83A60748 		lw	a3,1152(a5)		# MEM <struct pixel[10]> [(int *)&pixels][6].xdelta, MEM <struct pixel[10]> [(int 
 3646              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3647 20d4 03A74748 		lw	a4,1156(a5)		# MEM <struct pixel[10]> [(int *)&pixels][6].ydelta, MEM <struct pixel[10]> [(int 
 3648              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3649 20d8 83A5C748 		lw	a1,1164(a5)		# _189, MEM <struct pixel[10]> [(int *)&pixels][7].x
 3650              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3651 20dc B386A600 		add	a3,a3,a0	# _166, tmp394, MEM <struct pixel[10]> [(int *)&pixels][6].xdelta
 3652              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3653 20e0 3307C700 		add	a4,a4,a2	# _172, tmp400, MEM <struct pixel[10]> [(int *)&pixels][6].ydelta
 3654 20e4 23AEE746 		sw	a4,1148(a5)	# tmp400, MEM <struct pixel[10]> [(int *)&pixels][6].y
 3655              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3656 20e8 23ACD746 		sw	a3,1144(a5)	# tmp394, MEM <struct pixel[10]> [(int *)&pixels][6].x
 3657              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3658 20ec 1307E004 		li	a4,78		# tmp404,
 3659 20f0 6378B700 		bleu	a1,a4,.L442	#, _189, tmp404,
 3660              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3661 20f4 03A74749 		lw	a4,1172(a5)		# MEM <struct pixel[10]> [(int *)&pixels][7].xdelta, MEM <struct pixel[10]> [(int 
 3662 20f8 3307E040 		neg	a4,a4	# tmp409, MEM <struct pixel[10]> [(int *)&pixels][7].xdelta
 3663 20fc 23AAE748 		sw	a4,1172(a5)	# tmp409, MEM <struct pixel[10]> [(int *)&pixels][7].xdelta
 3664              	.L442:
 3665              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3666 2100 03A60749 		lw	a2,1168(a5)		# _195, MEM <struct pixel[10]> [(int *)&pixels][7].y
 3667              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3668 2104 1307A003 		li	a4,58		# tmp413,
 3669 2108 6378C700 		bleu	a2,a4,.L443	#, _195, tmp413,
 3670              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3671 210c 03A78749 		lw	a4,1176(a5)		# MEM <struct pixel[10]> [(int *)&pixels][7].ydelta, MEM <struct pixel[10]> [(int 
 3672 2110 3307E040 		neg	a4,a4	# tmp418, MEM <struct pixel[10]> [(int *)&pixels][7].ydelta
 3673 2114 23ACE748 		sw	a4,1176(a5)	# tmp418, MEM <struct pixel[10]> [(int *)&pixels][7].ydelta
 3674              	.L443:
 3675              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3676 2118 83A64749 		lw	a3,1172(a5)		# MEM <struct pixel[10]> [(int *)&pixels][7].xdelta, MEM <struct pixel[10]> [(int 
 3677              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3678 211c 03A78749 		lw	a4,1176(a5)		# MEM <struct pixel[10]> [(int *)&pixels][7].ydelta, MEM <struct pixel[10]> [(int 
 3679              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3680 2120 03A5074A 		lw	a0,1184(a5)		# _212, MEM <struct pixel[10]> [(int *)&pixels][8].x
 3681              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3682 2124 B386B600 		add	a3,a3,a1	# _189, tmp424, MEM <struct pixel[10]> [(int *)&pixels][7].xdelta
 3683              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3684 2128 3307C700 		add	a4,a4,a2	# _195, tmp430, MEM <struct pixel[10]> [(int *)&pixels][7].ydelta
 3685 212c 23A8E748 		sw	a4,1168(a5)	# tmp430, MEM <struct pixel[10]> [(int *)&pixels][7].y
 3686              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3687 2130 23A6D748 		sw	a3,1164(a5)	# tmp424, MEM <struct pixel[10]> [(int *)&pixels][7].x
 3688              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3689 2134 1307E004 		li	a4,78		# tmp434,
 3690 2138 6378A700 		bleu	a0,a4,.L444	#, _212, tmp434,
 3691              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3692 213c 03A7874A 		lw	a4,1192(a5)		# MEM <struct pixel[10]> [(int *)&pixels][8].xdelta, MEM <struct pixel[10]> [(int 
 3693 2140 3307E040 		neg	a4,a4	# tmp439, MEM <struct pixel[10]> [(int *)&pixels][8].xdelta
 3694 2144 23A4E74A 		sw	a4,1192(a5)	# tmp439, MEM <struct pixel[10]> [(int *)&pixels][8].xdelta
 3695              	.L444:
 3696              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3697 2148 03A6474A 		lw	a2,1188(a5)		# _218, MEM <struct pixel[10]> [(int *)&pixels][8].y
 3698              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3699 214c 1307A003 		li	a4,58		# tmp443,
 3700 2150 6378C700 		bleu	a2,a4,.L445	#, _218, tmp443,
 3701              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3702 2154 03A7C74A 		lw	a4,1196(a5)		# MEM <struct pixel[10]> [(int *)&pixels][8].ydelta, MEM <struct pixel[10]> [(int 
 3703 2158 3307E040 		neg	a4,a4	# tmp448, MEM <struct pixel[10]> [(int *)&pixels][8].ydelta
 3704 215c 23A6E74A 		sw	a4,1196(a5)	# tmp448, MEM <struct pixel[10]> [(int *)&pixels][8].ydelta
 3705              	.L445:
 3706              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3707 2160 83A6874A 		lw	a3,1192(a5)		# MEM <struct pixel[10]> [(int *)&pixels][8].xdelta, MEM <struct pixel[10]> [(int 
 3708              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3709 2164 03A7C74A 		lw	a4,1196(a5)		# MEM <struct pixel[10]> [(int *)&pixels][8].ydelta, MEM <struct pixel[10]> [(int 
 3710              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3711 2168 83A5474B 		lw	a1,1204(a5)		# _23, MEM <struct pixel[10]> [(int *)&pixels][9].x
 3712              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3713 216c B386A600 		add	a3,a3,a0	# _212, tmp454, MEM <struct pixel[10]> [(int *)&pixels][8].xdelta
 3714              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3715 2170 3307C700 		add	a4,a4,a2	# _218, tmp460, MEM <struct pixel[10]> [(int *)&pixels][8].ydelta
 3716 2174 23A2E74A 		sw	a4,1188(a5)	# tmp460, MEM <struct pixel[10]> [(int *)&pixels][8].y
 3717              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3718 2178 23A0D74A 		sw	a3,1184(a5)	# tmp454, MEM <struct pixel[10]> [(int *)&pixels][8].x
 3719              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3720 217c 1307E004 		li	a4,78		# tmp464,
 3721 2180 6378B700 		bleu	a1,a4,.L446	#, _23, tmp464,
 3722              	# main_balls_hdmi.c:47:         if (*x >= (HRES-1) || *x < 0) *xdelta *= -1;
 3723 2184 03A7C74B 		lw	a4,1212(a5)		# MEM <struct pixel[10]> [(int *)&pixels][9].xdelta, MEM <struct pixel[10]> [(int 
 3724 2188 3307E040 		neg	a4,a4	# tmp469, MEM <struct pixel[10]> [(int *)&pixels][9].xdelta
 3725 218c 23AEE74A 		sw	a4,1212(a5)	# tmp469, MEM <struct pixel[10]> [(int *)&pixels][9].xdelta
 3726              	.L446:
 3727              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3728 2190 03A6874B 		lw	a2,1208(a5)		# _35, MEM <struct pixel[10]> [(int *)&pixels][9].y
 3729              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3730 2194 1307A003 		li	a4,58		# tmp473,
 3731 2198 6378C700 		bleu	a2,a4,.L447	#, _35, tmp473,
 3732              	# main_balls_hdmi.c:48:         if (*y >= (VRES-1) || *y < 0) *ydelta *= -1;
 3733 219c 03A7074C 		lw	a4,1216(a5)		# MEM <struct pixel[10]> [(int *)&pixels][9].ydelta, MEM <struct pixel[10]> [(int 
 3734 21a0 3307E040 		neg	a4,a4	# tmp478, MEM <struct pixel[10]> [(int *)&pixels][9].ydelta
 3735 21a4 23A0E74C 		sw	a4,1216(a5)	# tmp478, MEM <struct pixel[10]> [(int *)&pixels][9].ydelta
 3736              	.L447:
 3737              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3738 21a8 83A6C74B 		lw	a3,1212(a5)		# MEM <struct pixel[10]> [(int *)&pixels][9].xdelta, MEM <struct pixel[10]> [(int 
 3739              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3740 21ac 03A7074C 		lw	a4,1216(a5)		# MEM <struct pixel[10]> [(int *)&pixels][9].ydelta, MEM <struct pixel[10]> [(int 
 3741              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3742 21b0 B386B600 		add	a3,a3,a1	# _23, tmp484, MEM <struct pixel[10]> [(int *)&pixels][9].xdelta
 3743              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3744 21b4 3307C700 		add	a4,a4,a2	# _35, tmp490, MEM <struct pixel[10]> [(int *)&pixels][9].ydelta
 3745              	# main_balls_hdmi.c:50:         *x += *xdelta;
 3746 21b8 23AAD74A 		sw	a3,1204(a5)	# tmp484, MEM <struct pixel[10]> [(int *)&pixels][9].x
 3747              	# main_balls_hdmi.c:51:         *y += *ydelta;
 3748 21bc 23ACE74A 		sw	a4,1208(a5)	# tmp490, MEM <struct pixel[10]> [(int *)&pixels][9].y
 3749              	# main_balls_hdmi.c:59: }
 3750 21c0 67800000 		ret	
 3752              		.section	.text.startup,"ax",@progbits
 3753              		.align	2
 3754              		.globl	main
 3756              	main:
 3757 0000 130101FB 		addi	sp,sp,-80	#,,
 3758 0004 B7060000 		lui	a3,%hi(framebuffer)	# tmp569,
 3759              	# gfx_lib_hdmi.h:228:     framebuffer[i] = 0x000f01<< (i % 16);//i<< (i % 16);//rgb;
 3760 0008 37160000 		li	a2,4096		# tmp256,
 3761              	# main_balls_hdmi.c:62: void main() {
 3762 000c 232E3103 		sw	s3,60(sp)	#,
 3763 0010 2320A103 		sw	s10,32(sp)	#,
 3764 0014 93890600 		addi	s3,a3,%lo(framebuffer)	# ivtmp.478, tmp569,
 3765 0018 138D0600 		addi	s10,a3,%lo(framebuffer)	# framebuffer, tmp569,
 3766              	# gfx_lib_hdmi.h:228:     framebuffer[i] = 0x000f01<< (i % 16);//i<< (i % 16);//rgb;
 3767 001c 930516F0 		addi	a1,a2,-255	#, tmp255, tmp256
 3768              	# main_balls_hdmi.c:62: void main() {
 3769 0020 23261104 		sw	ra,76(sp)	#,
 3770 0024 23248104 		sw	s0,72(sp)	#,
 3771 0028 23229104 		sw	s1,68(sp)	#,
 3772 002c 23202105 		sw	s2,64(sp)	#,
 3773 0030 232C4103 		sw	s4,56(sp)	#,
 3774 0034 232A5103 		sw	s5,52(sp)	#,
 3775 0038 23286103 		sw	s6,48(sp)	#,
 3776 003c 23267103 		sw	s7,44(sp)	#,
 3777 0040 23248103 		sw	s8,40(sp)	#,
 3778 0044 23229103 		sw	s9,36(sp)	#,
 3779 0048 232EB101 		sw	s11,28(sp)	#,
 3780              	# main_balls_hdmi.c:62: void main() {
 3781 004c 93860600 		addi	a3,a3,%lo(framebuffer)	# ivtmp.478, tmp569,
 3782              	# gfx_lib_hdmi.h:227:   for (int i = 0; i < (VRES*HRES); i++) {
 3783 0050 93070000 		li	a5,0		# i,
 3784              	# gfx_lib_hdmi.h:227:   for (int i = 0; i < (VRES*HRES); i++) {
 3785 0054 1306062C 		addi	a2,a2,704	#, tmp257, tmp256
 3786              	.L449:
 3787              	# gfx_lib_hdmi.h:228:     framebuffer[i] = 0x000f01<< (i % 16);//i<< (i % 16);//rgb;
 3788 0058 13F7F700 		andi	a4,a5,15	#, tmp253, i
 3789 005c 3397E500 		sll	a4,a1,a4	# tmp253, tmp254, tmp255
 3790              	# gfx_lib_hdmi.h:228:     framebuffer[i] = 0x000f01<< (i % 16);//i<< (i % 16);//rgb;
 3791 0060 23A0E600 		sw	a4,0(a3)	# tmp254, MEM[(uint32_t *)_160]
 3792              	# gfx_lib_hdmi.h:227:   for (int i = 0; i < (VRES*HRES); i++) {
 3793 0064 93871700 		addi	a5,a5,1	#, i, i
 3794              	# gfx_lib_hdmi.h:227:   for (int i = 0; i < (VRES*HRES); i++) {
 3795 0068 93864600 		addi	a3,a3,4	#, ivtmp.478, ivtmp.478
 3796 006c E396C7FE 		bne	a5,a2,.L449	#, i, tmp257,
 3797 0070 370B0000 		lui	s6,%hi(.LANCHOR0)	# tmp568,
 3798 0074 130B0B00 		addi	s6,s6,%lo(.LANCHOR0)	# tmp570, tmp568,
 3799              	# main_balls_hdmi.c:72:     pixels[i].color = (random() % 0xffffff);
 3800 0078 370A0001 		li	s4,16777216		# tmp281,
 3801 007c 13040B40 		addi	s0,s6,1024	#, ivtmp.472, tmp570
 3802 0080 930A8B4C 		addi	s5,s6,1224	#, _71, tmp570
 3803              	# main_balls_hdmi.c:68:     pixels[i].x = random() % HRES;
 3804 0084 13090005 		li	s2,80		# tmp261,
 3805              	# main_balls_hdmi.c:69:     pixels[i].y = random() % VRES;
 3806 0088 9304C003 		li	s1,60		# tmp263,
 3807              	# main_balls_hdmi.c:72:     pixels[i].color = (random() % 0xffffff);
 3808 008c 130AFAFF 		addi	s4,s4,-1	#, tmp280, tmp281
 3809              	.L450:
 3810              	# main_balls_hdmi.c:68:     pixels[i].x = random() % HRES;
 3811 0090 97000000 		call	random		#
 3811      E7800000 
 3812              	# main_balls_hdmi.c:68:     pixels[i].x = random() % HRES;
 3813 0098 B3672503 		rem	a5,a0,s2	# tmp261, tmp262, tmp582
 3814              	# main_balls_hdmi.c:67:   for (int i = 0; i < N; i++) {
 3815 009c 13044401 		addi	s0,s0,20	#, ivtmp.472, ivtmp.472
 3816              	# main_balls_hdmi.c:68:     pixels[i].x = random() % HRES;
 3817 00a0 2326F4FE 		sw	a5,-20(s0)	# tmp262, MEM[(int *)_70]
 3818              	# main_balls_hdmi.c:69:     pixels[i].y = random() % VRES;
 3819 00a4 97000000 		call	random		#
 3819      E7800000 
 3820              	# main_balls_hdmi.c:69:     pixels[i].y = random() % VRES;
 3821 00ac B3679502 		rem	a5,a0,s1	# tmp263, tmp264, tmp583
 3822              	# main_balls_hdmi.c:69:     pixels[i].y = random() % VRES;
 3823 00b0 2328F4FE 		sw	a5,-16(s0)	# tmp264, MEM[(int *)_70 + 4B]
 3824              	# main_balls_hdmi.c:70:     pixels[i].xdelta = (random() % 2) + 1;
 3825 00b4 97000000 		call	random		#
 3825      E7800000 
 3826              	# main_balls_hdmi.c:70:     pixels[i].xdelta = (random() % 2) + 1;
 3827 00bc 1357F501 		srli	a4,a0,31	#, tmp267, _5
 3828 00c0 B307E500 		add	a5,a0,a4	# tmp267, tmp268, _5
 3829 00c4 93F71700 		andi	a5,a5,1	#, tmp269, tmp268
 3830 00c8 B387E740 		sub	a5,a5,a4	# tmp270, tmp269, tmp267
 3831              	# main_balls_hdmi.c:70:     pixels[i].xdelta = (random() % 2) + 1;
 3832 00cc 93871700 		addi	a5,a5,1	#, tmp271, tmp270
 3833              	# main_balls_hdmi.c:70:     pixels[i].xdelta = (random() % 2) + 1;
 3834 00d0 232AF4FE 		sw	a5,-12(s0)	# tmp271, MEM[(int *)_70 + 8B]
 3835              	# main_balls_hdmi.c:71:     pixels[i].ydelta = (random() % 2) + 1;
 3836 00d4 97000000 		call	random		#
 3836      E7800000 
 3837              	# main_balls_hdmi.c:71:     pixels[i].ydelta = (random() % 2) + 1;
 3838 00dc 1357F501 		srli	a4,a0,31	#, tmp274, _8
 3839 00e0 B307E500 		add	a5,a0,a4	# tmp274, tmp275, _8
 3840 00e4 93F71700 		andi	a5,a5,1	#, tmp276, tmp275
 3841 00e8 B387E740 		sub	a5,a5,a4	# tmp277, tmp276, tmp274
 3842              	# main_balls_hdmi.c:71:     pixels[i].ydelta = (random() % 2) + 1;
 3843 00ec 93871700 		addi	a5,a5,1	#, tmp278, tmp277
 3844              	# main_balls_hdmi.c:71:     pixels[i].ydelta = (random() % 2) + 1;
 3845 00f0 232CF4FE 		sw	a5,-8(s0)	# tmp278, MEM[(int *)_70 + 12B]
 3846              	# main_balls_hdmi.c:72:     pixels[i].color = (random() % 0xffffff);
 3847 00f4 97000000 		call	random		#
 3847      E7800000 
 3848              	# main_balls_hdmi.c:72:     pixels[i].color = (random() % 0xffffff);
 3849 00fc B3674503 		rem	a5,a0,s4	# tmp280, tmp279, tmp586
 3850              	# main_balls_hdmi.c:72:     pixels[i].color = (random() % 0xffffff);
 3851 0100 232EF4FE 		sw	a5,-4(s0)	# tmp279, MEM[(int *)_70 + 16B]
 3852              	# main_balls_hdmi.c:67:   for (int i = 0; i < N; i++) {
 3853 0104 E3968AF8 		bne	s5,s0,.L450	#, _71, ivtmp.472,
 3854              	# main_balls_hdmi.c:76:   *fb_ctrl = 0;
 3855 0108 B7070030 		li	a5,805306368		# tmp283,
 3856              	# gfx_lib_hdmi.h:228:     framebuffer[i] = 0x000f01<< (i % 16);//i<< (i % 16);//rgb;
 3857 010c 37140000 		li	s0,4096		# tmp541,
 3858              	# main_balls_hdmi.c:77:   IO_OUT(GPIO_DIR, ~0);
 3859 0110 1307F0FF 		li	a4,-1		# tmp286,
 3860 0114 375A0000 		lui	s4,%hi(framebuffer+19200)	# tmp566,
 3861              	# gfx_lib_hdmi.h:228:     framebuffer[i] = 0x000f01<< (i % 16);//i<< (i % 16);//rgb;
 3862 0118 930A14F0 		addi	s5,s0,-255	#, tmp540, tmp541
 3863              	# main_balls_hdmi.c:76:   *fb_ctrl = 0;
 3864 011c 23A20702 		sw	zero,36(a5)	#, MEM[(uint32_t *)805306404B]
 3865              	# main_balls_hdmi.c:77:   IO_OUT(GPIO_DIR, ~0);
 3866 0120 23AAE700 		sw	a4,20(a5)	# tmp286, MEM[(volatile uint32_t *)805306388B]
 3867              	# main_balls_hdmi.c:63:   int led = 0;
 3868 0124 930D0000 		li	s11,0		# led,
 3869 0128 130A0AB0 		addi	s4,s4,%lo(framebuffer+19200)	# tmp567, tmp566,
 3870              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3871 012c 930BF004 		li	s7,79		# tmp289,
 3872              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3873 0130 930CB003 		li	s9,59		# tmp581,
 3874              	# main_balls_hdmi.c:82:     oled_show_fb_8or16(framebuffer, 0x10000000 + ((*fb_ctrl & 1) ? 0 : (819
 3875 0134 370C0030 		li	s8,805306368		# tmp478,
 3876              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 3877 0138 13091000 		li	s2,1		# tmp494,
 3878              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 3879 013c 9304803E 		li	s1,1000		# tmp502,
 3880              	# gfx_lib_hdmi.h:227:   for (int i = 0; i < (VRES*HRES); i++) {
 3881 0140 1304042C 		addi	s0,s0,704	#, tmp542, tmp541
 3882              	.L466:
 3883              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3884 0144 03270B40 		lw	a4,1024(s6)		# _122, pixels[0].x
 3885              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3886 0148 63E6EB02 		bgtu	a4,s7,.L451	#, _122, tmp289,
 3887              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3888 014c 83264B40 		lw	a3,1028(s6)		# _124, pixels[0].y
 3889              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3890 0150 63E2DC02 		bgtu	a3,s9,.L451	#, _124, tmp581,
 3891              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3892 0154 93972600 		slli	a5,a3,2	#, tmp294, _124
 3893 0158 B387D700 		add	a5,a5,a3	# _124, tmp295, tmp294
 3894 015c 93974700 		slli	a5,a5,4	#, tmp296, tmp295
 3895              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3896 0160 83160B41 		lh	a3,1040(s6)		# pixels[0].color, pixels[0].color
 3897              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3898 0164 B387E700 		add	a5,a5,a4	# _122, tmp297, tmp296
 3899              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3900 0168 93972700 		slli	a5,a5,2	#, tmp298, tmp297
 3901 016c B307FD00 		add	a5,s10,a5	# tmp298, tmp299, framebuffer
 3902 0170 23A0D700 		sw	a3,0(a5)	# pixels[0].color, *_131
 3903              	.L451:
 3904              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3905 0174 03274B41 		lw	a4,1044(s6)		# _68, pixels[1].x
 3906              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3907 0178 63E6EB02 		bgtu	a4,s7,.L452	#, _68, tmp289,
 3908              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3909 017c 83268B41 		lw	a3,1048(s6)		# _65, pixels[1].y
 3910              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3911 0180 63E2DC02 		bgtu	a3,s9,.L452	#, _65, tmp581,
 3912              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3913 0184 93972600 		slli	a5,a3,2	#, tmp313, _65
 3914 0188 B387D700 		add	a5,a5,a3	# _65, tmp314, tmp313
 3915 018c 93974700 		slli	a5,a5,4	#, tmp315, tmp314
 3916              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3917 0190 83164B42 		lh	a3,1060(s6)		# pixels[1].color, pixels[1].color
 3918              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3919 0194 B387E700 		add	a5,a5,a4	# _68, tmp316, tmp315
 3920              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3921 0198 93972700 		slli	a5,a5,2	#, tmp317, tmp316
 3922 019c B307FD00 		add	a5,s10,a5	# tmp317, tmp318, framebuffer
 3923 01a0 23A0D700 		sw	a3,0(a5)	# pixels[1].color, *_21
 3924              	.L452:
 3925              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3926 01a4 03278B42 		lw	a4,1064(s6)		# _163, pixels[2].x
 3927              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3928 01a8 63E6EB02 		bgtu	a4,s7,.L453	#, _163, tmp289,
 3929              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3930 01ac 8326CB42 		lw	a3,1068(s6)		# _165, pixels[2].y
 3931              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3932 01b0 63E2DC02 		bgtu	a3,s9,.L453	#, _165, tmp581,
 3933              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3934 01b4 93972600 		slli	a5,a3,2	#, tmp332, _165
 3935 01b8 B387D700 		add	a5,a5,a3	# _165, tmp333, tmp332
 3936 01bc 93974700 		slli	a5,a5,4	#, tmp334, tmp333
 3937              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3938 01c0 83168B43 		lh	a3,1080(s6)		# pixels[2].color, pixels[2].color
 3939              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3940 01c4 B387E700 		add	a5,a5,a4	# _163, tmp335, tmp334
 3941              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3942 01c8 93972700 		slli	a5,a5,2	#, tmp336, tmp335
 3943 01cc B307FD00 		add	a5,s10,a5	# tmp336, tmp337, framebuffer
 3944 01d0 23A0D700 		sw	a3,0(a5)	# pixels[2].color, *_172
 3945              	.L453:
 3946              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3947 01d4 0327CB43 		lw	a4,1084(s6)		# _182, pixels[3].x
 3948              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3949 01d8 63E6EB02 		bgtu	a4,s7,.L454	#, _182, tmp289,
 3950              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3951 01dc 83260B44 		lw	a3,1088(s6)		# _184, pixels[3].y
 3952              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3953 01e0 63E2DC02 		bgtu	a3,s9,.L454	#, _184, tmp581,
 3954              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3955 01e4 93972600 		slli	a5,a3,2	#, tmp351, _184
 3956 01e8 B387D700 		add	a5,a5,a3	# _184, tmp352, tmp351
 3957 01ec 93974700 		slli	a5,a5,4	#, tmp353, tmp352
 3958              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3959 01f0 8316CB44 		lh	a3,1100(s6)		# pixels[3].color, pixels[3].color
 3960              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3961 01f4 B387E700 		add	a5,a5,a4	# _182, tmp354, tmp353
 3962              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3963 01f8 93972700 		slli	a5,a5,2	#, tmp355, tmp354
 3964 01fc B307FD00 		add	a5,s10,a5	# tmp355, tmp356, framebuffer
 3965 0200 23A0D700 		sw	a3,0(a5)	# pixels[3].color, *_191
 3966              	.L454:
 3967              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3968 0204 03270B45 		lw	a4,1104(s6)		# _201, pixels[4].x
 3969              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3970 0208 63E6EB02 		bgtu	a4,s7,.L455	#, _201, tmp289,
 3971              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3972 020c 83264B45 		lw	a3,1108(s6)		# _203, pixels[4].y
 3973              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3974 0210 63E2DC02 		bgtu	a3,s9,.L455	#, _203, tmp581,
 3975              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3976 0214 93972600 		slli	a5,a3,2	#, tmp370, _203
 3977 0218 B387D700 		add	a5,a5,a3	# _203, tmp371, tmp370
 3978 021c 93974700 		slli	a5,a5,4	#, tmp372, tmp371
 3979              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3980 0220 83160B46 		lh	a3,1120(s6)		# pixels[4].color, pixels[4].color
 3981              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3982 0224 B387E700 		add	a5,a5,a4	# _201, tmp373, tmp372
 3983              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3984 0228 93972700 		slli	a5,a5,2	#, tmp374, tmp373
 3985 022c B307FD00 		add	a5,s10,a5	# tmp374, tmp375, framebuffer
 3986 0230 23A0D700 		sw	a3,0(a5)	# pixels[4].color, *_210
 3987              	.L455:
 3988              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3989 0234 03274B46 		lw	a4,1124(s6)		# _220, pixels[5].x
 3990              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3991 0238 63E6EB02 		bgtu	a4,s7,.L456	#, _220, tmp289,
 3992              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 3993 023c 83268B46 		lw	a3,1128(s6)		# _222, pixels[5].y
 3994              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3995 0240 63E2DC02 		bgtu	a3,s9,.L456	#, _222, tmp581,
 3996              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3997 0244 93972600 		slli	a5,a3,2	#, tmp389, _222
 3998 0248 B387D700 		add	a5,a5,a3	# _222, tmp390, tmp389
 3999 024c 93974700 		slli	a5,a5,4	#, tmp391, tmp390
 4000              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4001 0250 83164B47 		lh	a3,1140(s6)		# pixels[5].color, pixels[5].color
 4002              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4003 0254 B387E700 		add	a5,a5,a4	# _220, tmp392, tmp391
 4004              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4005 0258 93972700 		slli	a5,a5,2	#, tmp393, tmp392
 4006 025c B307FD00 		add	a5,s10,a5	# tmp393, tmp394, framebuffer
 4007 0260 23A0D700 		sw	a3,0(a5)	# pixels[5].color, *_229
 4008              	.L456:
 4009              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 4010 0264 03278B47 		lw	a4,1144(s6)		# _239, pixels[6].x
 4011              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 4012 0268 63E6EB02 		bgtu	a4,s7,.L457	#, _239, tmp289,
 4013              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 4014 026c 8326CB47 		lw	a3,1148(s6)		# _241, pixels[6].y
 4015              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 4016 0270 63E2DC02 		bgtu	a3,s9,.L457	#, _241, tmp581,
 4017              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4018 0274 93972600 		slli	a5,a3,2	#, tmp408, _241
 4019 0278 B387D700 		add	a5,a5,a3	# _241, tmp409, tmp408
 4020 027c 93974700 		slli	a5,a5,4	#, tmp410, tmp409
 4021              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4022 0280 83168B48 		lh	a3,1160(s6)		# pixels[6].color, pixels[6].color
 4023              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4024 0284 B387E700 		add	a5,a5,a4	# _239, tmp411, tmp410
 4025              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4026 0288 93972700 		slli	a5,a5,2	#, tmp412, tmp411
 4027 028c B307FD00 		add	a5,s10,a5	# tmp412, tmp413, framebuffer
 4028 0290 23A0D700 		sw	a3,0(a5)	# pixels[6].color, *_248
 4029              	.L457:
 4030              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 4031 0294 0327CB48 		lw	a4,1164(s6)		# _258, pixels[7].x
 4032              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 4033 0298 63E6EB02 		bgtu	a4,s7,.L458	#, _258, tmp289,
 4034              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 4035 029c 83260B49 		lw	a3,1168(s6)		# _260, pixels[7].y
 4036              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 4037 02a0 63E2DC02 		bgtu	a3,s9,.L458	#, _260, tmp581,
 4038              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4039 02a4 93972600 		slli	a5,a3,2	#, tmp427, _260
 4040 02a8 B387D700 		add	a5,a5,a3	# _260, tmp428, tmp427
 4041 02ac 93974700 		slli	a5,a5,4	#, tmp429, tmp428
 4042              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4043 02b0 8316CB49 		lh	a3,1180(s6)		# pixels[7].color, pixels[7].color
 4044              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4045 02b4 B387E700 		add	a5,a5,a4	# _258, tmp430, tmp429
 4046              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4047 02b8 93972700 		slli	a5,a5,2	#, tmp431, tmp430
 4048 02bc B307FD00 		add	a5,s10,a5	# tmp431, tmp432, framebuffer
 4049 02c0 23A0D700 		sw	a3,0(a5)	# pixels[7].color, *_267
 4050              	.L458:
 4051              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 4052 02c4 03270B4A 		lw	a4,1184(s6)		# _277, pixels[8].x
 4053              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 4054 02c8 63E6EB02 		bgtu	a4,s7,.L459	#, _277, tmp289,
 4055              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 4056 02cc 83264B4A 		lw	a3,1188(s6)		# _279, pixels[8].y
 4057              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 4058 02d0 63E2DC02 		bgtu	a3,s9,.L459	#, _279, tmp581,
 4059              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4060 02d4 93972600 		slli	a5,a3,2	#, tmp446, _279
 4061 02d8 B387D700 		add	a5,a5,a3	# _279, tmp447, tmp446
 4062 02dc 93974700 		slli	a5,a5,4	#, tmp448, tmp447
 4063              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4064 02e0 83160B4B 		lh	a3,1200(s6)		# pixels[8].color, pixels[8].color
 4065              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4066 02e4 B387E700 		add	a5,a5,a4	# _277, tmp449, tmp448
 4067              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4068 02e8 93972700 		slli	a5,a5,2	#, tmp450, tmp449
 4069 02ec B307FD00 		add	a5,s10,a5	# tmp450, tmp451, framebuffer
 4070 02f0 23A0D700 		sw	a3,0(a5)	# pixels[8].color, *_286
 4071              	.L459:
 4072              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 4073 02f4 03274B4B 		lw	a4,1204(s6)		# _76, pixels[9].x
 4074              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 4075 02f8 63E6EB02 		bgtu	a4,s7,.L460	#, _76, tmp289,
 4076              	# main_balls_hdmi.c:26:     fb_setpixel(framebuffer, pixels[i].x, pixels[i].y, pixels[i].color);
 4077 02fc 83268B4B 		lw	a3,1208(s6)		# _77, pixels[9].y
 4078              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 4079 0300 63E2DC02 		bgtu	a3,s9,.L460	#, _77, tmp581,
 4080              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4081 0304 93972600 		slli	a5,a3,2	#, tmp465, _77
 4082 0308 B387D700 		add	a5,a5,a3	# _77, tmp466, tmp465
 4083 030c 93974700 		slli	a5,a5,4	#, tmp467, tmp466
 4084              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4085 0310 83164B4C 		lh	a3,1220(s6)		# pixels[9].color, pixels[9].color
 4086              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4087 0314 B387E700 		add	a5,a5,a4	# _76, tmp468, tmp467
 4088              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4089 0318 93972700 		slli	a5,a5,2	#, tmp469, tmp468
 4090 031c B307FD00 		add	a5,s10,a5	# tmp469, tmp470, framebuffer
 4091 0320 23A0D700 		sw	a3,0(a5)	# pixels[9].color, *_85
 4092              	.L460:
 4093              	# main_balls_hdmi.c:82:     oled_show_fb_8or16(framebuffer, 0x10000000 + ((*fb_ctrl & 1) ? 0 : (819
 4094 0324 83274C02 		lw	a5,36(s8)		# MEM[(uint32_t *)805306404B], MEM[(uint32_t *)805306404B]
 4095              	# main_balls_hdmi.c:82:     oled_show_fb_8or16(framebuffer, 0x10000000 + ((*fb_ctrl & 1) ? 0 : (819
 4096 0328 37070010 		li	a4,268435456		# p,
 4097              	# main_balls_hdmi.c:82:     oled_show_fb_8or16(framebuffer, 0x10000000 + ((*fb_ctrl & 1) ? 0 : (819
 4098 032c 93F71700 		andi	a5,a5,1	#, tmp479, MEM[(uint32_t *)805306404B]
 4099              	# main_balls_hdmi.c:82:     oled_show_fb_8or16(framebuffer, 0x10000000 + ((*fb_ctrl & 1) ? 0 : (819
 4100 0330 63940700 		bne	a5,zero,.L461	#, tmp479,,
 4101 0334 37870010 		li	a4,268468224		# p,
 4102              	.L461:
 4103 0338 93070D00 		mv	a5,s10	# framebuffer, framebuffer
 4104              	.L462:
 4105              	# gfx_lib_hdmi.h:127:     *p++ = *framebuffer++;
 4106 033c 03A60700 		lw	a2,0(a5)		# _64, MEM[(uint32_t *)framebuffer_61 + 4294967292B]
 4107              	# gfx_lib_hdmi.h:127:     *p++ = *framebuffer++;
 4108 0340 93874700 		addi	a5,a5,4	#, framebuffer, framebuffer
 4109              	# gfx_lib_hdmi.h:127:     *p++ = *framebuffer++;
 4110 0344 13074700 		addi	a4,a4,4	#, p, p
 4111              	# gfx_lib_hdmi.h:127:     *p++ = *framebuffer++;
 4112 0348 232EC7FE 		sw	a2,-4(a4)	# _64, *p_66
 4113              	# gfx_lib_hdmi.h:126:   for (int i = 0; i < (VRES*HRES); i++) {
 4114 034c E39847FF 		bne	a5,s4,.L462	#, framebuffer, tmp567,
 4115              	# main_balls_hdmi.c:83:     *fb_ctrl ^= 1;
 4116 0350 83274C02 		lw	a5,36(s8)		# MEM[(uint32_t *)805306404B], MEM[(uint32_t *)805306404B]
 4117              	# main_balls_hdmi.c:88:     led &= 7;
 4118 0354 93FD7D00 		andi	s11,s11,7	#, led, led
 4119              	# main_balls_hdmi.c:83:     *fb_ctrl ^= 1;
 4120 0358 93C71700 		xori	a5,a5,1	#, tmp487, MEM[(uint32_t *)805306404B]
 4121 035c 2322FC02 		sw	a5,36(s8)	# tmp487, MEM[(uint32_t *)805306404B]
 4122              	# main_balls_hdmi.c:84:     move_pixels();
 4123 0360 97000000 		call	move_pixels		#
 4123      E7800000 
 4124              	# main_balls_hdmi.c:87:     IO_OUT(GPIO_OUTPUT, 0);
 4125 0368 232E0C00 		sw	zero,28(s8)	#, MEM[(volatile uint32_t *)805306396B]
 4126              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 4127 036c 0327CC01 		lw	a4,28(s8)		# _104, MEM[(volatile uint32_t *)805306396B]
 4128              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 4129 0370 B317B901 		sll	a5,s2,s11	# led, tmp493, tmp494
 4130              	# main_balls_hdmi.c:89:     gpio_set_value(led++, 1);
 4131 0374 938D1D00 		addi	s11,s11,1	#, led, led
 4132              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 4133 0378 B3E7E700 		or	a5,a5,a4	# _104, _108, tmp493
 4134 037c 232EFC00 		sw	a5,28(s8)	# _108, MEM[(volatile uint32_t *)805306396B]
 4135              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 4136 0380 03270C01 		lw	a4,16(s8)		# _87, MEM[(volatile uint32_t *)805306384B]
 4137              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 4138              	 #APP
 4139              	# 150 "kianv_stdlib.h" 1
 4140              		rdcycleh a5	# tmp499
 4141              	# 0 "" 2
 4142              	 #NO_APP
 4143 0388 2324F100 		sw	a5,8(sp)	# tmp499, tmph0
 4144              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 4145              	 #APP
 4146              	# 151 "kianv_stdlib.h" 1
 4147              		rdcycle  a5	# tmp500
 4148              	# 0 "" 2
 4149              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 4150              	 #NO_APP
 4151 0390 33579702 		divu	a4,a4,s1	# tmp502, tmp503, _87
 4152              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 4153 0394 2326F100 		sw	a5,12(sp)	# tmp500, tmpl0
 4154              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 4155 0398 83268100 		lw	a3,8(sp)		# tmph0.0_91, tmph0
 4156              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 4157 039c 0326C100 		lw	a2,12(sp)		# tmpl0.1_94, tmpl0
 4158              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 4159 03a0 93172700 		slli	a5,a4,2	#, tmp505, tmp503
 4160 03a4 B387E700 		add	a5,a5,a4	# tmp503, tmp506, tmp505
 4161 03a8 93972700 		slli	a5,a5,2	#, tmp507, tmp506
 4162              	# kianv_stdlib.h:162:   uint64_t lim = get_cycles() + wait;
 4163 03ac 3386C700 		add	a2,a5,a2	# tmpl0.1_94, tmp556, tmp507
 4164 03b0 B337F600 		sltu	a5,a2,a5	# tmp507, tmp519, tmp556
 4165 03b4 B387D700 		add	a5,a5,a3	# tmph0.0_91, tmp521, tmp519
 4166              	.L473:
 4167              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 4168              	 #APP
 4169              	# 150 "kianv_stdlib.h" 1
 4170              		rdcycleh a4	# tmp522
 4171              	# 0 "" 2
 4172              	 #NO_APP
 4173 03bc 2320E100 		sw	a4,0(sp)	# tmp522, tmph0
 4174              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 4175              	 #APP
 4176              	# 151 "kianv_stdlib.h" 1
 4177              		rdcycle  a4	# tmp523
 4178              	# 0 "" 2
 4179              	 #NO_APP
 4180 03c4 2322E100 		sw	a4,4(sp)	# tmp523, tmpl0
 4181              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 4182 03c8 03270100 		lw	a4,0(sp)		# tmph0.0_98, tmph0
 4183              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 4184 03cc 83264100 		lw	a3,4(sp)		# tmpl0.1_101, tmpl0
 4185              	# kianv_stdlib.h:163:   while (get_cycles() < lim)
 4186 03d0 E364F7FE 		bgtu	a5,a4,.L473	#, tmp521, tmph0.0_98,
 4187 03d4 6394E700 		bne	a5,a4,.L468	#, tmp521, tmph0.0_98,
 4188 03d8 E3E0C6FE 		bgtu	a2,a3,.L473	#, tmp556, tmpl0.1_101,
 4189              	.L468:
 4190 03dc 93860900 		mv	a3,s3	# ivtmp.457, ivtmp.478
 4191              	# gfx_lib_hdmi.h:227:   for (int i = 0; i < (VRES*HRES); i++) {
 4192 03e0 93070000 		li	a5,0		# i,
 4193              	.L465:
 4194              	# gfx_lib_hdmi.h:228:     framebuffer[i] = 0x000f01<< (i % 16);//i<< (i % 16);//rgb;
 4195 03e4 13F7F700 		andi	a4,a5,15	#, tmp538, i
 4196 03e8 3397EA00 		sll	a4,s5,a4	# tmp538, tmp539, tmp540
 4197              	# gfx_lib_hdmi.h:228:     framebuffer[i] = 0x000f01<< (i % 16);//i<< (i % 16);//rgb;
 4198 03ec 23A0E600 		sw	a4,0(a3)	# tmp539, MEM[(uint32_t *)_237]
 4199              	# gfx_lib_hdmi.h:227:   for (int i = 0; i < (VRES*HRES); i++) {
 4200 03f0 93871700 		addi	a5,a5,1	#, i, i
 4201              	# gfx_lib_hdmi.h:227:   for (int i = 0; i < (VRES*HRES); i++) {
 4202 03f4 93864600 		addi	a3,a3,4	#, ivtmp.457, ivtmp.457
 4203 03f8 E39687FE 		bne	a5,s0,.L465	#, i, tmp542,
 4204 03fc 6FF09FD4 		j	.L466		#
 4206              		.globl	pixels
 4207              		.globl	oled_8bit_init_seq
 4208              		.globl	framebuffer
 4209              		.globl	heap_memory_used
 4210              		.globl	heap_memory
 4211              		.section	.srodata.cst8,"aM",@progbits,8
 4212              		.align	3
 4213              	.LC1:
 4214 0000 00000000 		.word	0
 4215 0004 0000E040 		.word	1088421888
 4216              		.align	3
 4217              	.LC2:
 4218 0008 00000000 		.word	0
 4219 000c 00807640 		.word	1081507840
 4220              		.align	3
 4221              	.LC3:
 4222 0010 80004000 		.word	4194432
 4223 0014 2000003F 		.word	1056964640
 4224              		.section	.rodata
 4225              		.align	2
 4226              		.set	.LANCHOR1,. + 0
 4229              	sin90:
 4230 0000 0000     		.half	0
 4231 0002 4706     		.half	1607
 4232 0004 8B0C     		.half	3211
 4233 0006 C712     		.half	4807
 4234 0008 F818     		.half	6392
 4235 000a 191F     		.half	7961
 4236 000c 2725     		.half	9511
 4237 000e 1E2B     		.half	11038
 4238 0010 FB30     		.half	12539
 4239 0012 B936     		.half	14009
 4240 0014 563C     		.half	15446
 4241 0016 CD41     		.half	16845
 4242 0018 1C47     		.half	18204
 4243 001a 3F4C     		.half	19519
 4244 001c 3351     		.half	20787
 4245 001e F455     		.half	22004
 4246 0020 815A     		.half	23169
 4247 0022 D65E     		.half	24278
 4248 0024 F162     		.half	25329
 4249 0026 CE66     		.half	26318
 4250 0028 6C6A     		.half	27244
 4251 002a C96D     		.half	28105
 4252 002c E170     		.half	28897
 4253 002e B573     		.half	29621
 4254 0030 4076     		.half	30272
 4255 0032 8378     		.half	30851
 4256 0034 7C7A     		.half	31356
 4257 0036 297C     		.half	31785
 4258 0038 897D     		.half	32137
 4259 003a 9C7E     		.half	32412
 4260 003c 617F     		.half	32609
 4261 003e D77F     		.half	32727
 4262 0040 FF7F     		.half	32767
 4263              		.data
 4264              		.align	2
 4265              		.set	.LANCHOR2,. + 0
 4268              	oled_8bit_init_seq:
 4269 0000 AEA032A1 		.string	"\256\2402\241"
 4269      00
 4270 0005 A200     		.string	"\242"
 4271 0007 A4A83FAD 		.ascii	"\244\250?\255\216\260\013\2611\263\360\212d\213x\214d\273:\276"
 4271      8EB00BB1 
 4271      31B3F08A 
 4271      648B788C 
 4271      64BB3ABE 
 4272 001b 3E870681 		.ascii	">\207\006\201\221\202P\203}\257"
 4272      91825083 
 4272      7DAF
 4273              		.bss
 4274              		.align	2
 4275              		.set	.LANCHOR0,. + 0
 4278              	heap_memory:
 4279 0000 00000000 		.zero	1024
 4279      00000000 
 4279      00000000 
 4279      00000000 
 4279      00000000 
 4282              	pixels:
 4283 0400 00000000 		.zero	200
 4283      00000000 
 4283      00000000 
 4283      00000000 
 4283      00000000 
 4286              	framebuffer:
 4287 04c8 00000000 		.zero	19200
 4287      00000000 
 4287      00000000 
 4287      00000000 
 4287      00000000 
 4288              		.section	.sbss,"aw",@nobits
 4289              		.align	2
 4292              	heap_memory_used:
 4293 0000 00000000 		.zero	4
 4294              		.ident	"GCC: (GNU) 11.1.0"
