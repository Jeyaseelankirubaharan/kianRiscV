   1              		.file	"plasma_hdmi.c"
   2              		.option nopic
   3              		.attribute arch, "rv32i2p0_m2p0"
   4              		.attribute unaligned_access, 0
   5              		.attribute stack_align, 16
   6              	# GNU C17 (GCC) version 11.1.0 (riscv32-unknown-elf)
   7              	#	compiled by GNU C version 9.3.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl ve
   8              	# warning: GMP header version 6.2.0 differs from library version 6.3.0.
   9              	# warning: MPFR header version 4.0.2 differs from library version 4.2.1.
  10              	# warning: MPC header version 1.1.0 differs from library version 1.3.1.
  11              	# GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
  12              	# options passed: -march=rv32im -mabi=ilp32 -mtune=rocket -march=rv32im -O3 -fno-pic -fno-stack-pro
  13              		.text
  14              		.align	2
  15              		.globl	dma_action
  17              	dma_action:
  18              	# kianv_stdlib_hdmi.h:50:   *( (volatile uint32_t*) DMA_SRC  ) = src;
  19 0000 B7070030 		li	a5,805306368		# tmp77,
  20 0004 23A6A702 		sw	a0,44(a5)	# src, MEM[(volatile uint32_t *)805306412B]
  21              	# kianv_stdlib_hdmi.h:51:   *( (volatile uint32_t*) DMA_DST  ) = dst;
  22 0008 23A8B702 		sw	a1,48(a5)	# dst, MEM[(volatile uint32_t *)805306416B]
  23              	# kianv_stdlib_hdmi.h:52:   *( (volatile uint32_t*) DMA_LEN  ) = len;
  24 000c 23AAC702 		sw	a2,52(a5)	# len, MEM[(volatile uint32_t *)805306420B]
  25              	# kianv_stdlib_hdmi.h:53:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
  26 0010 23ACD702 		sw	a3,56(a5)	# ctrl, MEM[(volatile uint32_t *)805306424B]
  27              	# kianv_stdlib_hdmi.h:54: }
  28 0014 67800000 		ret	
  30              		.align	2
  31              		.globl	set_reg
  33              	set_reg:
  34              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  35 0018 03270500 		lw	a4,0(a0)		# _1,* p
  36              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  37 001c 93071000 		li	a5,1		# tmp85,
  38 0020 B397B700 		sll	a5,a5,a1	# tmp88, _12, tmp85
  39              	# kianv_stdlib_hdmi.h:57:     if (bit) {
  40 0024 63080600 		beq	a2,zero,.L4	#, tmp89,,
  41              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  42 0028 B3E7E700 		or	a5,a5,a4	# _1, _5, _12
  43 002c 2320F500 		sw	a5,0(a0)	# _5,* p
  44 0030 67800000 		ret	
  45              	.L4:
  46              	# kianv_stdlib_hdmi.h:60:       *p &= ~( 0x01 << (gpio & 0x1f));
  47 0034 93C7F7FF 		not	a5,a5	# tmp86, _12
  48              	# kianv_stdlib_hdmi.h:60:       *p &= ~( 0x01 << (gpio & 0x1f));
  49 0038 B3F7E700 		and	a5,a5,a4	# _13, _18, tmp86
  50 003c 2320F500 		sw	a5,0(a0)	# _18,* p
  51              	# kianv_stdlib_hdmi.h:62: }
  52 0040 67800000 		ret	
  54              		.align	2
  55              		.globl	gpio_set_value
  57              	gpio_set_value:
  58              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  59 0044 37070030 		li	a4,805306368		# tmp86,
  60 0048 8326C701 		lw	a3,28(a4)		# _4,
  61              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  62 004c 93071000 		li	a5,1		# tmp84,
  63 0050 B397A700 		sll	a5,a5,a0	# tmp94, _19, tmp84
  64              	# kianv_stdlib_hdmi.h:57:     if (bit) {
  65 0054 63880500 		beq	a1,zero,.L7	#, tmp95,,
  66              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  67 0058 B3E7D700 		or	a5,a5,a3	# _4, _8, _19
  68 005c 232EF700 		sw	a5,28(a4)	# _8,
  69 0060 67800000 		ret	
  70              	.L7:
  71              	# kianv_stdlib_hdmi.h:60:       *p &= ~( 0x01 << (gpio & 0x1f));
  72 0064 93C7F7FF 		not	a5,a5	# tmp91, _19
  73              	# kianv_stdlib_hdmi.h:60:       *p &= ~( 0x01 << (gpio & 0x1f));
  74 0068 B3F7D700 		and	a5,a5,a3	# _12, _17, tmp91
  75 006c 232EF700 		sw	a5,28(a4)	# _17,
  76              	# kianv_stdlib_hdmi.h:66: }
  77 0070 67800000 		ret	
  79              		.align	2
  80              		.globl	gpio_get_input_value
  82              	gpio_get_input_value:
  83              	# kianv_stdlib_hdmi.h:69:   uint32_t read = IO_IN(GPIO_INPUT);
  84 0074 B7070030 		li	a5,805306368		# tmp77,
  85 0078 83A70702 		lw	a5,32(a5)		# read, MEM[(volatile uint32_t *)805306400B]
  86              	# kianv_stdlib_hdmi.h:72:   return ((read >> gpio) & 0x01);
  87 007c 33D5A700 		srl	a0,a5,a0	# tmp80, tmp79, read
  88              	# kianv_stdlib_hdmi.h:73: }
  89 0080 13751500 		andi	a0,a0,1	#,, tmp79
  90 0084 67800000 		ret	
  92              		.align	2
  93              		.globl	gpio_set_direction
  95              	gpio_set_direction:
  96              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  97 0088 37070030 		li	a4,805306368		# tmp86,
  98 008c 83264701 		lw	a3,20(a4)		# _4,
  99              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
 100 0090 93071000 		li	a5,1		# tmp84,
 101 0094 B397A700 		sll	a5,a5,a0	# tmp94, _19, tmp84
 102              	# kianv_stdlib_hdmi.h:57:     if (bit) {
 103 0098 63880500 		beq	a1,zero,.L11	#, tmp95,,
 104              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
 105 009c B3E7D700 		or	a5,a5,a3	# _4, _8, _19
 106 00a0 232AF700 		sw	a5,20(a4)	# _8,
 107 00a4 67800000 		ret	
 108              	.L11:
 109              	# kianv_stdlib_hdmi.h:60:       *p &= ~( 0x01 << (gpio & 0x1f));
 110 00a8 93C7F7FF 		not	a5,a5	# tmp91, _19
 111              	# kianv_stdlib_hdmi.h:60:       *p &= ~( 0x01 << (gpio & 0x1f));
 112 00ac B3F7D700 		and	a5,a5,a3	# _12, _17, tmp91
 113 00b0 232AF700 		sw	a5,20(a4)	# _17,
 114              	# kianv_stdlib_hdmi.h:77: }
 115 00b4 67800000 		ret	
 117              		.align	2
 118              		.globl	get_cycles
 120              	get_cycles:
 121 00b8 130101FF 		addi	sp,sp,-16	#,,
 122              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 123              	 #APP
 124              	# 83 "kianv_stdlib_hdmi.h" 1
   1              	#include <stdint.h>
   2              	#include <math.h>
   3              	
   4              	/* kian hardware register */
   5              	#define IO_BASE 0x30000000
   6              	#define UART_TX             (volatile uint32_t *) (IO_BASE + 0x0000)
   7              	#define UART_READY          (volatile uint32_t *) (IO_BASE + 0x0000)
   8              	#define VIDEOENABLE         (volatile uint32_t *) (IO_BASE + 0x0008)
   9              	#define VIDEO               (volatile uint32_t *) (IO_BASE + 0x0008)
  10              	#define VIDEO_RAW           (volatile uint32_t *) (IO_BASE + 0x000C)
  11              	#define CPU_FREQ            (volatile uint32_t *) (IO_BASE + 0x0010)
  12              	// gpio hack stuff
  13              	#define GPIO_DIR            ( volatile uint32_t  *) (IO_BASE + 0x0014)
  14              	#define GPIO_PULLUP         ( volatile uint32_t  *) (IO_BASE + 0x0018) // not implemented
  15              	#define GPIO_OUTPUT         ( volatile uint32_t  *) (IO_BASE + 0x001C)
  16              	#define GPIO_INPUT          ( volatile uint32_t  *) (IO_BASE + 0x0020)
  17              	#define IO_OUT(reg, value) *((volatile uint32_t  *) (reg)) = (value)
  18              	#define IO_IN(reg)         *((volatile uint32_t  *) reg)
  19              	// dma stuff
  20              	#define DMA_SRC             ( volatile uint32_t  *) (IO_BASE + 0x002C)
  21              	#define DMA_DST             ( volatile uint32_t  *) (IO_BASE + 0x0030)
  22              	#define DMA_LEN             ( volatile uint32_t  *) (IO_BASE + 0x0034)
  23              	#define DMA_CTRL            ( volatile uint32_t  *) (IO_BASE + 0x0038)
  24              	#define DMA_MEMCPY          (1 << 0)
  25              	#define DMA_MEMSET          (1 << 1)
  26              	
  27              	#define GPIO_INPUT_PIN  0
  28              	#define GPIO_OUTPUT_PIN 1
  29              	//#define RV32_FASTCODE __attribute((section(".fastcode")))
  30              	#define RV32_FASTCODE
  31              	
  32              	//__attribute((section(".fastcode")))
  33              	
  34              	#define RED   "\x1B[31m"
  35              	#define GRN   "\x1B[32m"
  36              	#define YEL   "\x1B[33m"
  37              	#define BLU   "\x1B[34m"
  38              	#define MAG   "\x1B[35m"
  39              	#define CYN   "\x1B[36m"
  40              	#define WHT   "\x1B[37m"
  41              	#define RESET "\x1B[0m"
  42              	
  43              	#define CLS       "\x1B[2J"
  44              	#define BOLD      "\x1B[1m"
  45              	#define BLINK     "\x1B[5m"
  46              	#define BLINK_OFF "\x1B[25m"
  47              	
  48              	// dma stuff
  49              	void dma_action(uint32_t src, uint32_t dst, uint32_t len, uint32_t ctrl) {
  50              	  *( (volatile uint32_t*) DMA_SRC  ) = src;
  51              	  *( (volatile uint32_t*) DMA_DST  ) = dst;
  52              	  *( (volatile uint32_t*) DMA_LEN  ) = len;
  53              	  *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
  54              	}
  55              	
  56              	void set_reg(volatile uint32_t *p, int gpio, int bit) {
  57              	    if (bit) {
  58              	      *p |=  (0x01 << (gpio & 0x1f));
  59              	    } else {
  60              	      *p &= ~( 0x01 << (gpio & 0x1f));
  61              	    }
  62              	}
  63              	
  64              	void gpio_set_value(int gpio, int bit) {
  65              	    set_reg(GPIO_OUTPUT, gpio, bit);
  66              	}
  67              	
  68              	uint32_t gpio_get_input_value(int gpio) {
  69              	  uint32_t read = IO_IN(GPIO_INPUT);
  70              	
  71              	  //  return ((read & (1<<gpio)) >> gpio);
  72              	  return ((read >> gpio) & 0x01);
  73              	}
  74              	
  75              	void gpio_set_direction(int gpio, int bit) {
  76              	    set_reg(GPIO_DIR, gpio, bit);
  77              	}
  78              	
  79              	uint64_t get_cycles() {
  80              	  volatile uint32_t tmph0;
  81              	  volatile uint32_t tmpl0;
  82              	
  83 00bc F32700C8 	  asm volatile ("rdcycleh %0" : "=r"(tmph0));
  84              	  asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 125              		rdcycleh a5	# tmp78
 126              	# 0 "" 2
 127              	 #NO_APP
 128 00c0 2324F100 		sw	a5,8(sp)	# tmp78, tmph0
 129              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 130              	 #APP
 131              	# 84 "kianv_stdlib_hdmi.h" 1
  85              	
 132              		rdcycle  a5	# tmp79
 133              	# 0 "" 2
 134              	 #NO_APP
 135 00c8 2326F100 		sw	a5,12(sp)	# tmp79, tmpl0
 136              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 137 00cc 83258100 		lw	a1,8(sp)		# tmph0.0_1, tmph0
 138              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 139 00d0 0325C100 		lw	a0,12(sp)		# tmpl0.1_4, tmpl0
 140              	# kianv_stdlib_hdmi.h:88: }
 141 00d4 13010101 		addi	sp,sp,16	#,,
 142 00d8 67800000 		jr	ra		#
 144              		.align	2
 145              		.globl	wait_cycles
 147              	wait_cycles:
 148 00dc 130101FF 		addi	sp,sp,-16	#,,
 149              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 150              	 #APP
 151              	# 83 "kianv_stdlib_hdmi.h" 1
 152              		rdcycleh a5	# tmp86
 153              	# 0 "" 2
 154              	 #NO_APP
 155 00e4 2320F100 		sw	a5,0(sp)	# tmp86, tmph0
 156              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 157              	 #APP
 158              	# 84 "kianv_stdlib_hdmi.h" 1
 159              		rdcycle  a5	# tmp87
 160              	# 0 "" 2
 161              	 #NO_APP
 162 00ec 2322F100 		sw	a5,4(sp)	# tmp87, tmpl0
 163              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 164 00f0 83270100 		lw	a5,0(sp)		# tmph0.0_5, tmph0
 165              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 166 00f4 03264100 		lw	a2,4(sp)		# tmpl0.1_8, tmpl0
 167              	# kianv_stdlib_hdmi.h:95:   uint64_t lim = get_cycles() + wait;
 168 00f8 B387B700 		add	a5,a5,a1	# wait, tmp126, tmph0.0_5
 169 00fc 3306C500 		add	a2,a0,a2	# tmpl0.1_8, tmp129, wait
 170 0100 3335A600 		sltu	a0,a2,a0	# wait, tmp98, tmp129
 171 0104 3307F500 		add	a4,a0,a5	# tmp126, tmp100, tmp98
 172              	.L18:
 173              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 174              	 #APP
 175              	# 83 "kianv_stdlib_hdmi.h" 1
 176              		rdcycleh a5	# tmp101
 177              	# 0 "" 2
 178              	 #NO_APP
 179 010c 2324F100 		sw	a5,8(sp)	# tmp101, tmph0
 180              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 181              	 #APP
 182              	# 84 "kianv_stdlib_hdmi.h" 1
 183              		rdcycle  a5	# tmp102
 184              	# 0 "" 2
 185              	 #NO_APP
 186 0114 2326F100 		sw	a5,12(sp)	# tmp102, tmpl0
 187              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 188 0118 83278100 		lw	a5,8(sp)		# tmph0.0_11, tmph0
 189              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 190 011c 8326C100 		lw	a3,12(sp)		# tmpl0.1_14, tmpl0
 191              	# kianv_stdlib_hdmi.h:96:   while (get_cycles() < lim)
 192 0120 E3E4E7FE 		bgtu	a4,a5,.L18	#, tmp100, tmph0.0_11,
 193 0124 6314F700 		bne	a4,a5,.L15	#, tmp100, tmph0.0_11,
 194 0128 E3E0C6FE 		bgtu	a2,a3,.L18	#, tmp129, tmpl0.1_14,
 195              	.L15:
 196              	# kianv_stdlib_hdmi.h:98: }
 197 012c 13010101 		addi	sp,sp,16	#,,
 198 0130 67800000 		jr	ra		#
 200              		.align	2
 201              		.globl	usleep
 203              	usleep:
 204              	# kianv_stdlib_hdmi.h:101:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 205 0134 63080506 		beq	a0,zero,.L29	#, us,,
 206              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 207 0138 B7070030 		li	a5,805306368		# tmp91,
 208              	# kianv_stdlib_hdmi.h:100: void usleep(uint32_t us) {
 209 013c 130101FF 		addi	sp,sp,-16	#,,
 210              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 211 0140 83A70701 		lw	a5,16(a5)		# _20, MEM[(volatile uint32_t *)805306384B]
 212              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 213              	 #APP
 214              	# 83 "kianv_stdlib_hdmi.h" 1
 215              		rdcycleh a4	# tmp92
 216              	# 0 "" 2
 217              	 #NO_APP
 218 0148 2324E100 		sw	a4,8(sp)	# tmp92, tmph0
 219              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 220              	 #APP
 221              	# 84 "kianv_stdlib_hdmi.h" 1
 222              		rdcycle  a3	# tmp93
 223              	# 0 "" 2
 224              	# kianv_stdlib_hdmi.h:101:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 225              	 #NO_APP
 226 0150 37470F00 		li	a4,999424		# tmp97,
 227 0154 13070724 		addi	a4,a4,576	#, tmp96, tmp97
 228 0158 B3D7E702 		divu	a5,a5,a4	# tmp96, tmp95, _20
 229              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 230 015c 2326D100 		sw	a3,12(sp)	# tmp93, tmpl0
 231              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 232 0160 03278100 		lw	a4,8(sp)		# tmph0.0_7, tmph0
 233              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 234 0164 0326C100 		lw	a2,12(sp)		# tmpl0.1_10, tmpl0
 235              	# kianv_stdlib_hdmi.h:101:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 236 0168 B387A702 		mul	a5,a5,a0	# tmp98, tmp95, us
 237              	# kianv_stdlib_hdmi.h:95:   uint64_t lim = get_cycles() + wait;
 238 016c 3386C700 		add	a2,a5,a2	# tmpl0.1_10, tmp141, tmp98
 239 0170 B337F600 		sltu	a5,a2,a5	# tmp98, tmp110, tmp141
 240 0174 B387E700 		add	a5,a5,a4	# tmph0.0_7, tmp112, tmp110
 241              	.L26:
 242              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 243              	 #APP
 244              	# 83 "kianv_stdlib_hdmi.h" 1
 245              		rdcycleh a4	# tmp113
 246              	# 0 "" 2
 247              	 #NO_APP
 248 017c 2320E100 		sw	a4,0(sp)	# tmp113, tmph0
 249              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 250              	 #APP
 251              	# 84 "kianv_stdlib_hdmi.h" 1
 252              		rdcycle  a4	# tmp114
 253              	# 0 "" 2
 254              	 #NO_APP
 255 0184 2322E100 		sw	a4,4(sp)	# tmp114, tmpl0
 256              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 257 0188 03270100 		lw	a4,0(sp)		# tmph0.0_14, tmph0
 258              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 259 018c 83264100 		lw	a3,4(sp)		# tmpl0.1_17, tmpl0
 260              	# kianv_stdlib_hdmi.h:96:   while (get_cycles() < lim)
 261 0190 E364F7FE 		bgtu	a5,a4,.L26	#, tmp112, tmph0.0_14,
 262 0194 6394E700 		bne	a5,a4,.L20	#, tmp112, tmph0.0_14,
 263 0198 E3E0C6FE 		bgtu	a2,a3,.L26	#, tmp141, tmpl0.1_17,
 264              	.L20:
 265              	# kianv_stdlib_hdmi.h:102: }
 266 019c 13010101 		addi	sp,sp,16	#,,
 267 01a0 67800000 		jr	ra		#
 268              	.L29:
 269 01a4 67800000 		ret	
 271              		.align	2
 272              		.globl	msleep
 274              	msleep:
 275              	# kianv_stdlib_hdmi.h:105:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 276 01a8 63060506 		beq	a0,zero,.L41	#, ms,,
 277              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 278 01ac B7070030 		li	a5,805306368		# tmp91,
 279              	# kianv_stdlib_hdmi.h:104: void msleep(uint32_t ms) {
 280 01b0 130101FF 		addi	sp,sp,-16	#,,
 281              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 282 01b4 83A70701 		lw	a5,16(a5)		# _20, MEM[(volatile uint32_t *)805306384B]
 283              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 284              	 #APP
 285              	# 83 "kianv_stdlib_hdmi.h" 1
 286              		rdcycleh a4	# tmp92
 287              	# 0 "" 2
 288              	 #NO_APP
 289 01bc 2324E100 		sw	a4,8(sp)	# tmp92, tmph0
 290              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 291              	 #APP
 292              	# 84 "kianv_stdlib_hdmi.h" 1
 293              		rdcycle  a4	# tmp93
 294              	# 0 "" 2
 295              	# kianv_stdlib_hdmi.h:105:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 296              	 #NO_APP
 297 01c4 9306803E 		li	a3,1000		# tmp95,
 298 01c8 B3D7D702 		divu	a5,a5,a3	# tmp95, tmp96, _20
 299              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 300 01cc 2326E100 		sw	a4,12(sp)	# tmp93, tmpl0
 301              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 302 01d0 03278100 		lw	a4,8(sp)		# tmph0.0_7, tmph0
 303              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 304 01d4 0326C100 		lw	a2,12(sp)		# tmpl0.1_10, tmpl0
 305              	# kianv_stdlib_hdmi.h:105:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 306 01d8 B387A702 		mul	a5,a5,a0	# tmp97, tmp96, ms
 307              	# kianv_stdlib_hdmi.h:95:   uint64_t lim = get_cycles() + wait;
 308 01dc 3386C700 		add	a2,a5,a2	# tmpl0.1_10, tmp140, tmp97
 309 01e0 B337F600 		sltu	a5,a2,a5	# tmp97, tmp109, tmp140
 310 01e4 B387E700 		add	a5,a5,a4	# tmph0.0_7, tmp111, tmp109
 311              	.L38:
 312              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 313              	 #APP
 314              	# 83 "kianv_stdlib_hdmi.h" 1
 315              		rdcycleh a4	# tmp112
 316              	# 0 "" 2
 317              	 #NO_APP
 318 01ec 2320E100 		sw	a4,0(sp)	# tmp112, tmph0
 319              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 320              	 #APP
 321              	# 84 "kianv_stdlib_hdmi.h" 1
 322              		rdcycle  a4	# tmp113
 323              	# 0 "" 2
 324              	 #NO_APP
 325 01f4 2322E100 		sw	a4,4(sp)	# tmp113, tmpl0
 326              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 327 01f8 03270100 		lw	a4,0(sp)		# tmph0.0_14, tmph0
 328              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 329 01fc 83264100 		lw	a3,4(sp)		# tmpl0.1_17, tmpl0
 330              	# kianv_stdlib_hdmi.h:96:   while (get_cycles() < lim)
 331 0200 E364F7FE 		bgtu	a5,a4,.L38	#, tmp111, tmph0.0_14,
 332 0204 6394E700 		bne	a5,a4,.L32	#, tmp111, tmph0.0_14,
 333 0208 E3E0C6FE 		bgtu	a2,a3,.L38	#, tmp140, tmpl0.1_17,
 334              	.L32:
 335              	# kianv_stdlib_hdmi.h:106: }
 336 020c 13010101 		addi	sp,sp,16	#,,
 337 0210 67800000 		jr	ra		#
 338              	.L41:
 339 0214 67800000 		ret	
 341              		.align	2
 342              		.globl	sleep
 344              	sleep:
 345              	# kianv_stdlib_hdmi.h:109:   if (sec) wait_cycles(sec * get_cpu_freq());
 346 0218 63020506 		beq	a0,zero,.L53	#, sec,,
 347              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 348 021c B7070030 		li	a5,805306368		# tmp90,
 349              	# kianv_stdlib_hdmi.h:108: void sleep(uint32_t sec) {
 350 0220 130101FF 		addi	sp,sp,-16	#,,
 351              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 352 0224 03A70701 		lw	a4,16(a5)		# _19, MEM[(volatile uint32_t *)805306384B]
 353              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 354              	 #APP
 355              	# 83 "kianv_stdlib_hdmi.h" 1
 356              		rdcycleh a5	# tmp91
 357              	# 0 "" 2
 358              	 #NO_APP
 359 022c 2324F100 		sw	a5,8(sp)	# tmp91, tmph0
 360              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 361              	 #APP
 362              	# 84 "kianv_stdlib_hdmi.h" 1
 363              		rdcycle  a5	# tmp92
 364              	# 0 "" 2
 365              	# kianv_stdlib_hdmi.h:109:   if (sec) wait_cycles(sec * get_cpu_freq());
 366              	 #NO_APP
 367 0234 3305E502 		mul	a0,a0,a4	# tmp101, sec, _19
 368              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 369 0238 2326F100 		sw	a5,12(sp)	# tmp92, tmpl0
 370              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 371 023c 83278100 		lw	a5,8(sp)		# tmph0.0_6, tmph0
 372              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 373 0240 0327C100 		lw	a4,12(sp)		# tmpl0.1_9, tmpl0
 374              	# kianv_stdlib_hdmi.h:95:   uint64_t lim = get_cycles() + wait;
 375 0244 3305A700 		add	a0,a4,a0	# tmp101, tmp136, tmpl0.1_9
 376 0248 3337E500 		sltu	a4,a0,a4	# tmpl0.1_9, tmp105, tmp136
 377 024c 3307F700 		add	a4,a4,a5	# tmph0.0_6, tmp107, tmp105
 378              	.L50:
 379              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 380              	 #APP
 381              	# 83 "kianv_stdlib_hdmi.h" 1
 382              		rdcycleh a5	# tmp108
 383              	# 0 "" 2
 384              	 #NO_APP
 385 0254 2320F100 		sw	a5,0(sp)	# tmp108, tmph0
 386              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 387              	 #APP
 388              	# 84 "kianv_stdlib_hdmi.h" 1
 389              		rdcycle  a5	# tmp109
 390              	# 0 "" 2
 391              	 #NO_APP
 392 025c 2322F100 		sw	a5,4(sp)	# tmp109, tmpl0
 393              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 394 0260 83270100 		lw	a5,0(sp)		# tmph0.0_13, tmph0
 395              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 396 0264 83264100 		lw	a3,4(sp)		# tmpl0.1_16, tmpl0
 397              	# kianv_stdlib_hdmi.h:96:   while (get_cycles() < lim)
 398 0268 E3E4E7FE 		bgtu	a4,a5,.L50	#, tmp107, tmph0.0_13,
 399 026c 6314F700 		bne	a4,a5,.L44	#, tmp107, tmph0.0_13,
 400 0270 E3E0A6FE 		bgtu	a0,a3,.L50	#, tmp136, tmpl0.1_16,
 401              	.L44:
 402              	# kianv_stdlib_hdmi.h:110: }
 403 0274 13010101 		addi	sp,sp,16	#,,
 404 0278 67800000 		jr	ra		#
 405              	.L53:
 406 027c 67800000 		ret	
 408              		.globl	__udivdi3
 409              		.align	2
 410              		.globl	nanoseconds
 412              	nanoseconds:
 413 0280 130101FE 		addi	sp,sp,-32	#,,
 414 0284 232E1100 		sw	ra,28(sp)	#,
 415              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 416              	 #APP
 417              	# 83 "kianv_stdlib_hdmi.h" 1
 418              		rdcycleh a5	# tmp82
 419              	# 0 "" 2
 420              	 #NO_APP
 421 028c 2324F100 		sw	a5,8(sp)	# tmp82, tmph0
 422              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 423              	 #APP
 424              	# 84 "kianv_stdlib_hdmi.h" 1
 425              		rdcycle  a5	# tmp83
 426              	# 0 "" 2
 427              	 #NO_APP
 428 0294 2326F100 		sw	a5,12(sp)	# tmp83, tmpl0
 429              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 430 0298 B7070030 		li	a5,805306368		# tmp85,
 431              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 432 029c 83258100 		lw	a1,8(sp)		# tmph0.0_6, tmph0
 433              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 434 02a0 0325C100 		lw	a0,12(sp)		# tmpl0.1_9, tmpl0
 435              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 436 02a4 03A60701 		lw	a2,16(a5)		# _5, MEM[(volatile uint32_t *)805306384B]
 437              	# kianv_stdlib_hdmi.h:113:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000000);
 438 02a8 B7470F00 		li	a5,999424		# tmp98,
 439 02ac 93870724 		addi	a5,a5,576	#, tmp97, tmp98
 440              	# kianv_stdlib_hdmi.h:113:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000000);
 441 02b0 3356F602 		divu	a2,a2,a5	# tmp97,, _5
 442 02b4 93060000 		li	a3,0		#,
 443 02b8 97000000 		call	__udivdi3		#
 443      E7800000 
 444              	# kianv_stdlib_hdmi.h:114: }
 445 02c0 8320C101 		lw	ra,28(sp)		#,
 446 02c4 13010102 		addi	sp,sp,32	#,,
 447 02c8 67800000 		jr	ra		#
 449              		.align	2
 450              		.globl	milliseconds
 452              	milliseconds:
 453 02cc 130101FE 		addi	sp,sp,-32	#,,
 454 02d0 232E1100 		sw	ra,28(sp)	#,
 455              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 456              	 #APP
 457              	# 83 "kianv_stdlib_hdmi.h" 1
 458              		rdcycleh a5	# tmp82
 459              	# 0 "" 2
 460              	 #NO_APP
 461 02d8 2324F100 		sw	a5,8(sp)	# tmp82, tmph0
 462              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 463              	 #APP
 464              	# 84 "kianv_stdlib_hdmi.h" 1
 465              		rdcycle  a5	# tmp83
 466              	# 0 "" 2
 467              	 #NO_APP
 468 02e0 2326F100 		sw	a5,12(sp)	# tmp83, tmpl0
 469              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 470 02e4 B7070030 		li	a5,805306368		# tmp85,
 471              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 472 02e8 83258100 		lw	a1,8(sp)		# tmph0.0_6, tmph0
 473              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 474 02ec 0325C100 		lw	a0,12(sp)		# tmpl0.1_9, tmpl0
 475              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 476 02f0 03A60701 		lw	a2,16(a5)		# _5, MEM[(volatile uint32_t *)805306384B]
 477              	# kianv_stdlib_hdmi.h:117:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000);
 478 02f4 9307803E 		li	a5,1000		# tmp96,
 479 02f8 93060000 		li	a3,0		#,
 480 02fc 3356F602 		divu	a2,a2,a5	# tmp96,, _5
 481 0300 97000000 		call	__udivdi3		#
 481      E7800000 
 482              	# kianv_stdlib_hdmi.h:118: }
 483 0308 8320C101 		lw	ra,28(sp)		#,
 484 030c 13010102 		addi	sp,sp,32	#,,
 485 0310 67800000 		jr	ra		#
 487              		.align	2
 488              		.globl	seconds
 490              	seconds:
 491 0314 130101FE 		addi	sp,sp,-32	#,,
 492 0318 232E1100 		sw	ra,28(sp)	#,
 493              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 494              	 #APP
 495              	# 83 "kianv_stdlib_hdmi.h" 1
 496              		rdcycleh a5	# tmp81
 497              	# 0 "" 2
 498              	 #NO_APP
 499 0320 2324F100 		sw	a5,8(sp)	# tmp81, tmph0
 500              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 501              	 #APP
 502              	# 84 "kianv_stdlib_hdmi.h" 1
 503              		rdcycle  a5	# tmp82
 504              	# 0 "" 2
 505              	 #NO_APP
 506 0328 2326F100 		sw	a5,12(sp)	# tmp82, tmpl0
 507              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 508 032c B7070030 		li	a5,805306368		# tmp84,
 509              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 510 0330 83258100 		lw	a1,8(sp)		# tmph0.0_5, tmph0
 511              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 512 0334 0325C100 		lw	a0,12(sp)		# tmpl0.1_8, tmpl0
 513              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 514 0338 03A60701 		lw	a2,16(a5)		# _4, MEM[(volatile uint32_t *)805306384B]
 515              	# kianv_stdlib_hdmi.h:121:   return get_cycles() / (uint64_t) (get_cpu_freq());
 516 033c 93060000 		li	a3,0		#,
 517 0340 97000000 		call	__udivdi3		#
 517      E7800000 
 518              	# kianv_stdlib_hdmi.h:122: }
 519 0348 8320C101 		lw	ra,28(sp)		#,
 520 034c 13010102 		addi	sp,sp,32	#,,
 521 0350 67800000 		jr	ra		#
 523              		.align	2
 524              		.globl	putchar
 526              	putchar:
 527              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 528 0354 37070030 		li	a4,805306368		# tmp76,
 529              	.L63:
 530              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 531 0358 83270700 		lw	a5,0(a4)		# _2, MEM[(volatile uint32_t *)805306368B]
 532              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 533 035c E38E07FE 		beq	a5,zero,.L63	#, _2,,
 534              	# kianv_stdlib_hdmi.h:127:   *((volatile uint32_t*) UART_TX) = c;
 535 0360 2320A700 		sw	a0,0(a4)	# c, MEM[(volatile uint32_t *)805306368B]
 536              	# kianv_stdlib_hdmi.h:128:    if (c == 13) {
 537 0364 9307D000 		li	a5,13		# tmp78,
 538 0368 6304F500 		beq	a0,a5,.L70	#, c, tmp78,
 539              	# kianv_stdlib_hdmi.h:133: }
 540 036c 67800000 		ret	
 541              	.L70:
 542              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 543 0370 37070030 		li	a4,805306368		# tmp79,
 544              	.L65:
 545 0374 83270700 		lw	a5,0(a4)		# _8, MEM[(volatile uint32_t *)805306368B]
 546              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 547 0378 E38E07FE 		beq	a5,zero,.L65	#, _8,,
 548              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 549 037c 9307A000 		li	a5,10		# tmp81,
 550 0380 2320F700 		sw	a5,0(a4)	# tmp81, MEM[(volatile uint32_t *)805306368B]
 551              	# kianv_stdlib_hdmi.h:133: }
 552 0384 67800000 		ret	
 554              		.align	2
 555              		.globl	print_chr
 557              	print_chr:
 558              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 559 0388 37070030 		li	a4,805306368		# tmp76,
 560              	.L72:
 561 038c 83270700 		lw	a5,0(a4)		# _3, MEM[(volatile uint32_t *)805306368B]
 562              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 563 0390 E38E07FE 		beq	a5,zero,.L72	#, _3,,
 564              	# kianv_stdlib_hdmi.h:127:   *((volatile uint32_t*) UART_TX) = c;
 565 0394 2320A700 		sw	a0,0(a4)	# ch, MEM[(volatile uint32_t *)805306368B]
 566              	# kianv_stdlib_hdmi.h:128:    if (c == 13) {
 567 0398 9307D000 		li	a5,13		# tmp78,
 568 039c 6304F500 		beq	a0,a5,.L79	#, ch, tmp78,
 569              	# kianv_stdlib_hdmi.h:137: }
 570 03a0 67800000 		ret	
 571              	.L79:
 572              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 573 03a4 37070030 		li	a4,805306368		# tmp79,
 574              	.L74:
 575 03a8 83270700 		lw	a5,0(a4)		# _8, MEM[(volatile uint32_t *)805306368B]
 576              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 577 03ac E38E07FE 		beq	a5,zero,.L74	#, _8,,
 578              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 579 03b0 9307A000 		li	a5,10		# tmp81,
 580 03b4 2320F700 		sw	a5,0(a4)	# tmp81, MEM[(volatile uint32_t *)805306368B]
 581              	# kianv_stdlib_hdmi.h:137: }
 582 03b8 67800000 		ret	
 584              		.align	2
 585              		.globl	print_char
 587              	print_char:
 588 03bc 37070030 		li	a4,805306368		# tmp76,
 589              	.L81:
 590 03c0 83270700 		lw	a5,0(a4)		# _4, MEM[(volatile uint32_t *)805306368B]
 591 03c4 E38E07FE 		beq	a5,zero,.L81	#, _4,,
 592 03c8 2320A700 		sw	a0,0(a4)	# ch, MEM[(volatile uint32_t *)805306368B]
 593 03cc 9307D000 		li	a5,13		# tmp78,
 594 03d0 6304F500 		beq	a0,a5,.L88	#, ch, tmp78,
 595 03d4 67800000 		ret	
 596              	.L88:
 597 03d8 37070030 		li	a4,805306368		# tmp79,
 598              	.L83:
 599 03dc 83270700 		lw	a5,0(a4)		# _6, MEM[(volatile uint32_t *)805306368B]
 600 03e0 E38E07FE 		beq	a5,zero,.L83	#, _6,,
 601 03e4 9307A000 		li	a5,10		# tmp81,
 602 03e8 2320F700 		sw	a5,0(a4)	# tmp81, MEM[(volatile uint32_t *)805306368B]
 603 03ec 67800000 		ret	
 605              		.align	2
 606              		.globl	print_str
 608              	print_str:
 609              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 610 03f0 83460500 		lbu	a3,0(a0)	# _3, *p_6(D)
 611              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 612 03f4 638A0602 		beq	a3,zero,.L89	#, _3,,
 613              	# kianv_stdlib_hdmi.h:145:     while (!*((volatile uint32_t*) UART_READY))
 614 03f8 B7070030 		li	a5,805306368		# tmp78,
 615              	# kianv_stdlib_hdmi.h:128:    if (c == 13) {
 616 03fc 1306D000 		li	a2,13		# tmp81,
 617              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 618 0400 9305A000 		li	a1,10		# tmp85,
 619              	.L91:
 620              	# kianv_stdlib_hdmi.h:145:     while (!*((volatile uint32_t*) UART_READY))
 621 0404 03A70700 		lw	a4,0(a5)		# _1, MEM[(volatile uint32_t *)805306368B]
 622              	# kianv_stdlib_hdmi.h:145:     while (!*((volatile uint32_t*) UART_READY))
 623 0408 E30E07FE 		beq	a4,zero,.L91	#, _1,,
 624              	# kianv_stdlib_hdmi.h:147:     putchar(*(p++));
 625 040c 13051500 		addi	a0,a0,1	#, p, p
 626              	.L92:
 627              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 628 0410 03A70700 		lw	a4,0(a5)		# _9, MEM[(volatile uint32_t *)805306368B]
 629              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 630 0414 E30E07FE 		beq	a4,zero,.L92	#, _9,,
 631              	# kianv_stdlib_hdmi.h:127:   *((volatile uint32_t*) UART_TX) = c;
 632 0418 23A0D700 		sw	a3,0(a5)	# _3, MEM[(volatile uint32_t *)805306368B]
 633              	# kianv_stdlib_hdmi.h:128:    if (c == 13) {
 634 041c 6388C600 		beq	a3,a2,.L94	#, _3, tmp81,
 635              	.L93:
 636              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 637 0420 83460500 		lbu	a3,0(a0)	# _3, MEM[(char *)p_8]
 638              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 639 0424 E39006FE 		bne	a3,zero,.L91	#, _3,,
 640              	.L89:
 641              	# kianv_stdlib_hdmi.h:149: }
 642 0428 67800000 		ret	
 643              	.L94:
 644              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 645 042c 03A70700 		lw	a4,0(a5)		# _14, MEM[(volatile uint32_t *)805306368B]
 646              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 647 0430 E30E07FE 		beq	a4,zero,.L94	#, _14,,
 648              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 649 0434 23A0B700 		sw	a1,0(a5)	# tmp85, MEM[(volatile uint32_t *)805306368B]
 650              	# kianv_stdlib_hdmi.h:133: }
 651 0438 6FF09FFE 		j	.L93		#
 653              		.align	2
 654              		.globl	print_str_ln
 656              	print_str_ln:
 657              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 658 043c 83460500 		lbu	a3,0(a0)	# _11, *p_2(D)
 659              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 660 0440 638A0602 		beq	a3,zero,.L107	#, _11,,
 661              	# kianv_stdlib_hdmi.h:145:     while (!*((volatile uint32_t*) UART_READY))
 662 0444 B7070030 		li	a5,805306368		# tmp80,
 663              	# kianv_stdlib_hdmi.h:128:    if (c == 13) {
 664 0448 1306D000 		li	a2,13		# tmp83,
 665              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 666 044c 9305A000 		li	a1,10		# tmp93,
 667              	.L108:
 668              	# kianv_stdlib_hdmi.h:145:     while (!*((volatile uint32_t*) UART_READY))
 669 0450 03A70700 		lw	a4,0(a5)		# _7, MEM[(volatile uint32_t *)805306368B]
 670              	# kianv_stdlib_hdmi.h:145:     while (!*((volatile uint32_t*) UART_READY))
 671 0454 E30E07FE 		beq	a4,zero,.L108	#, _7,,
 672              	# kianv_stdlib_hdmi.h:147:     putchar(*(p++));
 673 0458 13051500 		addi	a0,a0,1	#, p, p
 674              	.L109:
 675              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 676 045c 03A70700 		lw	a4,0(a5)		# _10, MEM[(volatile uint32_t *)805306368B]
 677              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 678 0460 E30E07FE 		beq	a4,zero,.L109	#, _10,,
 679              	# kianv_stdlib_hdmi.h:127:   *((volatile uint32_t*) UART_TX) = c;
 680 0464 23A0D700 		sw	a3,0(a5)	# _11, MEM[(volatile uint32_t *)805306368B]
 681              	# kianv_stdlib_hdmi.h:128:    if (c == 13) {
 682 0468 638CC602 		beq	a3,a2,.L111	#, _11, tmp83,
 683              	.L110:
 684              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 685 046c 83460500 		lbu	a3,0(a0)	# _11, MEM[(char *)p_9]
 686              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 687 0470 E39006FE 		bne	a3,zero,.L108	#, _11,,
 688              	.L107:
 689              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 690 0474 37070030 		li	a4,805306368		# tmp87,
 691              	.L113:
 692 0478 83270700 		lw	a5,0(a4)		# _4, MEM[(volatile uint32_t *)805306368B]
 693              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 694 047c E38E07FE 		beq	a5,zero,.L113	#, _4,,
 695              	# kianv_stdlib_hdmi.h:127:   *((volatile uint32_t*) UART_TX) = c;
 696 0480 9307D000 		li	a5,13		# tmp89,
 697 0484 2320F700 		sw	a5,0(a4)	# tmp89, MEM[(volatile uint32_t *)805306368B]
 698              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 699 0488 37070030 		li	a4,805306368		# tmp90,
 700              	.L114:
 701 048c 83270700 		lw	a5,0(a4)		# _15, MEM[(volatile uint32_t *)805306368B]
 702              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 703 0490 E38E07FE 		beq	a5,zero,.L114	#, _15,,
 704              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 705 0494 9307A000 		li	a5,10		# tmp92,
 706 0498 2320F700 		sw	a5,0(a4)	# tmp92, MEM[(volatile uint32_t *)805306368B]
 707              	# kianv_stdlib_hdmi.h:154: }
 708 049c 67800000 		ret	
 709              	.L111:
 710              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 711 04a0 03A70700 		lw	a4,0(a5)		# _14, MEM[(volatile uint32_t *)805306368B]
 712              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 713 04a4 E30E07FE 		beq	a4,zero,.L111	#, _14,,
 714              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 715 04a8 23A0B700 		sw	a1,0(a5)	# tmp93, MEM[(volatile uint32_t *)805306368B]
 716              	# kianv_stdlib_hdmi.h:133: }
 717 04ac 6FF01FFC 		j	.L110		#
 719              		.align	2
 720              		.globl	print_dec
 722              	print_dec:
 723 04b0 130101FF 		addi	sp,sp,-16	#,,
 724              	# kianv_stdlib_hdmi.h:160:   char *p = buffer;
 725 04b4 13064100 		addi	a2,sp,4	#, tmp90,
 726 04b8 93070600 		mv	a5,a2	# p, tmp90
 727              	# kianv_stdlib_hdmi.h:162:     *(p++) = val % 10;
 728 04bc 1307A000 		li	a4,10		# tmp91,
 729              	.L130:
 730              	# kianv_stdlib_hdmi.h:161:   while (val || p == buffer) {
 731 04c0 63140500 		bne	a0,zero,.L131	#, val,,
 732              	# kianv_stdlib_hdmi.h:161:   while (val || p == buffer) {
 733 04c4 639CC700 		bne	a5,a2,.L135	#, p, tmp90,
 734              	.L131:
 735              	# kianv_stdlib_hdmi.h:162:     *(p++) = val % 10;
 736 04c8 B376E502 		remu	a3,a0,a4	# tmp91, tmp82, val
 737              	# kianv_stdlib_hdmi.h:162:     *(p++) = val % 10;
 738 04cc 93871700 		addi	a5,a5,1	#, p, p
 739              	# kianv_stdlib_hdmi.h:163:     val = val / 10;
 740 04d0 3355E502 		divu	a0,a0,a4	# tmp91, val, val
 741              	# kianv_stdlib_hdmi.h:162:     *(p++) = val % 10;
 742 04d4 A38FD7FE 		sb	a3,-1(a5)	# tmp82, MEM[(char *)p_17 + 4294967295B]
 743 04d8 6FF09FFE 		j	.L130		#
 744              	.L135:
 745              	# kianv_stdlib_hdmi.h:167:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 746 04dc B7060030 		li	a3,805306368		# tmp88,
 747              	.L132:
 748              	# kianv_stdlib_hdmi.h:167:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 749 04e0 03C7F7FF 		lbu	a4,-1(a5)	# MEM[(char *)p_15], MEM[(char *)p_15]
 750              	# kianv_stdlib_hdmi.h:167:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 751 04e4 9387F7FF 		addi	a5,a5,-1	#, p, p
 752              	# kianv_stdlib_hdmi.h:167:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 753 04e8 13070703 		addi	a4,a4,48	#, _6, MEM[(char *)p_15]
 754              	# kianv_stdlib_hdmi.h:167:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 755 04ec 23A0E600 		sw	a4,0(a3)	# _6, MEM[(volatile uint32_t *)805306368B]
 756              	# kianv_stdlib_hdmi.h:166:   while (p != buffer) {
 757 04f0 E398C7FE 		bne	a5,a2,.L132	#, p, tmp90,
 758              	# kianv_stdlib_hdmi.h:169: }
 759 04f4 13010101 		addi	sp,sp,16	#,,
 760 04f8 67800000 		jr	ra		#
 762              		.align	2
 763              		.globl	print_dec64
 765              	print_dec64:
 766 04fc 130101FE 		addi	sp,sp,-32	#,,
 767              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 768 0500 37DECCCC 		li	t3,-858992640		# tmp256,
 769              	# kianv_stdlib_hdmi.h:173:   char *p = buffer;
 770 0504 930EC100 		addi	t4,sp,12	#, tmp252,
 771              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 772 0508 37030010 		li	t1,268435456		# tmp253,
 773 050c 9308DECC 		addi	a7,t3,-819	#, tmp257, tmp256
 774              	# kianv_stdlib_hdmi.h:171: void print_dec64(uint64_t val) {
 775 0510 13070500 		mv	a4,a0	# val, tmp259
 776 0514 13880500 		mv	a6,a1	# val, tmp260
 777              	# kianv_stdlib_hdmi.h:173:   char *p = buffer;
 778 0518 13860E00 		mv	a2,t4	# p, tmp252
 779              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 780 051c 1303F3FF 		addi	t1,t1,-1	#, tmp254, tmp253
 781 0520 130F5000 		li	t5,5		# tmp255,
 782 0524 130ECECC 		addi	t3,t3,-820	#, tmp258, tmp256
 783              	# kianv_stdlib_hdmi.h:174:   while (val || p == buffer) {
 784 0528 6F008005 		j	.L137		#
 785              	.L138:
 786              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 787 052c B3F7E703 		remu	a5,a5,t5	# tmp255, tmp96, tmp93
 788              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 789 0530 13061600 		addi	a2,a2,1	#, p, p
 790              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 791 0534 B307F740 		sub	a5,a4,a5	# tmp212, val, tmp96
 792 0538 B335F700 		sgtu	a1,a5,a4	# tmp100, tmp212, val
 793 053c B305B840 		sub	a1,a6,a1	# tmp102, val, tmp100
 794 0540 3385C703 		mul	a0,a5,t3	# tmp106, tmp212, tmp258
 795 0544 B3851503 		mul	a1,a1,a7	# tmp103, tmp102, tmp257
 796 0548 B3B61703 		mulhu	a3,a5,a7	# tmp215, tmp212, tmp257
 797 054c B385A500 		add	a1,a1,a0	# tmp106, tmp109, tmp103
 798 0550 B3871703 		mul	a5,a5,a7	# tmp113, tmp212, tmp257
 799 0554 B385D500 		add	a1,a1,a3	# tmp215, tmp114, tmp109
 800 0558 9396F501 		slli	a3,a1,31	#, tmp132, tmp114
 801              	# kianv_stdlib_hdmi.h:176:     val = val / 10;
 802 055c 13D81500 		srli	a6,a1,1	#, val, tmp114
 803              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 804 0560 93D71700 		srli	a5,a5,1	#, tmp222, tmp113
 805 0564 B3E7F600 		or	a5,a3,a5	# tmp222, tmp222, tmp132
 806 0568 13952700 		slli	a0,a5,2	#, tmp226, tmp222
 807 056c 3305F500 		add	a0,a0,a5	# tmp222, tmp228, tmp226
 808 0570 13151500 		slli	a0,a0,1	#, tmp230, tmp228
 809 0574 3305A740 		sub	a0,a4,a0	# tmp232, val, tmp230
 810              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 811 0578 A30FA6FE 		sb	a0,-1(a2)	# tmp232, MEM[(char *)p_17 + 4294967295B]
 812              	# kianv_stdlib_hdmi.h:176:     val = val / 10;
 813 057c 13870700 		mv	a4,a5	# val, tmp222
 814              	.L137:
 815              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 816 0580 93174800 		slli	a5,a6,4	#, tmp87, val
 817 0584 9356C701 		srli	a3,a4,28	#, tmp206, val
 818 0588 B3E6D700 		or	a3,a5,a3	# tmp206, tmp206, tmp87
 819 058c B3F66600 		and	a3,a3,t1	# tmp254, tmp88, tmp206
 820 0590 B3776700 		and	a5,a4,t1	# tmp254, tmp83, val
 821 0594 B387D700 		add	a5,a5,a3	# tmp88, tmp91, tmp83
 822 0598 93558801 		srli	a1,a6,24	#, tmp208, val
 823              	# kianv_stdlib_hdmi.h:174:   while (val || p == buffer) {
 824 059c B3660701 		or	a3,a4,a6	# val, val, val
 825              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 826 05a0 B387B700 		add	a5,a5,a1	# tmp208, tmp93, tmp91
 827              	# kianv_stdlib_hdmi.h:174:   while (val || p == buffer) {
 828 05a4 E39406F8 		bne	a3,zero,.L138	#, val,,
 829              	# kianv_stdlib_hdmi.h:174:   while (val || p == buffer) {
 830 05a8 E302D6F9 		beq	a2,t4,.L138	#, p, tmp252,
 831              	# kianv_stdlib_hdmi.h:180:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 832 05ac 37070030 		li	a4,805306368		# tmp202,
 833              	.L139:
 834              	# kianv_stdlib_hdmi.h:180:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 835 05b0 8347F6FF 		lbu	a5,-1(a2)	# MEM[(char *)p_15], MEM[(char *)p_15]
 836              	# kianv_stdlib_hdmi.h:180:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 837 05b4 1306F6FF 		addi	a2,a2,-1	#, p, p
 838              	# kianv_stdlib_hdmi.h:180:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 839 05b8 93870703 		addi	a5,a5,48	#, _6, MEM[(char *)p_15]
 840              	# kianv_stdlib_hdmi.h:180:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 841 05bc 2320F700 		sw	a5,0(a4)	# _6, MEM[(volatile uint32_t *)805306368B]
 842              	# kianv_stdlib_hdmi.h:179:   while (p != buffer) {
 843 05c0 E318D6FF 		bne	a2,t4,.L139	#, p, tmp252,
 844              	# kianv_stdlib_hdmi.h:182: }
 845 05c4 13010102 		addi	sp,sp,32	#,,
 846 05c8 67800000 		jr	ra		#
 848              		.section	.rodata.str1.4,"aMS",@progbits,1
 849              		.align	2
 850              	.LC0:
 851 0000 30313233 		.string	"0123456789ABCDEF"
 851      34353637 
 851      38394142 
 851      43444546 
 851      00
 852              		.text
 853              		.align	2
 854              		.globl	print_hex
 856              	print_hex:
 857              	# kianv_stdlib_hdmi.h:185:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 858 05cc 9385F5FF 		addi	a1,a1,-1	#, tmp84, tmp96
 859              	# kianv_stdlib_hdmi.h:185:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 860 05d0 93952500 		slli	a1,a1,2	#, i, tmp84
 861              	# kianv_stdlib_hdmi.h:185:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 862 05d4 63C80502 		blt	a1,zero,.L142	#, i,,
 863 05d8 37070000 		lui	a4,%hi(.LC0)	# tmp93,
 864 05dc 1306C0FF 		li	a2,-4		# _7,
 865 05e0 13070700 		addi	a4,a4,%lo(.LC0)	# tmp92, tmp93,
 866              	# kianv_stdlib_hdmi.h:186:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16
 867 05e4 B7060030 		li	a3,805306368		# tmp91,
 868              	.L144:
 869              	# kianv_stdlib_hdmi.h:186:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16
 870 05e8 B357B500 		srl	a5,a0,a1	# i, tmp88, val
 871              	# kianv_stdlib_hdmi.h:186:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16
 872 05ec 93F7F700 		andi	a5,a5,15	#, tmp89, tmp88
 873              	# kianv_stdlib_hdmi.h:186:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16
 874 05f0 B307F700 		add	a5,a4,a5	# tmp89, tmp90, tmp92
 875 05f4 83C70700 		lbu	a5,0(a5)	# _5, "0123456789ABCDEF"[_3]
 876              	# kianv_stdlib_hdmi.h:185:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 877 05f8 9385C5FF 		addi	a1,a1,-4	#, i, i
 878              	# kianv_stdlib_hdmi.h:186:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16
 879 05fc 23A0F600 		sw	a5,0(a3)	# _5, MEM[(volatile uint32_t *)805306368B]
 880              	# kianv_stdlib_hdmi.h:185:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 881 0600 E314B6FE 		bne	a2,a1,.L144	#, _7, i,
 882              	.L142:
 883              	# kianv_stdlib_hdmi.h:188: }
 884 0604 67800000 		ret	
 886              		.align	2
 887              		.globl	setpixel
 889              	setpixel:
 890              	# kianv_stdlib_hdmi.h:197:   const int y_offset = y*80;
 891 0608 93172600 		slli	a5,a2,2	#, tmp82, tmp89
 892 060c 3386C700 		add	a2,a5,a2	# tmp89, y_offset, tmp82
 893 0610 13164600 		slli	a2,a2,4	#, tmp84, y_offset
 894              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 895 0614 3306B600 		add	a2,a2,a1	# tmp88, tmp85, tmp84
 896              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 897 0618 13162600 		slli	a2,a2,2	#, tmp86, tmp85
 898 061c 3305C500 		add	a0,a0,a2	# tmp86, _4, tmp87
 899              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 900 0620 2320D500 		sw	a3,0(a0)	# color, *_4
 901              	# kianv_stdlib_hdmi.h:200: }
 902 0624 67800000 		ret	
 904              		.align	2
 905              		.globl	draw_bresenham
 907              	draw_bresenham:
 908 0628 130101FD 		addi	sp,sp,-48	#,,
 909 062c 232A5101 		sw	s5,20(sp)	#,
 910 0630 930A0500 		mv	s5,a0	# tmp107, fb
 911              	# kianv_stdlib_hdmi.h:205:   int dx =  abs(x1 - x0);
 912 0634 3385B640 		sub	a0,a3,a1	#, x1, x0
 913              	# kianv_stdlib_hdmi.h:203: {
 914 0638 23261102 		sw	ra,44(sp)	#,
 915 063c 23248102 		sw	s0,40(sp)	#,
 916 0640 23229102 		sw	s1,36(sp)	#,
 917 0644 13840500 		mv	s0,a1	# x0, tmp108
 918 0648 93040600 		mv	s1,a2	# y0, tmp109
 919 064c 23202103 		sw	s2,32(sp)	#,
 920 0650 232E3101 		sw	s3,28(sp)	#,
 921 0654 232C4101 		sw	s4,24(sp)	#,
 922 0658 93890600 		mv	s3,a3	# x1, tmp110
 923 065c 138A0700 		mv	s4,a5	# color, tmp112
 924 0660 23286101 		sw	s6,16(sp)	#,
 925 0664 23267101 		sw	s7,12(sp)	#,
 926              	# kianv_stdlib_hdmi.h:203: {
 927 0668 930B0700 		mv	s7,a4	# y1, tmp111
 928              	# kianv_stdlib_hdmi.h:205:   int dx =  abs(x1 - x0);
 929 066c 97000000 		call	abs		#
 929      E7800000 
 930 0674 13090500 		mv	s2,a0	# tmp113,
 931              	# kianv_stdlib_hdmi.h:207:   int dy = -abs(y1 - y0);
 932 0678 33859B40 		sub	a0,s7,s1	#, y1, y0
 933 067c 97000000 		call	abs		#
 933      E7800000 
 934              	# kianv_stdlib_hdmi.h:206:   int sx = x0 < x1 ? 1 : -1;
 935 0684 332B3401 		sgt	s6,s3,s0	# tmp102, x1, x0
 936              	# kianv_stdlib_hdmi.h:208:   int sy = y0 < y1 ? 1 : -1;
 937 0688 B3A67401 		sgt	a3,s7,s1	# tmp105, y1, y0
 938              	# kianv_stdlib_hdmi.h:206:   int sx = x0 < x1 ? 1 : -1;
 939 068c 131B1B00 		slli	s6,s6,1	#, iftmp.5_9, tmp102
 940              	# kianv_stdlib_hdmi.h:208:   int sy = y0 < y1 ? 1 : -1;
 941 0690 93961600 		slli	a3,a3,1	#, iftmp.6_10, tmp105
 942              	# kianv_stdlib_hdmi.h:206:   int sx = x0 < x1 ? 1 : -1;
 943 0694 130BFBFF 		addi	s6,s6,-1	#, iftmp.5_9, iftmp.5_9
 944              	# kianv_stdlib_hdmi.h:207:   int dy = -abs(y1 - y0);
 945 0698 B307A040 		neg	a5,a0	# dy, _3
 946              	# kianv_stdlib_hdmi.h:208:   int sy = y0 < y1 ? 1 : -1;
 947 069c 9386F6FF 		addi	a3,a3,-1	#, iftmp.6_10, iftmp.6_10
 948 06a0 3306A940 		sub	a2,s2,a0	# err, dx, _3
 949 06a4 93982400 		slli	a7,s1,2	#, tmp100, y0
 950              	.L150:
 951              	# kianv_stdlib_hdmi.h:197:   const int y_offset = y*80;
 952 06a8 33889800 		add	a6,a7,s1	# y0, y_offset, tmp100
 953 06ac 13184800 		slli	a6,a6,4	#, tmp97, y_offset
 954              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 955 06b0 33088800 		add	a6,a6,s0	# x0, tmp98, tmp97
 956              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 957 06b4 13182800 		slli	a6,a6,2	#, tmp99, tmp98
 958 06b8 33880A01 		add	a6,s5,a6	# tmp99, _36, fb
 959              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 960 06bc 23204801 		sw	s4,0(a6)	# color, *_36
 961              	# kianv_stdlib_hdmi.h:214:     e2 = 2*err;
 962 06c0 93151600 		slli	a1,a2,1	#, e2, err
 963              	# kianv_stdlib_hdmi.h:213:     if (x0 == x1 && y0 == y1) break;
 964 06c4 63003405 		beq	s0,s3,.L158	#, x0, x1,
 965              	.L151:
 966              	# kianv_stdlib_hdmi.h:215:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 967 06c8 63C6F500 		bgt	a5,a1,.L153	#, dy, e2,
 968 06cc 3306A640 		sub	a2,a2,a0	# err, err, _3
 969              	# kianv_stdlib_hdmi.h:215:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 970 06d0 33046401 		add	s0,s0,s6	# iftmp.5_9, x0, x0
 971              	.L153:
 972              	# kianv_stdlib_hdmi.h:216:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 973 06d4 E34AB9FC 		blt	s2,a1,.L150	#, dx, e2,
 974              	# kianv_stdlib_hdmi.h:216:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 975 06d8 B384D400 		add	s1,s1,a3	# iftmp.6_10, y0, y0
 976 06dc 93982400 		slli	a7,s1,2	#, tmp100, y0
 977              	# kianv_stdlib_hdmi.h:197:   const int y_offset = y*80;
 978 06e0 33889800 		add	a6,a7,s1	# y0, y_offset, tmp100
 979 06e4 13184800 		slli	a6,a6,4	#, tmp97, y_offset
 980              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 981 06e8 33088800 		add	a6,a6,s0	# x0, tmp98, tmp97
 982              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 983 06ec 13182800 		slli	a6,a6,2	#, tmp99, tmp98
 984 06f0 33880A01 		add	a6,s5,a6	# tmp99, _36, fb
 985              	# kianv_stdlib_hdmi.h:216:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 986 06f4 33062601 		add	a2,a2,s2	# dx, err, err
 987              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 988 06f8 23204801 		sw	s4,0(a6)	# color, *_36
 989              	# kianv_stdlib_hdmi.h:214:     e2 = 2*err;
 990 06fc 93151600 		slli	a1,a2,1	#, e2, err
 991              	# kianv_stdlib_hdmi.h:213:     if (x0 == x1 && y0 == y1) break;
 992 0700 E31434FD 		bne	s0,s3,.L151	#, x0, x1,
 993              	.L158:
 994              	# kianv_stdlib_hdmi.h:213:     if (x0 == x1 && y0 == y1) break;
 995 0704 E39274FD 		bne	s1,s7,.L151	#, y0, y1,
 996              	# kianv_stdlib_hdmi.h:218: }
 997 0708 8320C102 		lw	ra,44(sp)		#,
 998 070c 03248102 		lw	s0,40(sp)		#,
 999 0710 83244102 		lw	s1,36(sp)		#,
 1000 0714 03290102 		lw	s2,32(sp)		#,
 1001 0718 8329C101 		lw	s3,28(sp)		#,
 1002 071c 032A8101 		lw	s4,24(sp)		#,
 1003 0720 832A4101 		lw	s5,20(sp)		#,
 1004 0724 032B0101 		lw	s6,16(sp)		#,
 1005 0728 832BC100 		lw	s7,12(sp)		#,
 1006 072c 13010103 		addi	sp,sp,48	#,,
 1007 0730 67800000 		jr	ra		#
 1009              		.globl	__floatsisf
 1010              		.globl	__extendsfdf2
 1011              		.globl	__muldf3
 1012              		.globl	__adddf3
 1013              		.globl	__truncdfsf2
 1014              		.globl	__addsf3
 1015              		.globl	__subdf3
 1016              		.align	2
 1017              		.globl	do_pixel
 1019              	do_pixel:
 1020 0734 130101FD 		addi	sp,sp,-48	#,,
 1021 0738 23261102 		sw	ra,44(sp)	#,
 1022 073c 23248102 		sw	s0,40(sp)	#,
 1023 0740 23229102 		sw	s1,36(sp)	#,
 1024 0744 23202103 		sw	s2,32(sp)	#,
 1025 0748 232E3101 		sw	s3,28(sp)	#,
 1026 074c 13090700 		mv	s2,a4	# B, tmp151
 1027 0750 232C4101 		sw	s4,24(sp)	#,
 1028 0754 232A5101 		sw	s5,20(sp)	#,
 1029 0758 23286101 		sw	s6,16(sp)	#,
 1030 075c 23267101 		sw	s7,12(sp)	#,
 1031 0760 23248101 		sw	s8,8(sp)	#,
 1032 0764 23229101 		sw	s9,4(sp)	#,
 1033              	# plasma_hdmi.c:188: void do_pixel(int i, int j, float *R, float *G, float *B) {
 1034 0768 930B0600 		mv	s7,a2	# R, tmp149
 1035 076c 138B0600 		mv	s6,a3	# G, tmp150
 1036 0770 93840500 		mv	s1,a1	# j, tmp148
 1037              	# plasma_hdmi.c:189:   float x = (float)i;
 1038 0774 97000000 		call	__floatsisf		#
 1038      E7800000 
 1039 077c 13040500 		mv	s0,a0	# tmp152,
 1040              	# plasma_hdmi.c:190:   float y = (float)j;
 1041 0780 13850400 		mv	a0,s1	#, j
 1042 0784 97000000 		call	__floatsisf		#
 1042      E7800000 
 1043 078c 93040500 		mv	s1,a0	# tmp153,
 1044              	# plasma_hdmi.c:191:   *R = 0.5f * (sin(x * 0.1 + f) + 1.0);
 1045 0790 13050400 		mv	a0,s0	#, tmp109
 1046 0794 97000000 		call	__extendsfdf2		#
 1046      E7800000 
 1047 079c B70C0000 		lui	s9,%hi(.LC1)	# tmp112,
 1048 07a0 03A60C00 		lw	a2,%lo(.LC1)(s9)		#,
 1049 07a4 83A64C00 		lw	a3,%lo(.LC1+4)(s9)		#,
 1050              	# plasma_hdmi.c:191:   *R = 0.5f * (sin(x * 0.1 + f) + 1.0);
 1051 07a8 B70A0000 		lui	s5,%hi(f)	# tmp114,
 1052              	# plasma_hdmi.c:191:   *R = 0.5f * (sin(x * 0.1 + f) + 1.0);
 1053 07ac 370A0000 		lui	s4,%hi(.LC2)	# tmp117,
 1054              	# plasma_hdmi.c:191:   *R = 0.5f * (sin(x * 0.1 + f) + 1.0);
 1055 07b0 97000000 		call	__muldf3		#
 1055      E7800000 
 1056 07b8 130C0500 		mv	s8,a0	# tmp170,
 1057              	# plasma_hdmi.c:191:   *R = 0.5f * (sin(x * 0.1 + f) + 1.0);
 1058 07bc 03A50A00 		lw	a0,%lo(f)(s5)		#, f
 1059              	# plasma_hdmi.c:191:   *R = 0.5f * (sin(x * 0.1 + f) + 1.0);
 1060 07c0 93890500 		mv	s3,a1	# tmp165, tmp171
 1061              	# plasma_hdmi.c:191:   *R = 0.5f * (sin(x * 0.1 + f) + 1.0);
 1062 07c4 97000000 		call	__extendsfdf2		#
 1062      E7800000 
 1063 07cc 13060500 		mv	a2,a0	# tmp155,
 1064 07d0 93860500 		mv	a3,a1	#,
 1065 07d4 13050C00 		mv	a0,s8	# tmp176, tmp164
 1066 07d8 93850900 		mv	a1,s3	#, tmp165
 1067 07dc 97000000 		call	__adddf3		#
 1067      E7800000 
 1068 07e4 97000000 		call	sin		#
 1068      E7800000 
 1069              	# plasma_hdmi.c:191:   *R = 0.5f * (sin(x * 0.1 + f) + 1.0);
 1070 07ec 03260A00 		lw	a2,%lo(.LC2)(s4)		#,
 1071 07f0 83264A00 		lw	a3,%lo(.LC2+4)(s4)		#,
 1072              	# plasma_hdmi.c:191:   *R = 0.5f * (sin(x * 0.1 + f) + 1.0);
 1073 07f4 B7090000 		lui	s3,%hi(.LC3)	# tmp119,
 1074              	# plasma_hdmi.c:191:   *R = 0.5f * (sin(x * 0.1 + f) + 1.0);
 1075 07f8 97000000 		call	__adddf3		#
 1075      E7800000 
 1076              	# plasma_hdmi.c:191:   *R = 0.5f * (sin(x * 0.1 + f) + 1.0);
 1077 0800 03A60900 		lw	a2,%lo(.LC3)(s3)		#,
 1078 0804 83A64900 		lw	a3,%lo(.LC3+4)(s3)		#,
 1079 0808 97000000 		call	__muldf3		#
 1079      E7800000 
 1080 0810 97000000 		call	__truncdfsf2		#
 1080      E7800000 
 1081 0818 23A0AB00 		sw	a0,0(s7)	# tmp156, *R_37(D)
 1082              	# plasma_hdmi.c:192:   *G = 0.5f * (sin(y * 0.1 + 2.0 * f) + 1.0);
 1083 081c 03A50A00 		lw	a0,%lo(f)(s5)		#, f
 1084 0820 97000000 		call	__extendsfdf2		#
 1084      E7800000 
 1085 0828 13060500 		mv	a2,a0	# tmp157,
 1086 082c 93860500 		mv	a3,a1	#,
 1087 0830 97000000 		call	__adddf3		#
 1087      E7800000 
 1088 0838 130C0500 		mv	s8,a0	# tmp172,
 1089              	# plasma_hdmi.c:192:   *G = 0.5f * (sin(y * 0.1 + 2.0 * f) + 1.0);
 1090 083c 13850400 		mv	a0,s1	#, tmp110
 1091              	# plasma_hdmi.c:192:   *G = 0.5f * (sin(y * 0.1 + 2.0 * f) + 1.0);
 1092 0840 938B0500 		mv	s7,a1	# tmp167, tmp173
 1093              	# plasma_hdmi.c:192:   *G = 0.5f * (sin(y * 0.1 + 2.0 * f) + 1.0);
 1094 0844 97000000 		call	__extendsfdf2		#
 1094      E7800000 
 1095 084c 03A60C00 		lw	a2,%lo(.LC1)(s9)		#,
 1096 0850 83A64C00 		lw	a3,%lo(.LC1+4)(s9)		#,
 1097 0854 97000000 		call	__muldf3		#
 1097      E7800000 
 1098 085c 13060500 		mv	a2,a0	# tmp159,
 1099 0860 93860500 		mv	a3,a1	#,
 1100              	# plasma_hdmi.c:192:   *G = 0.5f * (sin(y * 0.1 + 2.0 * f) + 1.0);
 1101 0864 13050C00 		mv	a0,s8	# tmp177, tmp166
 1102 0868 93850B00 		mv	a1,s7	#, tmp167
 1103 086c 97000000 		call	__adddf3		#
 1103      E7800000 
 1104 0874 97000000 		call	sin		#
 1104      E7800000 
 1105              	# plasma_hdmi.c:192:   *G = 0.5f * (sin(y * 0.1 + 2.0 * f) + 1.0);
 1106 087c 03260A00 		lw	a2,%lo(.LC2)(s4)		#,
 1107 0880 83264A00 		lw	a3,%lo(.LC2+4)(s4)		#,
 1108 0884 97000000 		call	__adddf3		#
 1108      E7800000 
 1109              	# plasma_hdmi.c:192:   *G = 0.5f * (sin(y * 0.1 + 2.0 * f) + 1.0);
 1110 088c 03A60900 		lw	a2,%lo(.LC3)(s3)		#,
 1111 0890 83A64900 		lw	a3,%lo(.LC3+4)(s3)		#,
 1112 0894 97000000 		call	__muldf3		#
 1112      E7800000 
 1113 089c 97000000 		call	__truncdfsf2		#
 1113      E7800000 
 1114              	# plasma_hdmi.c:193:   *B = 0.5f * (sin((x + y) * 0.05 - 3.0 * f) + 1.0);
 1115 08a4 93850400 		mv	a1,s1	#, tmp110
 1116              	# plasma_hdmi.c:192:   *G = 0.5f * (sin(y * 0.1 + 2.0 * f) + 1.0);
 1117 08a8 2320AB00 		sw	a0,0(s6)	# tmp160, *G_40(D)
 1118              	# plasma_hdmi.c:193:   *B = 0.5f * (sin((x + y) * 0.05 - 3.0 * f) + 1.0);
 1119 08ac 13050400 		mv	a0,s0	#, tmp109
 1120 08b0 97000000 		call	__addsf3		#
 1120      E7800000 
 1121 08b8 97000000 		call	__extendsfdf2		#
 1121      E7800000 
 1122              	# plasma_hdmi.c:193:   *B = 0.5f * (sin((x + y) * 0.05 - 3.0 * f) + 1.0);
 1123 08c0 B7070000 		lui	a5,%hi(.LC4)	# tmp136,
 1124 08c4 03A60700 		lw	a2,%lo(.LC4)(a5)		#,
 1125 08c8 83A64700 		lw	a3,%lo(.LC4+4)(a5)		#,
 1126 08cc 97000000 		call	__muldf3		#
 1126      E7800000 
 1127 08d4 93040500 		mv	s1,a0	# tmp174,
 1128              	# plasma_hdmi.c:193:   *B = 0.5f * (sin((x + y) * 0.05 - 3.0 * f) + 1.0);
 1129 08d8 03A50A00 		lw	a0,%lo(f)(s5)		#, f
 1130              	# plasma_hdmi.c:193:   *B = 0.5f * (sin((x + y) * 0.05 - 3.0 * f) + 1.0);
 1131 08dc 13840500 		mv	s0,a1	# tmp169, tmp175
 1132              	# plasma_hdmi.c:193:   *B = 0.5f * (sin((x + y) * 0.05 - 3.0 * f) + 1.0);
 1133 08e0 97000000 		call	__extendsfdf2		#
 1133      E7800000 
 1134 08e8 B7070000 		lui	a5,%hi(.LC5)	# tmp140,
 1135 08ec 03A60700 		lw	a2,%lo(.LC5)(a5)		#,
 1136 08f0 83A64700 		lw	a3,%lo(.LC5+4)(a5)		#,
 1137 08f4 97000000 		call	__muldf3		#
 1137      E7800000 
 1138 08fc 13060500 		mv	a2,a0	# tmp162,
 1139 0900 93860500 		mv	a3,a1	#,
 1140              	# plasma_hdmi.c:193:   *B = 0.5f * (sin((x + y) * 0.05 - 3.0 * f) + 1.0);
 1141 0904 13850400 		mv	a0,s1	# tmp178, tmp168
 1142 0908 93050400 		mv	a1,s0	#, tmp169
 1143 090c 97000000 		call	__subdf3		#
 1143      E7800000 
 1144 0914 97000000 		call	sin		#
 1144      E7800000 
 1145              	# plasma_hdmi.c:193:   *B = 0.5f * (sin((x + y) * 0.05 - 3.0 * f) + 1.0);
 1146 091c 03260A00 		lw	a2,%lo(.LC2)(s4)		#,
 1147 0920 83264A00 		lw	a3,%lo(.LC2+4)(s4)		#,
 1148 0924 97000000 		call	__adddf3		#
 1148      E7800000 
 1149              	# plasma_hdmi.c:193:   *B = 0.5f * (sin((x + y) * 0.05 - 3.0 * f) + 1.0);
 1150 092c 03A60900 		lw	a2,%lo(.LC3)(s3)		#,
 1151 0930 83A64900 		lw	a3,%lo(.LC3+4)(s3)		#,
 1152 0934 97000000 		call	__muldf3		#
 1152      E7800000 
 1153 093c 97000000 		call	__truncdfsf2		#
 1153      E7800000 
 1154              	# plasma_hdmi.c:194: }
 1155 0944 8320C102 		lw	ra,44(sp)		#,
 1156 0948 03248102 		lw	s0,40(sp)		#,
 1157              	# plasma_hdmi.c:193:   *B = 0.5f * (sin((x + y) * 0.05 - 3.0 * f) + 1.0);
 1158 094c 2320A900 		sw	a0,0(s2)	# tmp163, *B_43(D)
 1159              	# plasma_hdmi.c:194: }
 1160 0950 83244102 		lw	s1,36(sp)		#,
 1161 0954 03290102 		lw	s2,32(sp)		#,
 1162 0958 8329C101 		lw	s3,28(sp)		#,
 1163 095c 032A8101 		lw	s4,24(sp)		#,
 1164 0960 832A4101 		lw	s5,20(sp)		#,
 1165 0964 032B0101 		lw	s6,16(sp)		#,
 1166 0968 832BC100 		lw	s7,12(sp)		#,
 1167 096c 032C8100 		lw	s8,8(sp)		#,
 1168 0970 832C4100 		lw	s9,4(sp)		#,
 1169 0974 13010103 		addi	sp,sp,48	#,,
 1170 0978 67800000 		jr	ra		#
 1172              		.globl	__ltsf2
 1173              		.globl	__gtsf2
 1174              		.globl	__mulsf3
 1175              		.globl	__fixunssfsi
 1176              		.section	.text.startup,"ax",@progbits
 1177              		.align	2
 1178              		.globl	main
 1180              	main:
 1181 0000 130101F9 		addi	sp,sp,-112	#,,
 1182              	# plasma_hdmi.c:143:   f = (f > 1.0f) ? 1.0f : f;
 1183 0004 B7070000 		lui	a5,%hi(.LC6)	# tmp253,
 1184              	# plasma_hdmi.c:196: int main() {
 1185 0008 232A5105 		sw	s5,84(sp)	#,
 1186              	# plasma_hdmi.c:143:   f = (f > 1.0f) ? 1.0f : f;
 1187 000c 83AA0700 		lw	s5,%lo(.LC6)(a5)		# tmp211,
 1188              	# plasma_hdmi.c:196: int main() {
 1189 0010 23261106 		sw	ra,108(sp)	#,
 1190 0014 23248106 		sw	s0,104(sp)	#,
 1191 0018 23229106 		sw	s1,100(sp)	#,
 1192 001c 23202107 		sw	s2,96(sp)	#,
 1193 0020 232E3105 		sw	s3,92(sp)	#,
 1194 0024 232C4105 		sw	s4,88(sp)	#,
 1195 0028 23286105 		sw	s6,80(sp)	#,
 1196 002c 23267105 		sw	s7,76(sp)	#,
 1197 0030 23248105 		sw	s8,72(sp)	#,
 1198 0034 23229105 		sw	s9,68(sp)	#,
 1199 0038 2320A105 		sw	s10,64(sp)	#,
 1200 003c 232EB103 		sw	s11,60(sp)	#,
 1201              	.L177:
 1202 0040 B7070010 		li	a5,268435456		# ivtmp.176,
 1203 0044 2322F100 		sw	a5,4(sp)	# ivtmp.176, %sfp
 1204 0048 93070005 		li	a5,80		# ivtmp.173,
 1205 004c 23240100 		sw	zero,8(sp)	#, %sfp
 1206 0050 2326F100 		sw	a5,12(sp)	# ivtmp.173, %sfp
 1207              	# plasma_hdmi.c:161:   for (int j = 0; j < height; j += 2) {
 1208 0054 930C0000 		li	s9,0		# j,
 1209              	.L162:
 1210 0058 8327C100 		lw	a5,12(sp)		# ivtmp.173, %sfp
 1211 005c 03278100 		lw	a4,8(sp)		# ivtmp.174, %sfp
 1212              	# plasma_hdmi.c:196: int main() {
 1213 0060 032A4100 		lw	s4,4(sp)		# ivtmp.162, %sfp
 1214 0064 138D1C00 		addi	s10,s9,1	#, _110, j
 1215 0068 B387E740 		sub	a5,a5,a4	# _129, ivtmp.173, ivtmp.174
 1216 006c 2320F100 		sw	a5,0(sp)	# _129, %sfp
 1217              	# plasma_hdmi.c:162:     for (int i = 0; i < width; i++) {
 1218 0070 93040000 		li	s1,0		# i,
 1219 0074 6F000019 		j	.L175		#
 1220              	.L200:
 1221              	# plasma_hdmi.c:143:   f = (f > 1.0f) ? 1.0f : f;
 1222 0078 93850A00 		mv	a1,s5	#, tmp211
 1223 007c 13050400 		mv	a0,s0	#, fr1.12_14
 1224 0080 97000000 		call	__gtsf2		#
 1224      E7800000 
 1225 0088 B709FF00 		li	s3,16711680		# prephitmp_64,
 1226 008c 130BF00F 		li	s6,255		# _111,
 1227 0090 6350A024 		ble	a0,zero,.L194	#, tmp233,,
 1228              	.L163:
 1229              	# plasma_hdmi.c:165:       g1 = tty_graphics_ftoi(fg1);
 1230 0094 0324C101 		lw	s0,28(sp)		# fg1.13_19, fg1
 1231              	# plasma_hdmi.c:142:   f = (f < 0.0f) ? 0.0f : f;
 1232 0098 93050000 		mv	a1,zero	#,
 1233 009c 930B0000 		li	s7,0		# _136,
 1234 00a0 13050400 		mv	a0,s0	#, fg1.13_19
 1235 00a4 97000000 		call	__ltsf2		#
 1235      E7800000 
 1236 00ac 63440502 		blt	a0,zero,.L164	#, tmp235,,
 1237              	# plasma_hdmi.c:143:   f = (f > 1.0f) ? 1.0f : f;
 1238 00b0 93850A00 		mv	a1,s5	#, tmp211
 1239 00b4 13050400 		mv	a0,s0	#, fg1.13_19
 1240 00b8 97000000 		call	__gtsf2		#
 1240      E7800000 
 1241 00c0 6356A02C 		ble	a0,zero,.L191	#, tmp236,,
 1242              	# plasma_hdmi.c:86:     setpixel(FRAMEBUFFER, x, y, r1 << 16 | g1 << 8 | b1);
 1243 00c4 B7070100 		li	a5,65536		# tmp142,
 1244 00c8 938707F0 		addi	a5,a5,-256	#, tmp141, tmp142
 1245 00cc B3E9F900 		or	s3,s3,a5	# tmp141, prephitmp_64, prephitmp_64
 1246 00d0 930BF00F 		li	s7,255		# _136,
 1247              	.L164:
 1248              	# plasma_hdmi.c:166:       b1 = tty_graphics_ftoi(fb1);
 1249 00d4 03240102 		lw	s0,32(sp)		# fb1.14_24, fb1
 1250              	# plasma_hdmi.c:142:   f = (f < 0.0f) ? 0.0f : f;
 1251 00d8 93050000 		mv	a1,zero	#,
 1252 00dc 130C0000 		li	s8,0		# _149,
 1253 00e0 13050400 		mv	a0,s0	#, fb1.14_24
 1254 00e4 97000000 		call	__ltsf2		#
 1254      E7800000 
 1255 00ec 63400502 		blt	a0,zero,.L167	#, tmp238,,
 1256              	# plasma_hdmi.c:143:   f = (f > 1.0f) ? 1.0f : f;
 1257 00f0 93850A00 		mv	a1,s5	#, tmp211
 1258 00f4 13050400 		mv	a0,s0	#, fb1.14_24
 1259 00f8 97000000 		call	__gtsf2		#
 1259      E7800000 
 1260 0100 6352A026 		ble	a0,zero,.L192	#, tmp239,,
 1261              	# plasma_hdmi.c:86:     setpixel(FRAMEBUFFER, x, y, r1 << 16 | g1 << 8 | b1);
 1262 0104 93E9F90F 		ori	s3,s3,255	#, prephitmp_64, prephitmp_64
 1263 0108 130CF00F 		li	s8,255		# _149,
 1264              	.L167:
 1265              	# plasma_hdmi.c:167:       do_pixel(i, j + 1, &fr2, &fg2, &fb2);
 1266 010c 93050D00 		mv	a1,s10	#, _110
 1267 0110 13850400 		mv	a0,s1	#, i
 1268 0114 1307C102 		addi	a4,sp,44	#, tmp262,
 1269 0118 93068102 		addi	a3,sp,40	#, tmp263,
 1270 011c 13064102 		addi	a2,sp,36	#, tmp264,
 1271 0120 97000000 		call	do_pixel		#
 1271      E7800000 
 1272              	# plasma_hdmi.c:168:       r2 = tty_graphics_ftoi(fr2);
 1273 0128 03294102 		lw	s2,36(sp)		# fr2.15_30, fr2
 1274              	# plasma_hdmi.c:142:   f = (f < 0.0f) ? 0.0f : f;
 1275 012c 93050000 		mv	a1,zero	#,
 1276 0130 13040000 		li	s0,0		# prephitmp_159,
 1277 0134 13050900 		mv	a0,s2	#, fr2.15_30
 1278 0138 97000000 		call	__ltsf2		#
 1278      E7800000 
 1279 0140 634E0500 		blt	a0,zero,.L170	#, tmp241,,
 1280              	# plasma_hdmi.c:143:   f = (f > 1.0f) ? 1.0f : f;
 1281 0144 93850A00 		mv	a1,s5	#, tmp211
 1282 0148 13050900 		mv	a0,s2	#, fr2.15_30
 1283 014c 97000000 		call	__gtsf2		#
 1283      E7800000 
 1284 0154 1304F00F 		li	s0,255		# prephitmp_159,
 1285 0158 6354A01E 		ble	a0,zero,.L195	#, tmp242,,
 1286              	.L170:
 1287              	# plasma_hdmi.c:169:       g2 = tty_graphics_ftoi(fg2);
 1288 015c 832D8102 		lw	s11,40(sp)		# fg2.16_35, fg2
 1289              	# plasma_hdmi.c:142:   f = (f < 0.0f) ? 0.0f : f;
 1290 0160 93050000 		mv	a1,zero	#,
 1291 0164 13090000 		li	s2,0		# prephitmp_163,
 1292 0168 13850D00 		mv	a0,s11	#, fg2.16_35
 1293 016c 97000000 		call	__ltsf2		#
 1293      E7800000 
 1294 0174 634E0500 		blt	a0,zero,.L171	#, tmp244,,
 1295              	# plasma_hdmi.c:143:   f = (f > 1.0f) ? 1.0f : f;
 1296 0178 93850A00 		mv	a1,s5	#, tmp211
 1297 017c 13850D00 		mv	a0,s11	#, fg2.16_35
 1298 0180 97000000 		call	__gtsf2		#
 1298      E7800000 
 1299 0188 1309F00F 		li	s2,255		# prephitmp_163,
 1300 018c 6358A018 		ble	a0,zero,.L196	#, tmp245,,
 1301              	.L171:
 1302              	# plasma_hdmi.c:170:       b2 = tty_graphics_ftoi(fb2);
 1303 0190 832DC102 		lw	s11,44(sp)		# fb2.17_40, fb2
 1304              	# plasma_hdmi.c:142:   f = (f < 0.0f) ? 0.0f : f;
 1305 0194 93050000 		mv	a1,zero	#,
 1306 0198 13850D00 		mv	a0,s11	#, fb2.17_40
 1307 019c 97000000 		call	__ltsf2		#
 1307      E7800000 
 1308 01a4 13070000 		li	a4,0		# prephitmp_167,
 1309 01a8 63400502 		blt	a0,zero,.L172	#, tmp247,,
 1310              	# plasma_hdmi.c:143:   f = (f > 1.0f) ? 1.0f : f;
 1311 01ac B7070000 		lui	a5,%hi(.LC6)	# tmp267,
 1312 01b0 83A50700 		lw	a1,%lo(.LC6)(a5)		#,
 1313 01b4 13850D00 		mv	a0,s11	#, fb2.17_40
 1314 01b8 97000000 		call	__gtsf2		#
 1314      E7800000 
 1315 01c0 1307F00F 		li	a4,255		# prephitmp_167,
 1316 01c4 635AA012 		ble	a0,zero,.L197	#, tmp248,,
 1317              	.L172:
 1318              	# plasma_hdmi.c:89:     setpixel(FRAMEBUFFER, x + 1, y + 1, r2 << 16 | g2 << 8 | b2);
 1319 01c8 93841400 		addi	s1,s1,1	#, i, i
 1320              	# plasma_hdmi.c:84:   if ((r2 == r1) && (g2 == g1) && (b2 == b1)) {
 1321 01cc 630C8B06 		beq	s6,s0,.L198	#, _111, prephitmp_159,
 1322              	.L173:
 1323 01d0 83270100 		lw	a5,0(sp)		# _129, %sfp
 1324              	# plasma_hdmi.c:89:     setpixel(FRAMEBUFFER, x + 1, y + 1, r2 << 16 | g2 << 8 | b2);
 1325 01d4 13140401 		slli	s0,s0,16	#, tmp183, prephitmp_159
 1326              	# plasma_hdmi.c:89:     setpixel(FRAMEBUFFER, x + 1, y + 1, r2 << 16 | g2 << 8 | b2);
 1327 01d8 13198900 		slli	s2,s2,8	#, tmp184, prephitmp_163
 1328 01dc 93871700 		addi	a5,a5,1	#, tmp186, _129
 1329              	# plasma_hdmi.c:89:     setpixel(FRAMEBUFFER, x + 1, y + 1, r2 << 16 | g2 << 8 | b2);
 1330 01e0 33642401 		or	s0,s0,s2	# tmp184, tmp185, tmp183
 1331 01e4 93972700 		slli	a5,a5,2	#, tmp187, tmp186
 1332 01e8 B3874701 		add	a5,a5,s4	# ivtmp.162, _125, tmp187
 1333              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 1334 01ec 23203A01 		sw	s3,0(s4)	# prephitmp_64, *_187
 1335              	# plasma_hdmi.c:89:     setpixel(FRAMEBUFFER, x + 1, y + 1, r2 << 16 | g2 << 8 | b2);
 1336 01f0 3364E400 		or	s0,s0,a4	# prephitmp_167, _88, tmp185
 1337              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 1338 01f4 23A08700 		sw	s0,0(a5)	# _88, *_125
 1339              	# plasma_hdmi.c:162:     for (int i = 0; i < width; i++) {
 1340 01f8 9307F004 		li	a5,79		# tmp188,
 1341 01fc 130A4A00 		addi	s4,s4,4	#, ivtmp.162, ivtmp.162
 1342 0200 638EF404 		beq	s1,a5,.L199	#, i, tmp188,
 1343              	.L175:
 1344              	# plasma_hdmi.c:163:       do_pixel(i, j, &fr1, &fg1, &fb1);
 1345 0204 93850C00 		mv	a1,s9	#, j
 1346 0208 13850400 		mv	a0,s1	#, i
 1347 020c 13070102 		addi	a4,sp,32	#, tmp256,
 1348 0210 9306C101 		addi	a3,sp,28	#, tmp257,
 1349 0214 13068101 		addi	a2,sp,24	#, tmp258,
 1350 0218 97000000 		call	do_pixel		#
 1350      E7800000 
 1351              	# plasma_hdmi.c:164:       r1 = tty_graphics_ftoi(fr1);
 1352 0220 03248101 		lw	s0,24(sp)		# fr1.12_14, fr1
 1353              	# plasma_hdmi.c:142:   f = (f < 0.0f) ? 0.0f : f;
 1354 0224 93050000 		mv	a1,zero	#,
 1355 0228 13050400 		mv	a0,s0	#, fr1.12_14
 1356 022c 97000000 		call	__ltsf2		#
 1356      E7800000 
 1357 0234 E35205E4 		bge	a0,zero,.L200	#, tmp232,,
 1358 0238 93090000 		li	s3,0		# prephitmp_64,
 1359 023c 130B0000 		li	s6,0		# _111,
 1360 0240 6FF05FE5 		j	.L163		#
 1361              	.L198:
 1362              	# plasma_hdmi.c:84:   if ((r2 == r1) && (g2 == g1) && (b2 == b1)) {
 1363 0244 E3962BF9 		bne	s7,s2,.L173	#, _136, prephitmp_163,
 1364              	# plasma_hdmi.c:84:   if ((r2 == r1) && (g2 == g1) && (b2 == b1)) {
 1365 0248 E314ECF8 		bne	s8,a4,.L173	#, _149, prephitmp_167,
 1366              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 1367 024c 23203A01 		sw	s3,0(s4)	# prephitmp_64, *_187
 1368              	# plasma_hdmi.c:162:     for (int i = 0; i < width; i++) {
 1369 0250 9307F004 		li	a5,79		# tmp188,
 1370 0254 130A4A00 		addi	s4,s4,4	#, ivtmp.162, ivtmp.162
 1371 0258 E396F4FA 		bne	s1,a5,.L175	#, i, tmp188,
 1372              	.L199:
 1373              	# plasma_hdmi.c:161:   for (int j = 0; j < height; j += 2) {
 1374 025c 0327C100 		lw	a4,12(sp)		# ivtmp.173, %sfp
 1375              	# plasma_hdmi.c:161:   for (int j = 0; j < height; j += 2) {
 1376 0260 938C2C00 		addi	s9,s9,2	#, j, j
 1377              	# plasma_hdmi.c:161:   for (int j = 0; j < height; j += 2) {
 1378 0264 9307C003 		li	a5,60		# tmp189,
 1379 0268 1307070A 		addi	a4,a4,160	#, ivtmp.173, ivtmp.173
 1380 026c 2326E100 		sw	a4,12(sp)	# ivtmp.173, %sfp
 1381 0270 03278100 		lw	a4,8(sp)		# ivtmp.174, %sfp
 1382 0274 1307070A 		addi	a4,a4,160	#, ivtmp.174, ivtmp.174
 1383 0278 2324E100 		sw	a4,8(sp)	# ivtmp.174, %sfp
 1384 027c 03274100 		lw	a4,4(sp)		# ivtmp.176, %sfp
 1385 0280 13070728 		addi	a4,a4,640	#, ivtmp.176, ivtmp.176
 1386 0284 2322E100 		sw	a4,4(sp)	# ivtmp.176, %sfp
 1387 0288 E398FCDC 		bne	s9,a5,.L162	#, j, tmp189,
 1388              	# plasma_hdmi.c:202:     f += 0.1;
 1389 028c 37040000 		lui	s0,%hi(f)	# tmp279,
 1390 0290 03250400 		lw	a0,%lo(f)(s0)		#, f
 1391 0294 97000000 		call	__extendsfdf2		#
 1391      E7800000 
 1392 029c B7070000 		lui	a5,%hi(.LC1)	# tmp280,
 1393 02a0 03A60700 		lw	a2,%lo(.LC1)(a5)		#,
 1394 02a4 83A64700 		lw	a3,%lo(.LC1+4)(a5)		#,
 1395 02a8 97000000 		call	__adddf3		#
 1395      E7800000 
 1396 02b0 97000000 		call	__truncdfsf2		#
 1396      E7800000 
 1397              	# plasma_hdmi.c:203:     ++frame;
 1398 02b8 37070000 		lui	a4,%hi(frame)	# tmp281,
 1399 02bc 83270700 		lw	a5,%lo(frame)(a4)		# frame, frame
 1400              	# plasma_hdmi.c:202:     f += 0.1;
 1401 02c0 2320A400 		sw	a0,%lo(f)(s0)	# tmp250, f
 1402              	# plasma_hdmi.c:203:     ++frame;
 1403 02c4 93871700 		addi	a5,a5,1	#, tmp198, frame
 1404 02c8 2320F700 		sw	a5,%lo(frame)(a4)	# tmp198, frame
 1405 02cc 6FF05FD7 		j	.L177		#
 1406              	.L194:
 1407              	# plasma_hdmi.c:144:   return (uint8_t)(255.0f * f);
 1408 02d0 B7070000 		lui	a5,%hi(.LC7)	# tmp259,
 1409 02d4 83A50700 		lw	a1,%lo(.LC7)(a5)		#,
 1410 02d8 13050400 		mv	a0,s0	#, fr1.12_14
 1411 02dc 97000000 		call	__mulsf3		#
 1411      E7800000 
 1412              	# plasma_hdmi.c:144:   return (uint8_t)(255.0f * f);
 1413 02e4 97000000 		call	__fixunssfsi		#
 1413      E7800000 
 1414 02ec 137BF50F 		andi	s6,a0,0xff	# _111, tmp234
 1415              	# plasma_hdmi.c:86:     setpixel(FRAMEBUFFER, x, y, r1 << 16 | g1 << 8 | b1);
 1416 02f0 93190B01 		slli	s3,s6,16	#, prephitmp_64, _111
 1417 02f4 6FF01FDA 		j	.L163		#
 1418              	.L197:
 1419              	# plasma_hdmi.c:144:   return (uint8_t)(255.0f * f);
 1420 02f8 B7070000 		lui	a5,%hi(.LC7)	# tmp268,
 1421 02fc 83A50700 		lw	a1,%lo(.LC7)(a5)		#,
 1422 0300 13850D00 		mv	a0,s11	#, fb2.17_40
 1423 0304 97000000 		call	__mulsf3		#
 1423      E7800000 
 1424              	# plasma_hdmi.c:144:   return (uint8_t)(255.0f * f);
 1425 030c 97000000 		call	__fixunssfsi		#
 1425      E7800000 
 1426 0314 1377F50F 		andi	a4,a0,0xff	# prephitmp_167, tmp249
 1427 0318 6FF01FEB 		j	.L172		#
 1428              	.L196:
 1429              	# plasma_hdmi.c:144:   return (uint8_t)(255.0f * f);
 1430 031c B7070000 		lui	a5,%hi(.LC7)	# tmp266,
 1431 0320 83A50700 		lw	a1,%lo(.LC7)(a5)		#,
 1432 0324 13850D00 		mv	a0,s11	#, fg2.16_35
 1433 0328 97000000 		call	__mulsf3		#
 1433      E7800000 
 1434              	# plasma_hdmi.c:144:   return (uint8_t)(255.0f * f);
 1435 0330 97000000 		call	__fixunssfsi		#
 1435      E7800000 
 1436 0338 1379F50F 		andi	s2,a0,0xff	# prephitmp_163, tmp246
 1437 033c 6FF05FE5 		j	.L171		#
 1438              	.L195:
 1439              	# plasma_hdmi.c:144:   return (uint8_t)(255.0f * f);
 1440 0340 B7070000 		lui	a5,%hi(.LC7)	# tmp265,
 1441 0344 83A50700 		lw	a1,%lo(.LC7)(a5)		#,
 1442 0348 13050900 		mv	a0,s2	#, fr2.15_30
 1443 034c 97000000 		call	__mulsf3		#
 1443      E7800000 
 1444              	# plasma_hdmi.c:144:   return (uint8_t)(255.0f * f);
 1445 0354 97000000 		call	__fixunssfsi		#
 1445      E7800000 
 1446 035c 1374F50F 		andi	s0,a0,0xff	# prephitmp_159, tmp243
 1447 0360 6FF0DFDF 		j	.L170		#
 1448              	.L192:
 1449              	# plasma_hdmi.c:144:   return (uint8_t)(255.0f * f);
 1450 0364 B7070000 		lui	a5,%hi(.LC7)	# tmp261,
 1451 0368 83A50700 		lw	a1,%lo(.LC7)(a5)		#,
 1452 036c 13050400 		mv	a0,s0	#, fb1.14_24
 1453 0370 97000000 		call	__mulsf3		#
 1453      E7800000 
 1454              	# plasma_hdmi.c:144:   return (uint8_t)(255.0f * f);
 1455 0378 97000000 		call	__fixunssfsi		#
 1455      E7800000 
 1456 0380 137CF50F 		andi	s8,a0,0xff	# _149, tmp240
 1457              	# plasma_hdmi.c:86:     setpixel(FRAMEBUFFER, x, y, r1 << 16 | g1 << 8 | b1);
 1458 0384 B3E98901 		or	s3,s3,s8	# _149, prephitmp_64, prephitmp_64
 1459 0388 6FF05FD8 		j	.L167		#
 1460              	.L191:
 1461              	# plasma_hdmi.c:144:   return (uint8_t)(255.0f * f);
 1462 038c B7070000 		lui	a5,%hi(.LC7)	# tmp260,
 1463 0390 83A50700 		lw	a1,%lo(.LC7)(a5)		#,
 1464 0394 13050400 		mv	a0,s0	#, fg1.13_19
 1465 0398 97000000 		call	__mulsf3		#
 1465      E7800000 
 1466              	# plasma_hdmi.c:144:   return (uint8_t)(255.0f * f);
 1467 03a0 97000000 		call	__fixunssfsi		#
 1467      E7800000 
 1468 03a8 937BF50F 		andi	s7,a0,0xff	# _136, tmp237
 1469              	# plasma_hdmi.c:86:     setpixel(FRAMEBUFFER, x, y, r1 << 16 | g1 << 8 | b1);
 1470 03ac 93978B00 		slli	a5,s7,8	#, tmp147, _136
 1471              	# plasma_hdmi.c:86:     setpixel(FRAMEBUFFER, x, y, r1 << 16 | g1 << 8 | b1);
 1472 03b0 B3E9F900 		or	s3,s3,a5	# tmp147, prephitmp_64, prephitmp_64
 1473 03b4 6FF01FD2 		j	.L164		#
 1475              		.globl	f
 1476              		.globl	frame
 1477              		.section	.srodata.cst8,"aM",@progbits,8
 1478              		.align	3
 1479              	.LC1:
 1480 0000 9A999999 		.word	-1717986918
 1481 0004 9999B93F 		.word	1069128089
 1482              		.align	3
 1483              	.LC2:
 1484 0008 00000000 		.word	0
 1485 000c 0000F03F 		.word	1072693248
 1486              		.align	3
 1487              	.LC3:
 1488 0010 00000000 		.word	0
 1489 0014 0000E03F 		.word	1071644672
 1490              		.align	3
 1491              	.LC4:
 1492 0018 9A999999 		.word	-1717986918
 1493 001c 9999A93F 		.word	1068079513
 1494              		.align	3
 1495              	.LC5:
 1496 0020 00000000 		.word	0
 1497 0024 00000840 		.word	1074266112
 1498              		.section	.srodata.cst4,"aM",@progbits,4
 1499              		.align	2
 1500              	.LC6:
 1501 0000 0000803F 		.word	1065353216
 1502              		.align	2
 1503              	.LC7:
 1504 0004 00007F43 		.word	1132396544
 1505              		.section	.sbss,"aw",@nobits
 1506              		.align	2
 1509              	f:
 1510 0000 00000000 		.zero	4
 1513              	frame:
 1514 0004 00000000 		.zero	4
 1515              		.ident	"GCC: (GNU) 11.1.0"
