   1              		.file	"main_mandel_hdmi.c"
   2              		.option nopic
   3              		.attribute arch, "rv32i2p0_m2p0"
   4              		.attribute unaligned_access, 0
   5              		.attribute stack_align, 16
   6              	# GNU C17 (GCC) version 11.1.0 (riscv32-unknown-elf)
   7              	#	compiled by GNU C version 9.3.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl ve
   8              	# warning: GMP header version 6.2.0 differs from library version 6.3.0.
   9              	# warning: MPFR header version 4.0.2 differs from library version 4.2.1.
  10              	# warning: MPC header version 1.1.0 differs from library version 1.3.1.
  11              	# GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
  12              	# options passed: -march=rv32im -mabi=ilp32 -mtune=rocket -march=rv32im -O3 -fno-pic -fno-stack-pro
  13              		.text
  14              		.align	2
  15              		.globl	dma_action
  17              	dma_action:
  18              	# kianv_stdlib_hdmi.h:50:   *( (volatile uint32_t*) DMA_SRC  ) = src;
  19 0000 B7070030 		li	a5,805306368		# tmp77,
  20 0004 23A6A702 		sw	a0,44(a5)	# src, MEM[(volatile uint32_t *)805306412B]
  21              	# kianv_stdlib_hdmi.h:51:   *( (volatile uint32_t*) DMA_DST  ) = dst;
  22 0008 23A8B702 		sw	a1,48(a5)	# dst, MEM[(volatile uint32_t *)805306416B]
  23              	# kianv_stdlib_hdmi.h:52:   *( (volatile uint32_t*) DMA_LEN  ) = len;
  24 000c 23AAC702 		sw	a2,52(a5)	# len, MEM[(volatile uint32_t *)805306420B]
  25              	# kianv_stdlib_hdmi.h:53:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
  26 0010 23ACD702 		sw	a3,56(a5)	# ctrl, MEM[(volatile uint32_t *)805306424B]
  27              	# kianv_stdlib_hdmi.h:54: }
  28 0014 67800000 		ret	
  30              		.align	2
  31              		.globl	set_reg
  33              	set_reg:
  34              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  35 0018 03270500 		lw	a4,0(a0)		# _1,* p
  36              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  37 001c 93071000 		li	a5,1		# tmp85,
  38 0020 B397B700 		sll	a5,a5,a1	# tmp88, _12, tmp85
  39              	# kianv_stdlib_hdmi.h:57:     if (bit) {
  40 0024 63080600 		beq	a2,zero,.L4	#, tmp89,,
  41              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  42 0028 B3E7E700 		or	a5,a5,a4	# _1, _5, _12
  43 002c 2320F500 		sw	a5,0(a0)	# _5,* p
  44 0030 67800000 		ret	
  45              	.L4:
  46              	# kianv_stdlib_hdmi.h:60:       *p &= ~( 0x01 << (gpio & 0x1f));
  47 0034 93C7F7FF 		not	a5,a5	# tmp86, _12
  48              	# kianv_stdlib_hdmi.h:60:       *p &= ~( 0x01 << (gpio & 0x1f));
  49 0038 B3F7E700 		and	a5,a5,a4	# _13, _18, tmp86
  50 003c 2320F500 		sw	a5,0(a0)	# _18,* p
  51              	# kianv_stdlib_hdmi.h:62: }
  52 0040 67800000 		ret	
  54              		.align	2
  55              		.globl	gpio_set_value
  57              	gpio_set_value:
  58              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  59 0044 37070030 		li	a4,805306368		# tmp86,
  60 0048 8326C701 		lw	a3,28(a4)		# _4,
  61              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  62 004c 93071000 		li	a5,1		# tmp84,
  63 0050 B397A700 		sll	a5,a5,a0	# tmp94, _19, tmp84
  64              	# kianv_stdlib_hdmi.h:57:     if (bit) {
  65 0054 63880500 		beq	a1,zero,.L7	#, tmp95,,
  66              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  67 0058 B3E7D700 		or	a5,a5,a3	# _4, _8, _19
  68 005c 232EF700 		sw	a5,28(a4)	# _8,
  69 0060 67800000 		ret	
  70              	.L7:
  71              	# kianv_stdlib_hdmi.h:60:       *p &= ~( 0x01 << (gpio & 0x1f));
  72 0064 93C7F7FF 		not	a5,a5	# tmp91, _19
  73              	# kianv_stdlib_hdmi.h:60:       *p &= ~( 0x01 << (gpio & 0x1f));
  74 0068 B3F7D700 		and	a5,a5,a3	# _12, _17, tmp91
  75 006c 232EF700 		sw	a5,28(a4)	# _17,
  76              	# kianv_stdlib_hdmi.h:66: }
  77 0070 67800000 		ret	
  79              		.align	2
  80              		.globl	gpio_get_input_value
  82              	gpio_get_input_value:
  83              	# kianv_stdlib_hdmi.h:69:   uint32_t read = IO_IN(GPIO_INPUT);
  84 0074 B7070030 		li	a5,805306368		# tmp77,
  85 0078 83A70702 		lw	a5,32(a5)		# read, MEM[(volatile uint32_t *)805306400B]
  86              	# kianv_stdlib_hdmi.h:72:   return ((read >> gpio) & 0x01);
  87 007c 33D5A700 		srl	a0,a5,a0	# tmp80, tmp79, read
  88              	# kianv_stdlib_hdmi.h:73: }
  89 0080 13751500 		andi	a0,a0,1	#,, tmp79
  90 0084 67800000 		ret	
  92              		.align	2
  93              		.globl	gpio_set_direction
  95              	gpio_set_direction:
  96              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
  97 0088 37070030 		li	a4,805306368		# tmp86,
  98 008c 83264701 		lw	a3,20(a4)		# _4,
  99              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
 100 0090 93071000 		li	a5,1		# tmp84,
 101 0094 B397A700 		sll	a5,a5,a0	# tmp94, _19, tmp84
 102              	# kianv_stdlib_hdmi.h:57:     if (bit) {
 103 0098 63880500 		beq	a1,zero,.L11	#, tmp95,,
 104              	# kianv_stdlib_hdmi.h:58:       *p |=  (0x01 << (gpio & 0x1f));
 105 009c B3E7D700 		or	a5,a5,a3	# _4, _8, _19
 106 00a0 232AF700 		sw	a5,20(a4)	# _8,
 107 00a4 67800000 		ret	
 108              	.L11:
 109              	# kianv_stdlib_hdmi.h:60:       *p &= ~( 0x01 << (gpio & 0x1f));
 110 00a8 93C7F7FF 		not	a5,a5	# tmp91, _19
 111              	# kianv_stdlib_hdmi.h:60:       *p &= ~( 0x01 << (gpio & 0x1f));
 112 00ac B3F7D700 		and	a5,a5,a3	# _12, _17, tmp91
 113 00b0 232AF700 		sw	a5,20(a4)	# _17,
 114              	# kianv_stdlib_hdmi.h:77: }
 115 00b4 67800000 		ret	
 117              		.align	2
 118              		.globl	get_cycles
 120              	get_cycles:
 121 00b8 130101FF 		addi	sp,sp,-16	#,,
 122              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 123              	 #APP
 124              	# 83 "kianv_stdlib_hdmi.h" 1
   1              	#include <stdint.h>
   2              	#include <math.h>
   3              	
   4              	/* kian hardware register */
   5              	#define IO_BASE 0x30000000
   6              	#define UART_TX             (volatile uint32_t *) (IO_BASE + 0x0000)
   7              	#define UART_READY          (volatile uint32_t *) (IO_BASE + 0x0000)
   8              	#define VIDEOENABLE         (volatile uint32_t *) (IO_BASE + 0x0008)
   9              	#define VIDEO               (volatile uint32_t *) (IO_BASE + 0x0008)
  10              	#define VIDEO_RAW           (volatile uint32_t *) (IO_BASE + 0x000C)
  11              	#define CPU_FREQ            (volatile uint32_t *) (IO_BASE + 0x0010)
  12              	// gpio hack stuff
  13              	#define GPIO_DIR            ( volatile uint32_t  *) (IO_BASE + 0x0014)
  14              	#define GPIO_PULLUP         ( volatile uint32_t  *) (IO_BASE + 0x0018) // not implemented
  15              	#define GPIO_OUTPUT         ( volatile uint32_t  *) (IO_BASE + 0x001C)
  16              	#define GPIO_INPUT          ( volatile uint32_t  *) (IO_BASE + 0x0020)
  17              	#define IO_OUT(reg, value) *((volatile uint32_t  *) (reg)) = (value)
  18              	#define IO_IN(reg)         *((volatile uint32_t  *) reg)
  19              	// dma stuff
  20              	#define DMA_SRC             ( volatile uint32_t  *) (IO_BASE + 0x002C)
  21              	#define DMA_DST             ( volatile uint32_t  *) (IO_BASE + 0x0030)
  22              	#define DMA_LEN             ( volatile uint32_t  *) (IO_BASE + 0x0034)
  23              	#define DMA_CTRL            ( volatile uint32_t  *) (IO_BASE + 0x0038)
  24              	#define DMA_MEMCPY          (1 << 0)
  25              	#define DMA_MEMSET          (1 << 1)
  26              	
  27              	#define GPIO_INPUT_PIN  0
  28              	#define GPIO_OUTPUT_PIN 1
  29              	//#define RV32_FASTCODE __attribute((section(".fastcode")))
  30              	#define RV32_FASTCODE
  31              	
  32              	//__attribute((section(".fastcode")))
  33              	
  34              	#define RED   "\x1B[31m"
  35              	#define GRN   "\x1B[32m"
  36              	#define YEL   "\x1B[33m"
  37              	#define BLU   "\x1B[34m"
  38              	#define MAG   "\x1B[35m"
  39              	#define CYN   "\x1B[36m"
  40              	#define WHT   "\x1B[37m"
  41              	#define RESET "\x1B[0m"
  42              	
  43              	#define CLS       "\x1B[2J"
  44              	#define BOLD      "\x1B[1m"
  45              	#define BLINK     "\x1B[5m"
  46              	#define BLINK_OFF "\x1B[25m"
  47              	
  48              	// dma stuff
  49              	void dma_action(uint32_t src, uint32_t dst, uint32_t len, uint32_t ctrl) {
  50              	  *( (volatile uint32_t*) DMA_SRC  ) = src;
  51              	  *( (volatile uint32_t*) DMA_DST  ) = dst;
  52              	  *( (volatile uint32_t*) DMA_LEN  ) = len;
  53              	  *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
  54              	}
  55              	
  56              	void set_reg(volatile uint32_t *p, int gpio, int bit) {
  57              	    if (bit) {
  58              	      *p |=  (0x01 << (gpio & 0x1f));
  59              	    } else {
  60              	      *p &= ~( 0x01 << (gpio & 0x1f));
  61              	    }
  62              	}
  63              	
  64              	void gpio_set_value(int gpio, int bit) {
  65              	    set_reg(GPIO_OUTPUT, gpio, bit);
  66              	}
  67              	
  68              	uint32_t gpio_get_input_value(int gpio) {
  69              	  uint32_t read = IO_IN(GPIO_INPUT);
  70              	
  71              	  //  return ((read & (1<<gpio)) >> gpio);
  72              	  return ((read >> gpio) & 0x01);
  73              	}
  74              	
  75              	void gpio_set_direction(int gpio, int bit) {
  76              	    set_reg(GPIO_DIR, gpio, bit);
  77              	}
  78              	
  79              	uint64_t get_cycles() {
  80              	  volatile uint32_t tmph0;
  81              	  volatile uint32_t tmpl0;
  82              	
  83 00bc F32700C8 	  asm volatile ("rdcycleh %0" : "=r"(tmph0));
  84              	  asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 125              		rdcycleh a5	# tmp78
 126              	# 0 "" 2
 127              	 #NO_APP
 128 00c0 2324F100 		sw	a5,8(sp)	# tmp78, tmph0
 129              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 130              	 #APP
 131              	# 84 "kianv_stdlib_hdmi.h" 1
  85              	
 132              		rdcycle  a5	# tmp79
 133              	# 0 "" 2
 134              	 #NO_APP
 135 00c8 2326F100 		sw	a5,12(sp)	# tmp79, tmpl0
 136              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 137 00cc 83258100 		lw	a1,8(sp)		# tmph0.0_1, tmph0
 138              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 139 00d0 0325C100 		lw	a0,12(sp)		# tmpl0.1_4, tmpl0
 140              	# kianv_stdlib_hdmi.h:88: }
 141 00d4 13010101 		addi	sp,sp,16	#,,
 142 00d8 67800000 		jr	ra		#
 144              		.align	2
 145              		.globl	wait_cycles
 147              	wait_cycles:
 148 00dc 130101FF 		addi	sp,sp,-16	#,,
 149              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 150              	 #APP
 151              	# 83 "kianv_stdlib_hdmi.h" 1
 152              		rdcycleh a5	# tmp86
 153              	# 0 "" 2
 154              	 #NO_APP
 155 00e4 2320F100 		sw	a5,0(sp)	# tmp86, tmph0
 156              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 157              	 #APP
 158              	# 84 "kianv_stdlib_hdmi.h" 1
 159              		rdcycle  a5	# tmp87
 160              	# 0 "" 2
 161              	 #NO_APP
 162 00ec 2322F100 		sw	a5,4(sp)	# tmp87, tmpl0
 163              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 164 00f0 83270100 		lw	a5,0(sp)		# tmph0.0_5, tmph0
 165              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 166 00f4 03264100 		lw	a2,4(sp)		# tmpl0.1_8, tmpl0
 167              	# kianv_stdlib_hdmi.h:95:   uint64_t lim = get_cycles() + wait;
 168 00f8 B387B700 		add	a5,a5,a1	# wait, tmp126, tmph0.0_5
 169 00fc 3306C500 		add	a2,a0,a2	# tmpl0.1_8, tmp129, wait
 170 0100 3335A600 		sltu	a0,a2,a0	# wait, tmp98, tmp129
 171 0104 3307F500 		add	a4,a0,a5	# tmp126, tmp100, tmp98
 172              	.L18:
 173              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 174              	 #APP
 175              	# 83 "kianv_stdlib_hdmi.h" 1
 176              		rdcycleh a5	# tmp101
 177              	# 0 "" 2
 178              	 #NO_APP
 179 010c 2324F100 		sw	a5,8(sp)	# tmp101, tmph0
 180              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 181              	 #APP
 182              	# 84 "kianv_stdlib_hdmi.h" 1
 183              		rdcycle  a5	# tmp102
 184              	# 0 "" 2
 185              	 #NO_APP
 186 0114 2326F100 		sw	a5,12(sp)	# tmp102, tmpl0
 187              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 188 0118 83278100 		lw	a5,8(sp)		# tmph0.0_11, tmph0
 189              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 190 011c 8326C100 		lw	a3,12(sp)		# tmpl0.1_14, tmpl0
 191              	# kianv_stdlib_hdmi.h:96:   while (get_cycles() < lim)
 192 0120 E3E4E7FE 		bgtu	a4,a5,.L18	#, tmp100, tmph0.0_11,
 193 0124 6314F700 		bne	a4,a5,.L15	#, tmp100, tmph0.0_11,
 194 0128 E3E0C6FE 		bgtu	a2,a3,.L18	#, tmp129, tmpl0.1_14,
 195              	.L15:
 196              	# kianv_stdlib_hdmi.h:98: }
 197 012c 13010101 		addi	sp,sp,16	#,,
 198 0130 67800000 		jr	ra		#
 200              		.align	2
 201              		.globl	usleep
 203              	usleep:
 204              	# kianv_stdlib_hdmi.h:101:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 205 0134 63080506 		beq	a0,zero,.L29	#, us,,
 206              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 207 0138 B7070030 		li	a5,805306368		# tmp91,
 208              	# kianv_stdlib_hdmi.h:100: void usleep(uint32_t us) {
 209 013c 130101FF 		addi	sp,sp,-16	#,,
 210              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 211 0140 83A70701 		lw	a5,16(a5)		# _20, MEM[(volatile uint32_t *)805306384B]
 212              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 213              	 #APP
 214              	# 83 "kianv_stdlib_hdmi.h" 1
 215              		rdcycleh a4	# tmp92
 216              	# 0 "" 2
 217              	 #NO_APP
 218 0148 2324E100 		sw	a4,8(sp)	# tmp92, tmph0
 219              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 220              	 #APP
 221              	# 84 "kianv_stdlib_hdmi.h" 1
 222              		rdcycle  a3	# tmp93
 223              	# 0 "" 2
 224              	# kianv_stdlib_hdmi.h:101:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 225              	 #NO_APP
 226 0150 37470F00 		li	a4,999424		# tmp97,
 227 0154 13070724 		addi	a4,a4,576	#, tmp96, tmp97
 228 0158 B3D7E702 		divu	a5,a5,a4	# tmp96, tmp95, _20
 229              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 230 015c 2326D100 		sw	a3,12(sp)	# tmp93, tmpl0
 231              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 232 0160 03278100 		lw	a4,8(sp)		# tmph0.0_7, tmph0
 233              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 234 0164 0326C100 		lw	a2,12(sp)		# tmpl0.1_10, tmpl0
 235              	# kianv_stdlib_hdmi.h:101:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 236 0168 B387A702 		mul	a5,a5,a0	# tmp98, tmp95, us
 237              	# kianv_stdlib_hdmi.h:95:   uint64_t lim = get_cycles() + wait;
 238 016c 3386C700 		add	a2,a5,a2	# tmpl0.1_10, tmp141, tmp98
 239 0170 B337F600 		sltu	a5,a2,a5	# tmp98, tmp110, tmp141
 240 0174 B387E700 		add	a5,a5,a4	# tmph0.0_7, tmp112, tmp110
 241              	.L26:
 242              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 243              	 #APP
 244              	# 83 "kianv_stdlib_hdmi.h" 1
 245              		rdcycleh a4	# tmp113
 246              	# 0 "" 2
 247              	 #NO_APP
 248 017c 2320E100 		sw	a4,0(sp)	# tmp113, tmph0
 249              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 250              	 #APP
 251              	# 84 "kianv_stdlib_hdmi.h" 1
 252              		rdcycle  a4	# tmp114
 253              	# 0 "" 2
 254              	 #NO_APP
 255 0184 2322E100 		sw	a4,4(sp)	# tmp114, tmpl0
 256              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 257 0188 03270100 		lw	a4,0(sp)		# tmph0.0_14, tmph0
 258              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 259 018c 83264100 		lw	a3,4(sp)		# tmpl0.1_17, tmpl0
 260              	# kianv_stdlib_hdmi.h:96:   while (get_cycles() < lim)
 261 0190 E364F7FE 		bgtu	a5,a4,.L26	#, tmp112, tmph0.0_14,
 262 0194 6394E700 		bne	a5,a4,.L20	#, tmp112, tmph0.0_14,
 263 0198 E3E0C6FE 		bgtu	a2,a3,.L26	#, tmp141, tmpl0.1_17,
 264              	.L20:
 265              	# kianv_stdlib_hdmi.h:102: }
 266 019c 13010101 		addi	sp,sp,16	#,,
 267 01a0 67800000 		jr	ra		#
 268              	.L29:
 269 01a4 67800000 		ret	
 271              		.align	2
 272              		.globl	msleep
 274              	msleep:
 275              	# kianv_stdlib_hdmi.h:105:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 276 01a8 63060506 		beq	a0,zero,.L41	#, ms,,
 277              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 278 01ac B7070030 		li	a5,805306368		# tmp91,
 279              	# kianv_stdlib_hdmi.h:104: void msleep(uint32_t ms) {
 280 01b0 130101FF 		addi	sp,sp,-16	#,,
 281              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 282 01b4 83A70701 		lw	a5,16(a5)		# _20, MEM[(volatile uint32_t *)805306384B]
 283              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 284              	 #APP
 285              	# 83 "kianv_stdlib_hdmi.h" 1
 286              		rdcycleh a4	# tmp92
 287              	# 0 "" 2
 288              	 #NO_APP
 289 01bc 2324E100 		sw	a4,8(sp)	# tmp92, tmph0
 290              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 291              	 #APP
 292              	# 84 "kianv_stdlib_hdmi.h" 1
 293              		rdcycle  a4	# tmp93
 294              	# 0 "" 2
 295              	# kianv_stdlib_hdmi.h:105:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 296              	 #NO_APP
 297 01c4 9306803E 		li	a3,1000		# tmp95,
 298 01c8 B3D7D702 		divu	a5,a5,a3	# tmp95, tmp96, _20
 299              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 300 01cc 2326E100 		sw	a4,12(sp)	# tmp93, tmpl0
 301              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 302 01d0 03278100 		lw	a4,8(sp)		# tmph0.0_7, tmph0
 303              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 304 01d4 0326C100 		lw	a2,12(sp)		# tmpl0.1_10, tmpl0
 305              	# kianv_stdlib_hdmi.h:105:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 306 01d8 B387A702 		mul	a5,a5,a0	# tmp97, tmp96, ms
 307              	# kianv_stdlib_hdmi.h:95:   uint64_t lim = get_cycles() + wait;
 308 01dc 3386C700 		add	a2,a5,a2	# tmpl0.1_10, tmp140, tmp97
 309 01e0 B337F600 		sltu	a5,a2,a5	# tmp97, tmp109, tmp140
 310 01e4 B387E700 		add	a5,a5,a4	# tmph0.0_7, tmp111, tmp109
 311              	.L38:
 312              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 313              	 #APP
 314              	# 83 "kianv_stdlib_hdmi.h" 1
 315              		rdcycleh a4	# tmp112
 316              	# 0 "" 2
 317              	 #NO_APP
 318 01ec 2320E100 		sw	a4,0(sp)	# tmp112, tmph0
 319              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 320              	 #APP
 321              	# 84 "kianv_stdlib_hdmi.h" 1
 322              		rdcycle  a4	# tmp113
 323              	# 0 "" 2
 324              	 #NO_APP
 325 01f4 2322E100 		sw	a4,4(sp)	# tmp113, tmpl0
 326              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 327 01f8 03270100 		lw	a4,0(sp)		# tmph0.0_14, tmph0
 328              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 329 01fc 83264100 		lw	a3,4(sp)		# tmpl0.1_17, tmpl0
 330              	# kianv_stdlib_hdmi.h:96:   while (get_cycles() < lim)
 331 0200 E364F7FE 		bgtu	a5,a4,.L38	#, tmp111, tmph0.0_14,
 332 0204 6394E700 		bne	a5,a4,.L32	#, tmp111, tmph0.0_14,
 333 0208 E3E0C6FE 		bgtu	a2,a3,.L38	#, tmp140, tmpl0.1_17,
 334              	.L32:
 335              	# kianv_stdlib_hdmi.h:106: }
 336 020c 13010101 		addi	sp,sp,16	#,,
 337 0210 67800000 		jr	ra		#
 338              	.L41:
 339 0214 67800000 		ret	
 341              		.align	2
 342              		.globl	sleep
 344              	sleep:
 345              	# kianv_stdlib_hdmi.h:109:   if (sec) wait_cycles(sec * get_cpu_freq());
 346 0218 63020506 		beq	a0,zero,.L53	#, sec,,
 347              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 348 021c B7070030 		li	a5,805306368		# tmp90,
 349              	# kianv_stdlib_hdmi.h:108: void sleep(uint32_t sec) {
 350 0220 130101FF 		addi	sp,sp,-16	#,,
 351              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 352 0224 03A70701 		lw	a4,16(a5)		# _19, MEM[(volatile uint32_t *)805306384B]
 353              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 354              	 #APP
 355              	# 83 "kianv_stdlib_hdmi.h" 1
 356              		rdcycleh a5	# tmp91
 357              	# 0 "" 2
 358              	 #NO_APP
 359 022c 2324F100 		sw	a5,8(sp)	# tmp91, tmph0
 360              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 361              	 #APP
 362              	# 84 "kianv_stdlib_hdmi.h" 1
 363              		rdcycle  a5	# tmp92
 364              	# 0 "" 2
 365              	# kianv_stdlib_hdmi.h:109:   if (sec) wait_cycles(sec * get_cpu_freq());
 366              	 #NO_APP
 367 0234 3305E502 		mul	a0,a0,a4	# tmp101, sec, _19
 368              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 369 0238 2326F100 		sw	a5,12(sp)	# tmp92, tmpl0
 370              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 371 023c 83278100 		lw	a5,8(sp)		# tmph0.0_6, tmph0
 372              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 373 0240 0327C100 		lw	a4,12(sp)		# tmpl0.1_9, tmpl0
 374              	# kianv_stdlib_hdmi.h:95:   uint64_t lim = get_cycles() + wait;
 375 0244 3305A700 		add	a0,a4,a0	# tmp101, tmp136, tmpl0.1_9
 376 0248 3337E500 		sltu	a4,a0,a4	# tmpl0.1_9, tmp105, tmp136
 377 024c 3307F700 		add	a4,a4,a5	# tmph0.0_6, tmp107, tmp105
 378              	.L50:
 379              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 380              	 #APP
 381              	# 83 "kianv_stdlib_hdmi.h" 1
 382              		rdcycleh a5	# tmp108
 383              	# 0 "" 2
 384              	 #NO_APP
 385 0254 2320F100 		sw	a5,0(sp)	# tmp108, tmph0
 386              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 387              	 #APP
 388              	# 84 "kianv_stdlib_hdmi.h" 1
 389              		rdcycle  a5	# tmp109
 390              	# 0 "" 2
 391              	 #NO_APP
 392 025c 2322F100 		sw	a5,4(sp)	# tmp109, tmpl0
 393              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 394 0260 83270100 		lw	a5,0(sp)		# tmph0.0_13, tmph0
 395              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 396 0264 83264100 		lw	a3,4(sp)		# tmpl0.1_16, tmpl0
 397              	# kianv_stdlib_hdmi.h:96:   while (get_cycles() < lim)
 398 0268 E3E4E7FE 		bgtu	a4,a5,.L50	#, tmp107, tmph0.0_13,
 399 026c 6314F700 		bne	a4,a5,.L44	#, tmp107, tmph0.0_13,
 400 0270 E3E0A6FE 		bgtu	a0,a3,.L50	#, tmp136, tmpl0.1_16,
 401              	.L44:
 402              	# kianv_stdlib_hdmi.h:110: }
 403 0274 13010101 		addi	sp,sp,16	#,,
 404 0278 67800000 		jr	ra		#
 405              	.L53:
 406 027c 67800000 		ret	
 408              		.globl	__udivdi3
 409              		.align	2
 410              		.globl	nanoseconds
 412              	nanoseconds:
 413 0280 130101FE 		addi	sp,sp,-32	#,,
 414 0284 232E1100 		sw	ra,28(sp)	#,
 415              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 416              	 #APP
 417              	# 83 "kianv_stdlib_hdmi.h" 1
 418              		rdcycleh a5	# tmp82
 419              	# 0 "" 2
 420              	 #NO_APP
 421 028c 2324F100 		sw	a5,8(sp)	# tmp82, tmph0
 422              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 423              	 #APP
 424              	# 84 "kianv_stdlib_hdmi.h" 1
 425              		rdcycle  a5	# tmp83
 426              	# 0 "" 2
 427              	 #NO_APP
 428 0294 2326F100 		sw	a5,12(sp)	# tmp83, tmpl0
 429              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 430 0298 B7070030 		li	a5,805306368		# tmp85,
 431              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 432 029c 83258100 		lw	a1,8(sp)		# tmph0.0_6, tmph0
 433              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 434 02a0 0325C100 		lw	a0,12(sp)		# tmpl0.1_9, tmpl0
 435              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 436 02a4 03A60701 		lw	a2,16(a5)		# _5, MEM[(volatile uint32_t *)805306384B]
 437              	# kianv_stdlib_hdmi.h:113:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000000);
 438 02a8 B7470F00 		li	a5,999424		# tmp98,
 439 02ac 93870724 		addi	a5,a5,576	#, tmp97, tmp98
 440              	# kianv_stdlib_hdmi.h:113:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000000);
 441 02b0 3356F602 		divu	a2,a2,a5	# tmp97,, _5
 442 02b4 93060000 		li	a3,0		#,
 443 02b8 97000000 		call	__udivdi3		#
 443      E7800000 
 444              	# kianv_stdlib_hdmi.h:114: }
 445 02c0 8320C101 		lw	ra,28(sp)		#,
 446 02c4 13010102 		addi	sp,sp,32	#,,
 447 02c8 67800000 		jr	ra		#
 449              		.align	2
 450              		.globl	milliseconds
 452              	milliseconds:
 453 02cc 130101FE 		addi	sp,sp,-32	#,,
 454 02d0 232E1100 		sw	ra,28(sp)	#,
 455              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 456              	 #APP
 457              	# 83 "kianv_stdlib_hdmi.h" 1
 458              		rdcycleh a5	# tmp82
 459              	# 0 "" 2
 460              	 #NO_APP
 461 02d8 2324F100 		sw	a5,8(sp)	# tmp82, tmph0
 462              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 463              	 #APP
 464              	# 84 "kianv_stdlib_hdmi.h" 1
 465              		rdcycle  a5	# tmp83
 466              	# 0 "" 2
 467              	 #NO_APP
 468 02e0 2326F100 		sw	a5,12(sp)	# tmp83, tmpl0
 469              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 470 02e4 B7070030 		li	a5,805306368		# tmp85,
 471              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 472 02e8 83258100 		lw	a1,8(sp)		# tmph0.0_6, tmph0
 473              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 474 02ec 0325C100 		lw	a0,12(sp)		# tmpl0.1_9, tmpl0
 475              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 476 02f0 03A60701 		lw	a2,16(a5)		# _5, MEM[(volatile uint32_t *)805306384B]
 477              	# kianv_stdlib_hdmi.h:117:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000);
 478 02f4 9307803E 		li	a5,1000		# tmp96,
 479 02f8 93060000 		li	a3,0		#,
 480 02fc 3356F602 		divu	a2,a2,a5	# tmp96,, _5
 481 0300 97000000 		call	__udivdi3		#
 481      E7800000 
 482              	# kianv_stdlib_hdmi.h:118: }
 483 0308 8320C101 		lw	ra,28(sp)		#,
 484 030c 13010102 		addi	sp,sp,32	#,,
 485 0310 67800000 		jr	ra		#
 487              		.align	2
 488              		.globl	seconds
 490              	seconds:
 491 0314 130101FE 		addi	sp,sp,-32	#,,
 492 0318 232E1100 		sw	ra,28(sp)	#,
 493              	# kianv_stdlib_hdmi.h:83:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 494              	 #APP
 495              	# 83 "kianv_stdlib_hdmi.h" 1
 496              		rdcycleh a5	# tmp81
 497              	# 0 "" 2
 498              	 #NO_APP
 499 0320 2324F100 		sw	a5,8(sp)	# tmp81, tmph0
 500              	# kianv_stdlib_hdmi.h:84:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 501              	 #APP
 502              	# 84 "kianv_stdlib_hdmi.h" 1
 503              		rdcycle  a5	# tmp82
 504              	# 0 "" 2
 505              	 #NO_APP
 506 0328 2326F100 		sw	a5,12(sp)	# tmp82, tmpl0
 507              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 508 032c B7070030 		li	a5,805306368		# tmp84,
 509              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 510 0330 83258100 		lw	a1,8(sp)		# tmph0.0_5, tmph0
 511              	# kianv_stdlib_hdmi.h:86:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 512 0334 0325C100 		lw	a0,12(sp)		# tmpl0.1_8, tmpl0
 513              	# kianv_stdlib_hdmi.h:91:   return *((volatile uint32_t*) CPU_FREQ);
 514 0338 03A60701 		lw	a2,16(a5)		# _4, MEM[(volatile uint32_t *)805306384B]
 515              	# kianv_stdlib_hdmi.h:121:   return get_cycles() / (uint64_t) (get_cpu_freq());
 516 033c 93060000 		li	a3,0		#,
 517 0340 97000000 		call	__udivdi3		#
 517      E7800000 
 518              	# kianv_stdlib_hdmi.h:122: }
 519 0348 8320C101 		lw	ra,28(sp)		#,
 520 034c 13010102 		addi	sp,sp,32	#,,
 521 0350 67800000 		jr	ra		#
 523              		.align	2
 524              		.globl	putchar
 526              	putchar:
 527              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 528 0354 37070030 		li	a4,805306368		# tmp76,
 529              	.L63:
 530              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 531 0358 83270700 		lw	a5,0(a4)		# _2, MEM[(volatile uint32_t *)805306368B]
 532              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 533 035c E38E07FE 		beq	a5,zero,.L63	#, _2,,
 534              	# kianv_stdlib_hdmi.h:127:   *((volatile uint32_t*) UART_TX) = c;
 535 0360 2320A700 		sw	a0,0(a4)	# c, MEM[(volatile uint32_t *)805306368B]
 536              	# kianv_stdlib_hdmi.h:128:    if (c == 13) {
 537 0364 9307D000 		li	a5,13		# tmp78,
 538 0368 6304F500 		beq	a0,a5,.L70	#, c, tmp78,
 539              	# kianv_stdlib_hdmi.h:133: }
 540 036c 67800000 		ret	
 541              	.L70:
 542              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 543 0370 37070030 		li	a4,805306368		# tmp79,
 544              	.L65:
 545 0374 83270700 		lw	a5,0(a4)		# _8, MEM[(volatile uint32_t *)805306368B]
 546              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 547 0378 E38E07FE 		beq	a5,zero,.L65	#, _8,,
 548              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 549 037c 9307A000 		li	a5,10		# tmp81,
 550 0380 2320F700 		sw	a5,0(a4)	# tmp81, MEM[(volatile uint32_t *)805306368B]
 551              	# kianv_stdlib_hdmi.h:133: }
 552 0384 67800000 		ret	
 554              		.align	2
 555              		.globl	print_chr
 557              	print_chr:
 558              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 559 0388 37070030 		li	a4,805306368		# tmp76,
 560              	.L72:
 561 038c 83270700 		lw	a5,0(a4)		# _3, MEM[(volatile uint32_t *)805306368B]
 562              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 563 0390 E38E07FE 		beq	a5,zero,.L72	#, _3,,
 564              	# kianv_stdlib_hdmi.h:127:   *((volatile uint32_t*) UART_TX) = c;
 565 0394 2320A700 		sw	a0,0(a4)	# ch, MEM[(volatile uint32_t *)805306368B]
 566              	# kianv_stdlib_hdmi.h:128:    if (c == 13) {
 567 0398 9307D000 		li	a5,13		# tmp78,
 568 039c 6304F500 		beq	a0,a5,.L79	#, ch, tmp78,
 569              	# kianv_stdlib_hdmi.h:137: }
 570 03a0 67800000 		ret	
 571              	.L79:
 572              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 573 03a4 37070030 		li	a4,805306368		# tmp79,
 574              	.L74:
 575 03a8 83270700 		lw	a5,0(a4)		# _8, MEM[(volatile uint32_t *)805306368B]
 576              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 577 03ac E38E07FE 		beq	a5,zero,.L74	#, _8,,
 578              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 579 03b0 9307A000 		li	a5,10		# tmp81,
 580 03b4 2320F700 		sw	a5,0(a4)	# tmp81, MEM[(volatile uint32_t *)805306368B]
 581              	# kianv_stdlib_hdmi.h:137: }
 582 03b8 67800000 		ret	
 584              		.align	2
 585              		.globl	print_char
 587              	print_char:
 588 03bc 37070030 		li	a4,805306368		# tmp76,
 589              	.L81:
 590 03c0 83270700 		lw	a5,0(a4)		# _4, MEM[(volatile uint32_t *)805306368B]
 591 03c4 E38E07FE 		beq	a5,zero,.L81	#, _4,,
 592 03c8 2320A700 		sw	a0,0(a4)	# ch, MEM[(volatile uint32_t *)805306368B]
 593 03cc 9307D000 		li	a5,13		# tmp78,
 594 03d0 6304F500 		beq	a0,a5,.L88	#, ch, tmp78,
 595 03d4 67800000 		ret	
 596              	.L88:
 597 03d8 37070030 		li	a4,805306368		# tmp79,
 598              	.L83:
 599 03dc 83270700 		lw	a5,0(a4)		# _6, MEM[(volatile uint32_t *)805306368B]
 600 03e0 E38E07FE 		beq	a5,zero,.L83	#, _6,,
 601 03e4 9307A000 		li	a5,10		# tmp81,
 602 03e8 2320F700 		sw	a5,0(a4)	# tmp81, MEM[(volatile uint32_t *)805306368B]
 603 03ec 67800000 		ret	
 605              		.align	2
 606              		.globl	print_str
 608              	print_str:
 609              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 610 03f0 83460500 		lbu	a3,0(a0)	# _3, *p_6(D)
 611              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 612 03f4 638A0602 		beq	a3,zero,.L89	#, _3,,
 613              	# kianv_stdlib_hdmi.h:145:     while (!*((volatile uint32_t*) UART_READY))
 614 03f8 B7070030 		li	a5,805306368		# tmp78,
 615              	# kianv_stdlib_hdmi.h:128:    if (c == 13) {
 616 03fc 1306D000 		li	a2,13		# tmp81,
 617              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 618 0400 9305A000 		li	a1,10		# tmp85,
 619              	.L91:
 620              	# kianv_stdlib_hdmi.h:145:     while (!*((volatile uint32_t*) UART_READY))
 621 0404 03A70700 		lw	a4,0(a5)		# _1, MEM[(volatile uint32_t *)805306368B]
 622              	# kianv_stdlib_hdmi.h:145:     while (!*((volatile uint32_t*) UART_READY))
 623 0408 E30E07FE 		beq	a4,zero,.L91	#, _1,,
 624              	# kianv_stdlib_hdmi.h:147:     putchar(*(p++));
 625 040c 13051500 		addi	a0,a0,1	#, p, p
 626              	.L92:
 627              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 628 0410 03A70700 		lw	a4,0(a5)		# _9, MEM[(volatile uint32_t *)805306368B]
 629              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 630 0414 E30E07FE 		beq	a4,zero,.L92	#, _9,,
 631              	# kianv_stdlib_hdmi.h:127:   *((volatile uint32_t*) UART_TX) = c;
 632 0418 23A0D700 		sw	a3,0(a5)	# _3, MEM[(volatile uint32_t *)805306368B]
 633              	# kianv_stdlib_hdmi.h:128:    if (c == 13) {
 634 041c 6388C600 		beq	a3,a2,.L94	#, _3, tmp81,
 635              	.L93:
 636              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 637 0420 83460500 		lbu	a3,0(a0)	# _3, MEM[(char *)p_8]
 638              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 639 0424 E39006FE 		bne	a3,zero,.L91	#, _3,,
 640              	.L89:
 641              	# kianv_stdlib_hdmi.h:149: }
 642 0428 67800000 		ret	
 643              	.L94:
 644              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 645 042c 03A70700 		lw	a4,0(a5)		# _14, MEM[(volatile uint32_t *)805306368B]
 646              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 647 0430 E30E07FE 		beq	a4,zero,.L94	#, _14,,
 648              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 649 0434 23A0B700 		sw	a1,0(a5)	# tmp85, MEM[(volatile uint32_t *)805306368B]
 650              	# kianv_stdlib_hdmi.h:133: }
 651 0438 6FF09FFE 		j	.L93		#
 653              		.align	2
 654              		.globl	print_str_ln
 656              	print_str_ln:
 657              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 658 043c 83460500 		lbu	a3,0(a0)	# _11, *p_2(D)
 659              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 660 0440 638A0602 		beq	a3,zero,.L107	#, _11,,
 661              	# kianv_stdlib_hdmi.h:145:     while (!*((volatile uint32_t*) UART_READY))
 662 0444 B7070030 		li	a5,805306368		# tmp80,
 663              	# kianv_stdlib_hdmi.h:128:    if (c == 13) {
 664 0448 1306D000 		li	a2,13		# tmp83,
 665              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 666 044c 9305A000 		li	a1,10		# tmp93,
 667              	.L108:
 668              	# kianv_stdlib_hdmi.h:145:     while (!*((volatile uint32_t*) UART_READY))
 669 0450 03A70700 		lw	a4,0(a5)		# _7, MEM[(volatile uint32_t *)805306368B]
 670              	# kianv_stdlib_hdmi.h:145:     while (!*((volatile uint32_t*) UART_READY))
 671 0454 E30E07FE 		beq	a4,zero,.L108	#, _7,,
 672              	# kianv_stdlib_hdmi.h:147:     putchar(*(p++));
 673 0458 13051500 		addi	a0,a0,1	#, p, p
 674              	.L109:
 675              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 676 045c 03A70700 		lw	a4,0(a5)		# _10, MEM[(volatile uint32_t *)805306368B]
 677              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 678 0460 E30E07FE 		beq	a4,zero,.L109	#, _10,,
 679              	# kianv_stdlib_hdmi.h:127:   *((volatile uint32_t*) UART_TX) = c;
 680 0464 23A0D700 		sw	a3,0(a5)	# _11, MEM[(volatile uint32_t *)805306368B]
 681              	# kianv_stdlib_hdmi.h:128:    if (c == 13) {
 682 0468 638CC602 		beq	a3,a2,.L111	#, _11, tmp83,
 683              	.L110:
 684              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 685 046c 83460500 		lbu	a3,0(a0)	# _11, MEM[(char *)p_9]
 686              	# kianv_stdlib_hdmi.h:144:   while (*p != 0) {
 687 0470 E39006FE 		bne	a3,zero,.L108	#, _11,,
 688              	.L107:
 689              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 690 0474 37070030 		li	a4,805306368		# tmp87,
 691              	.L113:
 692 0478 83270700 		lw	a5,0(a4)		# _4, MEM[(volatile uint32_t *)805306368B]
 693              	# kianv_stdlib_hdmi.h:125:   while (!*((volatile uint32_t*) UART_READY))
 694 047c E38E07FE 		beq	a5,zero,.L113	#, _4,,
 695              	# kianv_stdlib_hdmi.h:127:   *((volatile uint32_t*) UART_TX) = c;
 696 0480 9307D000 		li	a5,13		# tmp89,
 697 0484 2320F700 		sw	a5,0(a4)	# tmp89, MEM[(volatile uint32_t *)805306368B]
 698              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 699 0488 37070030 		li	a4,805306368		# tmp90,
 700              	.L114:
 701 048c 83270700 		lw	a5,0(a4)		# _15, MEM[(volatile uint32_t *)805306368B]
 702              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 703 0490 E38E07FE 		beq	a5,zero,.L114	#, _15,,
 704              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 705 0494 9307A000 		li	a5,10		# tmp92,
 706 0498 2320F700 		sw	a5,0(a4)	# tmp92, MEM[(volatile uint32_t *)805306368B]
 707              	# kianv_stdlib_hdmi.h:154: }
 708 049c 67800000 		ret	
 709              	.L111:
 710              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 711 04a0 03A70700 		lw	a4,0(a5)		# _14, MEM[(volatile uint32_t *)805306368B]
 712              	# kianv_stdlib_hdmi.h:129:   while (!*((volatile uint32_t*) UART_READY))
 713 04a4 E30E07FE 		beq	a4,zero,.L111	#, _14,,
 714              	# kianv_stdlib_hdmi.h:131:     *((volatile uint32_t*) UART_TX) = 10;
 715 04a8 23A0B700 		sw	a1,0(a5)	# tmp93, MEM[(volatile uint32_t *)805306368B]
 716              	# kianv_stdlib_hdmi.h:133: }
 717 04ac 6FF01FFC 		j	.L110		#
 719              		.align	2
 720              		.globl	print_dec
 722              	print_dec:
 723 04b0 130101FF 		addi	sp,sp,-16	#,,
 724              	# kianv_stdlib_hdmi.h:160:   char *p = buffer;
 725 04b4 13064100 		addi	a2,sp,4	#, tmp90,
 726 04b8 93070600 		mv	a5,a2	# p, tmp90
 727              	# kianv_stdlib_hdmi.h:162:     *(p++) = val % 10;
 728 04bc 1307A000 		li	a4,10		# tmp91,
 729              	.L130:
 730              	# kianv_stdlib_hdmi.h:161:   while (val || p == buffer) {
 731 04c0 63140500 		bne	a0,zero,.L131	#, val,,
 732              	# kianv_stdlib_hdmi.h:161:   while (val || p == buffer) {
 733 04c4 639CC700 		bne	a5,a2,.L135	#, p, tmp90,
 734              	.L131:
 735              	# kianv_stdlib_hdmi.h:162:     *(p++) = val % 10;
 736 04c8 B376E502 		remu	a3,a0,a4	# tmp91, tmp82, val
 737              	# kianv_stdlib_hdmi.h:162:     *(p++) = val % 10;
 738 04cc 93871700 		addi	a5,a5,1	#, p, p
 739              	# kianv_stdlib_hdmi.h:163:     val = val / 10;
 740 04d0 3355E502 		divu	a0,a0,a4	# tmp91, val, val
 741              	# kianv_stdlib_hdmi.h:162:     *(p++) = val % 10;
 742 04d4 A38FD7FE 		sb	a3,-1(a5)	# tmp82, MEM[(char *)p_17 + 4294967295B]
 743 04d8 6FF09FFE 		j	.L130		#
 744              	.L135:
 745              	# kianv_stdlib_hdmi.h:167:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 746 04dc B7060030 		li	a3,805306368		# tmp88,
 747              	.L132:
 748              	# kianv_stdlib_hdmi.h:167:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 749 04e0 03C7F7FF 		lbu	a4,-1(a5)	# MEM[(char *)p_15], MEM[(char *)p_15]
 750              	# kianv_stdlib_hdmi.h:167:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 751 04e4 9387F7FF 		addi	a5,a5,-1	#, p, p
 752              	# kianv_stdlib_hdmi.h:167:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 753 04e8 13070703 		addi	a4,a4,48	#, _6, MEM[(char *)p_15]
 754              	# kianv_stdlib_hdmi.h:167:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 755 04ec 23A0E600 		sw	a4,0(a3)	# _6, MEM[(volatile uint32_t *)805306368B]
 756              	# kianv_stdlib_hdmi.h:166:   while (p != buffer) {
 757 04f0 E398C7FE 		bne	a5,a2,.L132	#, p, tmp90,
 758              	# kianv_stdlib_hdmi.h:169: }
 759 04f4 13010101 		addi	sp,sp,16	#,,
 760 04f8 67800000 		jr	ra		#
 762              		.align	2
 763              		.globl	print_dec64
 765              	print_dec64:
 766 04fc 130101FE 		addi	sp,sp,-32	#,,
 767              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 768 0500 37DECCCC 		li	t3,-858992640		# tmp256,
 769              	# kianv_stdlib_hdmi.h:173:   char *p = buffer;
 770 0504 930EC100 		addi	t4,sp,12	#, tmp252,
 771              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 772 0508 37030010 		li	t1,268435456		# tmp253,
 773 050c 9308DECC 		addi	a7,t3,-819	#, tmp257, tmp256
 774              	# kianv_stdlib_hdmi.h:171: void print_dec64(uint64_t val) {
 775 0510 13070500 		mv	a4,a0	# val, tmp259
 776 0514 13880500 		mv	a6,a1	# val, tmp260
 777              	# kianv_stdlib_hdmi.h:173:   char *p = buffer;
 778 0518 13860E00 		mv	a2,t4	# p, tmp252
 779              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 780 051c 1303F3FF 		addi	t1,t1,-1	#, tmp254, tmp253
 781 0520 130F5000 		li	t5,5		# tmp255,
 782 0524 130ECECC 		addi	t3,t3,-820	#, tmp258, tmp256
 783              	# kianv_stdlib_hdmi.h:174:   while (val || p == buffer) {
 784 0528 6F008005 		j	.L137		#
 785              	.L138:
 786              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 787 052c B3F7E703 		remu	a5,a5,t5	# tmp255, tmp96, tmp93
 788              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 789 0530 13061600 		addi	a2,a2,1	#, p, p
 790              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 791 0534 B307F740 		sub	a5,a4,a5	# tmp212, val, tmp96
 792 0538 B335F700 		sgtu	a1,a5,a4	# tmp100, tmp212, val
 793 053c B305B840 		sub	a1,a6,a1	# tmp102, val, tmp100
 794 0540 3385C703 		mul	a0,a5,t3	# tmp106, tmp212, tmp258
 795 0544 B3851503 		mul	a1,a1,a7	# tmp103, tmp102, tmp257
 796 0548 B3B61703 		mulhu	a3,a5,a7	# tmp215, tmp212, tmp257
 797 054c B385A500 		add	a1,a1,a0	# tmp106, tmp109, tmp103
 798 0550 B3871703 		mul	a5,a5,a7	# tmp113, tmp212, tmp257
 799 0554 B385D500 		add	a1,a1,a3	# tmp215, tmp114, tmp109
 800 0558 9396F501 		slli	a3,a1,31	#, tmp132, tmp114
 801              	# kianv_stdlib_hdmi.h:176:     val = val / 10;
 802 055c 13D81500 		srli	a6,a1,1	#, val, tmp114
 803              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 804 0560 93D71700 		srli	a5,a5,1	#, tmp222, tmp113
 805 0564 B3E7F600 		or	a5,a3,a5	# tmp222, tmp222, tmp132
 806 0568 13952700 		slli	a0,a5,2	#, tmp226, tmp222
 807 056c 3305F500 		add	a0,a0,a5	# tmp222, tmp228, tmp226
 808 0570 13151500 		slli	a0,a0,1	#, tmp230, tmp228
 809 0574 3305A740 		sub	a0,a4,a0	# tmp232, val, tmp230
 810              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 811 0578 A30FA6FE 		sb	a0,-1(a2)	# tmp232, MEM[(char *)p_17 + 4294967295B]
 812              	# kianv_stdlib_hdmi.h:176:     val = val / 10;
 813 057c 13870700 		mv	a4,a5	# val, tmp222
 814              	.L137:
 815              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 816 0580 93174800 		slli	a5,a6,4	#, tmp87, val
 817 0584 9356C701 		srli	a3,a4,28	#, tmp206, val
 818 0588 B3E6D700 		or	a3,a5,a3	# tmp206, tmp206, tmp87
 819 058c B3F66600 		and	a3,a3,t1	# tmp254, tmp88, tmp206
 820 0590 B3776700 		and	a5,a4,t1	# tmp254, tmp83, val
 821 0594 B387D700 		add	a5,a5,a3	# tmp88, tmp91, tmp83
 822 0598 93558801 		srli	a1,a6,24	#, tmp208, val
 823              	# kianv_stdlib_hdmi.h:174:   while (val || p == buffer) {
 824 059c B3660701 		or	a3,a4,a6	# val, val, val
 825              	# kianv_stdlib_hdmi.h:175:     *(p++) = val % 10;
 826 05a0 B387B700 		add	a5,a5,a1	# tmp208, tmp93, tmp91
 827              	# kianv_stdlib_hdmi.h:174:   while (val || p == buffer) {
 828 05a4 E39406F8 		bne	a3,zero,.L138	#, val,,
 829              	# kianv_stdlib_hdmi.h:174:   while (val || p == buffer) {
 830 05a8 E302D6F9 		beq	a2,t4,.L138	#, p, tmp252,
 831              	# kianv_stdlib_hdmi.h:180:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 832 05ac 37070030 		li	a4,805306368		# tmp202,
 833              	.L139:
 834              	# kianv_stdlib_hdmi.h:180:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 835 05b0 8347F6FF 		lbu	a5,-1(a2)	# MEM[(char *)p_15], MEM[(char *)p_15]
 836              	# kianv_stdlib_hdmi.h:180:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 837 05b4 1306F6FF 		addi	a2,a2,-1	#, p, p
 838              	# kianv_stdlib_hdmi.h:180:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 839 05b8 93870703 		addi	a5,a5,48	#, _6, MEM[(char *)p_15]
 840              	# kianv_stdlib_hdmi.h:180:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 841 05bc 2320F700 		sw	a5,0(a4)	# _6, MEM[(volatile uint32_t *)805306368B]
 842              	# kianv_stdlib_hdmi.h:179:   while (p != buffer) {
 843 05c0 E318D6FF 		bne	a2,t4,.L139	#, p, tmp252,
 844              	# kianv_stdlib_hdmi.h:182: }
 845 05c4 13010102 		addi	sp,sp,32	#,,
 846 05c8 67800000 		jr	ra		#
 848              		.section	.rodata.str1.4,"aMS",@progbits,1
 849              		.align	2
 850              	.LC0:
 851 0000 30313233 		.string	"0123456789ABCDEF"
 851      34353637 
 851      38394142 
 851      43444546 
 851      00
 852              		.text
 853              		.align	2
 854              		.globl	print_hex
 856              	print_hex:
 857              	# kianv_stdlib_hdmi.h:185:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 858 05cc 9385F5FF 		addi	a1,a1,-1	#, tmp84, tmp96
 859              	# kianv_stdlib_hdmi.h:185:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 860 05d0 93952500 		slli	a1,a1,2	#, i, tmp84
 861              	# kianv_stdlib_hdmi.h:185:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 862 05d4 63C80502 		blt	a1,zero,.L142	#, i,,
 863 05d8 37070000 		lui	a4,%hi(.LC0)	# tmp93,
 864 05dc 1306C0FF 		li	a2,-4		# _7,
 865 05e0 13070700 		addi	a4,a4,%lo(.LC0)	# tmp92, tmp93,
 866              	# kianv_stdlib_hdmi.h:186:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16
 867 05e4 B7060030 		li	a3,805306368		# tmp91,
 868              	.L144:
 869              	# kianv_stdlib_hdmi.h:186:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16
 870 05e8 B357B500 		srl	a5,a0,a1	# i, tmp88, val
 871              	# kianv_stdlib_hdmi.h:186:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16
 872 05ec 93F7F700 		andi	a5,a5,15	#, tmp89, tmp88
 873              	# kianv_stdlib_hdmi.h:186:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16
 874 05f0 B307F700 		add	a5,a4,a5	# tmp89, tmp90, tmp92
 875 05f4 83C70700 		lbu	a5,0(a5)	# _5, "0123456789ABCDEF"[_3]
 876              	# kianv_stdlib_hdmi.h:185:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 877 05f8 9385C5FF 		addi	a1,a1,-4	#, i, i
 878              	# kianv_stdlib_hdmi.h:186:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16
 879 05fc 23A0F600 		sw	a5,0(a3)	# _5, MEM[(volatile uint32_t *)805306368B]
 880              	# kianv_stdlib_hdmi.h:185:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 881 0600 E314B6FE 		bne	a2,a1,.L144	#, _7, i,
 882              	.L142:
 883              	# kianv_stdlib_hdmi.h:188: }
 884 0604 67800000 		ret	
 886              		.align	2
 887              		.globl	setpixel
 889              	setpixel:
 890              	# kianv_stdlib_hdmi.h:197:   const int y_offset = y*80;
 891 0608 93172600 		slli	a5,a2,2	#, tmp82, tmp89
 892 060c 3386C700 		add	a2,a5,a2	# tmp89, y_offset, tmp82
 893 0610 13164600 		slli	a2,a2,4	#, tmp84, y_offset
 894              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 895 0614 3306B600 		add	a2,a2,a1	# tmp88, tmp85, tmp84
 896              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 897 0618 13162600 		slli	a2,a2,2	#, tmp86, tmp85
 898 061c 3305C500 		add	a0,a0,a2	# tmp86, _4, tmp87
 899              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 900 0620 2320D500 		sw	a3,0(a0)	# color, *_4
 901              	# kianv_stdlib_hdmi.h:200: }
 902 0624 67800000 		ret	
 904              		.align	2
 905              		.globl	draw_bresenham
 907              	draw_bresenham:
 908 0628 130101FD 		addi	sp,sp,-48	#,,
 909 062c 232A5101 		sw	s5,20(sp)	#,
 910 0630 930A0500 		mv	s5,a0	# tmp107, fb
 911              	# kianv_stdlib_hdmi.h:205:   int dx =  abs(x1 - x0);
 912 0634 3385B640 		sub	a0,a3,a1	#, x1, x0
 913              	# kianv_stdlib_hdmi.h:203: {
 914 0638 23261102 		sw	ra,44(sp)	#,
 915 063c 23248102 		sw	s0,40(sp)	#,
 916 0640 23229102 		sw	s1,36(sp)	#,
 917 0644 13840500 		mv	s0,a1	# x0, tmp108
 918 0648 93040600 		mv	s1,a2	# y0, tmp109
 919 064c 23202103 		sw	s2,32(sp)	#,
 920 0650 232E3101 		sw	s3,28(sp)	#,
 921 0654 232C4101 		sw	s4,24(sp)	#,
 922 0658 93890600 		mv	s3,a3	# x1, tmp110
 923 065c 138A0700 		mv	s4,a5	# color, tmp112
 924 0660 23286101 		sw	s6,16(sp)	#,
 925 0664 23267101 		sw	s7,12(sp)	#,
 926              	# kianv_stdlib_hdmi.h:203: {
 927 0668 930B0700 		mv	s7,a4	# y1, tmp111
 928              	# kianv_stdlib_hdmi.h:205:   int dx =  abs(x1 - x0);
 929 066c 97000000 		call	abs		#
 929      E7800000 
 930 0674 13090500 		mv	s2,a0	# tmp113,
 931              	# kianv_stdlib_hdmi.h:207:   int dy = -abs(y1 - y0);
 932 0678 33859B40 		sub	a0,s7,s1	#, y1, y0
 933 067c 97000000 		call	abs		#
 933      E7800000 
 934              	# kianv_stdlib_hdmi.h:206:   int sx = x0 < x1 ? 1 : -1;
 935 0684 332B3401 		sgt	s6,s3,s0	# tmp102, x1, x0
 936              	# kianv_stdlib_hdmi.h:208:   int sy = y0 < y1 ? 1 : -1;
 937 0688 B3A67401 		sgt	a3,s7,s1	# tmp105, y1, y0
 938              	# kianv_stdlib_hdmi.h:206:   int sx = x0 < x1 ? 1 : -1;
 939 068c 131B1B00 		slli	s6,s6,1	#, iftmp.5_9, tmp102
 940              	# kianv_stdlib_hdmi.h:208:   int sy = y0 < y1 ? 1 : -1;
 941 0690 93961600 		slli	a3,a3,1	#, iftmp.6_10, tmp105
 942              	# kianv_stdlib_hdmi.h:206:   int sx = x0 < x1 ? 1 : -1;
 943 0694 130BFBFF 		addi	s6,s6,-1	#, iftmp.5_9, iftmp.5_9
 944              	# kianv_stdlib_hdmi.h:207:   int dy = -abs(y1 - y0);
 945 0698 B307A040 		neg	a5,a0	# dy, _3
 946              	# kianv_stdlib_hdmi.h:208:   int sy = y0 < y1 ? 1 : -1;
 947 069c 9386F6FF 		addi	a3,a3,-1	#, iftmp.6_10, iftmp.6_10
 948 06a0 3306A940 		sub	a2,s2,a0	# err, dx, _3
 949 06a4 93982400 		slli	a7,s1,2	#, tmp100, y0
 950              	.L150:
 951              	# kianv_stdlib_hdmi.h:197:   const int y_offset = y*80;
 952 06a8 33889800 		add	a6,a7,s1	# y0, y_offset, tmp100
 953 06ac 13184800 		slli	a6,a6,4	#, tmp97, y_offset
 954              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 955 06b0 33088800 		add	a6,a6,s0	# x0, tmp98, tmp97
 956              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 957 06b4 13182800 		slli	a6,a6,2	#, tmp99, tmp98
 958 06b8 33880A01 		add	a6,s5,a6	# tmp99, _36, fb
 959              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 960 06bc 23204801 		sw	s4,0(a6)	# color, *_36
 961              	# kianv_stdlib_hdmi.h:214:     e2 = 2*err;
 962 06c0 93151600 		slli	a1,a2,1	#, e2, err
 963              	# kianv_stdlib_hdmi.h:213:     if (x0 == x1 && y0 == y1) break;
 964 06c4 63003405 		beq	s0,s3,.L158	#, x0, x1,
 965              	.L151:
 966              	# kianv_stdlib_hdmi.h:215:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 967 06c8 63C6F500 		bgt	a5,a1,.L153	#, dy, e2,
 968 06cc 3306A640 		sub	a2,a2,a0	# err, err, _3
 969              	# kianv_stdlib_hdmi.h:215:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 970 06d0 33046401 		add	s0,s0,s6	# iftmp.5_9, x0, x0
 971              	.L153:
 972              	# kianv_stdlib_hdmi.h:216:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 973 06d4 E34AB9FC 		blt	s2,a1,.L150	#, dx, e2,
 974              	# kianv_stdlib_hdmi.h:216:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 975 06d8 B384D400 		add	s1,s1,a3	# iftmp.6_10, y0, y0
 976 06dc 93982400 		slli	a7,s1,2	#, tmp100, y0
 977              	# kianv_stdlib_hdmi.h:197:   const int y_offset = y*80;
 978 06e0 33889800 		add	a6,a7,s1	# y0, y_offset, tmp100
 979 06e4 13184800 		slli	a6,a6,4	#, tmp97, y_offset
 980              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 981 06e8 33088800 		add	a6,a6,s0	# x0, tmp98, tmp97
 982              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 983 06ec 13182800 		slli	a6,a6,2	#, tmp99, tmp98
 984 06f0 33880A01 		add	a6,s5,a6	# tmp99, _36, fb
 985              	# kianv_stdlib_hdmi.h:216:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 986 06f4 33062601 		add	a2,a2,s2	# dx, err, err
 987              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 988 06f8 23204801 		sw	s4,0(a6)	# color, *_36
 989              	# kianv_stdlib_hdmi.h:214:     e2 = 2*err;
 990 06fc 93151600 		slli	a1,a2,1	#, e2, err
 991              	# kianv_stdlib_hdmi.h:213:     if (x0 == x1 && y0 == y1) break;
 992 0700 E31434FD 		bne	s0,s3,.L151	#, x0, x1,
 993              	.L158:
 994              	# kianv_stdlib_hdmi.h:213:     if (x0 == x1 && y0 == y1) break;
 995 0704 E39274FD 		bne	s1,s7,.L151	#, y0, y1,
 996              	# kianv_stdlib_hdmi.h:218: }
 997 0708 8320C102 		lw	ra,44(sp)		#,
 998 070c 03248102 		lw	s0,40(sp)		#,
 999 0710 83244102 		lw	s1,36(sp)		#,
 1000 0714 03290102 		lw	s2,32(sp)		#,
 1001 0718 8329C101 		lw	s3,28(sp)		#,
 1002 071c 032A8101 		lw	s4,24(sp)		#,
 1003 0720 832A4101 		lw	s5,20(sp)		#,
 1004 0724 032B0101 		lw	s6,16(sp)		#,
 1005 0728 832BC100 		lw	s7,12(sp)		#,
 1006 072c 13010103 		addi	sp,sp,48	#,,
 1007 0730 67800000 		jr	ra		#
 1009              		.align	2
 1010              		.globl	mandel
 1012              	mandel:
 1013              	# main_mandel_hdmi.c:47:       if(indexed) {
 1014 0734 B7070000 		lui	a5,%hi(indexed)	# tmp102,
 1015 0738 83AE0700 		lw	t4,%lo(indexed)(a5)		# indexed.7_64, indexed
 1016              	# main_mandel_hdmi.c:27: void mandel(volatile Pixel *framebuffer, uint32_t shift) {
 1017 073c 138F0500 		mv	t5,a1	# shift, tmp127
 1018 0740 93020500 		mv	t0,a0	# ivtmp.163, tmp126
 1019              	# main_mandel_hdmi.c:29:   int Ci = ymin;
 1020 0744 13080080 		li	a6,-2048		# Ci,
 1021              	# main_mandel_hdmi.c:42:         if(Zrr + Zii > norm_max) {
 1022 0748 B7180000 		li	a7,4096		# tmp109,
 1023              	# main_mandel_hdmi.c:49:                   setpixel(framebuffer, X, Y, iter==0?0:(iter%15)+1);
 1024 074c 930FF000 		li	t6,15		# tmp122,
 1025              	# main_mandel_hdmi.c:32:     for(int X = 0; X< HRES; ++X) {
 1026 0750 130E007F 		li	t3,2032		# tmp119,
 1027              	.L160:
 1028              	# main_mandel_hdmi.c:47:       if(indexed) {
 1029 0754 13830200 		mv	t1,t0	# ivtmp.151, ivtmp.163
 1030              	# main_mandel_hdmi.c:31:     int Cr = xmin;
 1031 0758 13050080 		li	a0,-2048		# Cr,
 1032              	.L167:
 1033              	# main_mandel_hdmi.c:27: void mandel(volatile Pixel *framebuffer, uint32_t shift) {
 1034 075c 93070800 		mv	a5,a6	# Zi, Ci
 1035 0760 93060500 		mv	a3,a0	# Zr, Cr
 1036              	# main_mandel_hdmi.c:35:       int iter = 255;
 1037 0764 9305F00F 		li	a1,255		# iter,
 1038 0768 6F00C000 		j	.L162		#
 1039              	.L176:
 1040              	# main_mandel_hdmi.c:45:         --iter;
 1041 076c 9385F5FF 		addi	a1,a1,-1	#, iter, iter
 1042              	# main_mandel_hdmi.c:36:       while(iter > 0) {
 1043 0770 638C0506 		beq	a1,zero,.L175	#, iter,,
 1044              	.L162:
 1045              	# main_mandel_hdmi.c:37:         int Zrr = (Zr * Zr) >> mandel_shift;
 1046 0774 3387D602 		mul	a4,a3,a3	# tmp103, Zr, Zr
 1047              	# main_mandel_hdmi.c:38:         int Zii = (Zi * Zi) >> mandel_shift;
 1048 0778 3386F702 		mul	a2,a5,a5	# tmp104, Zi, Zi
 1049              	# main_mandel_hdmi.c:37:         int Zrr = (Zr * Zr) >> mandel_shift;
 1050 077c 1357A740 		srai	a4,a4,10	#, Zrr, tmp103
 1051              	# main_mandel_hdmi.c:39:         int Zri = (Zr * Zi) >> (mandel_shift - 1);
 1052 0780 B387F602 		mul	a5,a3,a5	# tmp105, Zr, Zi
 1053              	# main_mandel_hdmi.c:38:         int Zii = (Zi * Zi) >> mandel_shift;
 1054 0784 1356A640 		srai	a2,a2,10	#, Zii, tmp104
 1055              	# main_mandel_hdmi.c:40:         Zr = Zrr - Zii + Cr;
 1056 0788 B306C740 		sub	a3,a4,a2	# tmp106, Zrr, Zii
 1057              	# main_mandel_hdmi.c:42:         if(Zrr + Zii > norm_max) {
 1058 078c 3307C700 		add	a4,a4,a2	# Zii, tmp107, Zrr
 1059              	# main_mandel_hdmi.c:40:         Zr = Zrr - Zii + Cr;
 1060 0790 B386A600 		add	a3,a3,a0	# Cr, Zr, tmp106
 1061              	# main_mandel_hdmi.c:39:         int Zri = (Zr * Zi) >> (mandel_shift - 1);
 1062 0794 93D79740 		srai	a5,a5,9	#, Zri, tmp105
 1063              	# main_mandel_hdmi.c:41:         Zi = Zri + Ci;
 1064 0798 B3870701 		add	a5,a5,a6	# Ci, Zi, Zri
 1065              	# main_mandel_hdmi.c:42:         if(Zrr + Zii > norm_max) {
 1066 079c E3D8E8FC 		ble	a4,a7,.L176	#, tmp107, tmp109,
 1067              	# main_mandel_hdmi.c:47:       if(indexed) {
 1068 07a0 639E0E02 		bne	t4,zero,.L177	#, indexed.7_64,,
 1069              	.L169:
 1070              	# main_mandel_hdmi.c:53:                  setpixel(framebuffer, X, Y, ((iter << 19) | (iter << 2)) 
 1071 07a4 93973501 		slli	a5,a1,19	#, tmp116, iter
 1072              	# main_mandel_hdmi.c:53:                  setpixel(framebuffer, X, Y, ((iter << 19) | (iter << 2)) 
 1073 07a8 13972500 		slli	a4,a1,2	#, tmp117, iter
 1074              	# main_mandel_hdmi.c:53:                  setpixel(framebuffer, X, Y, ((iter << 19) | (iter << 2)) 
 1075 07ac B3E7E700 		or	a5,a5,a4	# tmp117, tmp118, tmp116
 1076              	# main_mandel_hdmi.c:52:         setpixel(framebuffer, X, Y, (iter << 8));
 1077 07b0 93958500 		slli	a1,a1,8	#, _10, iter
 1078              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 1079 07b4 2320B300 		sw	a1,0(t1)	# _10, *_51
 1080              	# main_mandel_hdmi.c:53:                  setpixel(framebuffer, X, Y, ((iter << 19) | (iter << 2)) 
 1081 07b8 B397E701 		sll	a5,a5,t5	# shift, _15, tmp118
 1082              	.L174:
 1083              	# kianv_stdlib_hdmi.h:199:   fb[x_offset + y_offset] = color;
 1084 07bc 2320F300 		sw	a5,0(t1)	# _15,* ivtmp.151
 1085              	# main_mandel_hdmi.c:57:       Cr += dx;
 1086 07c0 13053503 		addi	a0,a0,51	#, Cr, Cr
 1087              	# main_mandel_hdmi.c:32:     for(int X = 0; X< HRES; ++X) {
 1088 07c4 13034300 		addi	t1,t1,4	#, ivtmp.151, ivtmp.151
 1089 07c8 E31AC5F9 		bne	a0,t3,.L167	#, Cr, tmp119,
 1090              	# main_mandel_hdmi.c:59:     Ci += dy;
 1091 07cc 13084804 		addi	a6,a6,68	#, Ci, Ci
 1092              	# main_mandel_hdmi.c:30:   for(int Y = 0; Y < VRES; ++Y) {
 1093 07d0 93820214 		addi	t0,t0,320	#, ivtmp.163, ivtmp.163
 1094 07d4 E310A8F8 		bne	a6,a0,.L160	#, Ci, Cr,
 1095              	# main_mandel_hdmi.c:61: }
 1096 07d8 67800000 		ret	
 1097              	.L177:
 1098              	# main_mandel_hdmi.c:49:                   setpixel(framebuffer, X, Y, iter==0?0:(iter%15)+1);
 1099 07dc B3E5F503 		rem	a1,a1,t6	# tmp122, tmp115, iter
 1100              	# main_mandel_hdmi.c:49:                   setpixel(framebuffer, X, Y, iter==0?0:(iter%15)+1);
 1101 07e0 93871500 		addi	a5,a1,1	#, iftmp.8_23, tmp115
 1102 07e4 6FF09FFD 		j	.L174		#
 1103              	.L175:
 1104              	# main_mandel_hdmi.c:49:                   setpixel(framebuffer, X, Y, iter==0?0:(iter%15)+1);
 1105 07e8 93070000 		li	a5,0		# iftmp.8_23,
 1106              	# main_mandel_hdmi.c:47:       if(indexed) {
 1107 07ec E3980EFC 		bne	t4,zero,.L174	#, indexed.7_64,,
 1108 07f0 6FF05FFB 		j	.L169		#
 1110              		.section	.text.startup,"ax",@progbits
 1111              		.align	2
 1112              		.globl	main
 1114              	main:
 1115 0000 130101FF 		addi	sp,sp,-16	#,,
 1116              	# main_mandel_hdmi.c:70:     mandel(fb, shift++);
 1117 0004 B7070000 		lui	a5,%hi(fb)	# tmp74,
 1118              	# main_mandel_hdmi.c:66: void main() {
 1119 0008 23229100 		sw	s1,4(sp)	#,
 1120              	# main_mandel_hdmi.c:70:     mandel(fb, shift++);
 1121 000c 83A40700 		lw	s1,%lo(fb)(a5)		# pretmp_8, fb
 1122              	# main_mandel_hdmi.c:66: void main() {
 1123 0010 23248100 		sw	s0,8(sp)	#,
 1124 0014 23261100 		sw	ra,12(sp)	#,
 1125              	# main_mandel_hdmi.c:70:     mandel(fb, shift++);
 1126 0018 13040000 		li	s0,0		# ivtmp.167,
 1127              	.L179:
 1128              	# main_mandel_hdmi.c:70:     mandel(fb, shift++);
 1129 001c 93050400 		mv	a1,s0	#, ivtmp.167
 1130 0020 13850400 		mv	a0,s1	#, pretmp_8
 1131 0024 97000000 		call	mandel		#
 1131      E7800000 
 1132 002c 13041400 		addi	s0,s0,1	#, ivtmp.167, ivtmp.167
 1133 0030 6FF0DFFE 		j	.L179		#
 1135              		.globl	fb
 1136              		.globl	indexed
 1137              		.section	.sbss,"aw",@nobits
 1138              		.align	2
 1141              	indexed:
 1142 0000 00000000 		.zero	4
 1143              		.section	.sdata,"aw"
 1144              		.align	2
 1147              	fb:
 1148 0000 00000010 		.word	268435456
 1149              		.ident	"GCC: (GNU) 11.1.0"
