   1              		.file	"main_sphere3d_hdmi.c"
   2              		.option nopic
   3              		.attribute arch, "rv32i2p0_m2p0"
   4              		.attribute unaligned_access, 0
   5              		.attribute stack_align, 16
   6              	# GNU C17 (GCC) version 11.1.0 (riscv32-unknown-elf)
   7              	#	compiled by GNU C version 9.3.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl ve
   8              	# warning: GMP header version 6.2.0 differs from library version 6.3.0.
   9              	# warning: MPFR header version 4.0.2 differs from library version 4.2.1.
  10              	# warning: MPC header version 1.1.0 differs from library version 1.3.1.
  11              	# GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
  12              	# options passed: -march=rv32im -mabi=ilp32 -mtune=rocket -march=rv32im -O3 -fno-pic -fno-stack-pro
  13              		.text
  14              		.align	2
  15              		.globl	dma_action
  17              	dma_action:
  18              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
  19 0000 B7070030 		li	a5,805306368		# tmp77,
  20 0004 23A6A702 		sw	a0,44(a5)	# src, MEM[(volatile uint32_t *)805306412B]
  21              	# kianv_stdlib.h:52:   *( (volatile uint32_t*) DMA_DST  ) = dst;
  22 0008 23A8B702 		sw	a1,48(a5)	# dst, MEM[(volatile uint32_t *)805306416B]
  23              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
  24 000c 23AAC702 		sw	a2,52(a5)	# len, MEM[(volatile uint32_t *)805306420B]
  25              	# kianv_stdlib.h:54:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
  26 0010 23ACD702 		sw	a3,56(a5)	# ctrl, MEM[(volatile uint32_t *)805306424B]
  27              	# kianv_stdlib.h:55: }
  28 0014 67800000 		ret	
  30              		.align	2
  31              		.globl	_sendCmd
  33              	_sendCmd:
  34              	# kianv_stdlib.h:62:     *((volatile uint32_t *) VIDEO_RAW) = ((0x00) << 8) | c;
  35 0018 B7070030 		li	a5,805306368		# tmp75,
  36 001c 23A6A700 		sw	a0,12(a5)	# c, MEM[(volatile uint32_t *)805306380B]
  37              	# kianv_stdlib.h:64: }
  38 0020 67800000 		ret	
  40              		.align	2
  41              		.globl	_sendData
  43              	_sendData:
  44              	# kianv_stdlib.h:71:     *((volatile uint32_t *) VIDEO_RAW) = ((0x01) << 8) | c;
  45 0024 13650510 		ori	a0,a0,256	#, _3, tmp78
  46              	# kianv_stdlib.h:71:     *((volatile uint32_t *) VIDEO_RAW) = ((0x01) << 8) | c;
  47 0028 B7070030 		li	a5,805306368		# tmp77,
  48 002c 23A6A700 		sw	a0,12(a5)	# _3, MEM[(volatile uint32_t *)805306380B]
  49              	# kianv_stdlib.h:73: }
  50 0030 67800000 		ret	
  52              		.align	2
  53              		.globl	init_oled1331
  55              	init_oled1331:
  56              	# kianv_stdlib.h:62:     *((volatile uint32_t *) VIDEO_RAW) = ((0x00) << 8) | c;
  57 0034 B7070030 		li	a5,805306368		# tmp73,
  58 0038 1307E00A 		li	a4,174		# tmp74,
  59 003c 23A6E700 		sw	a4,12(a5)	# tmp74, MEM[(volatile uint32_t *)805306380B]
  60 0040 13071008 		li	a4,129		# tmp77,
  61 0044 23A6E700 		sw	a4,12(a5)	# tmp77, MEM[(volatile uint32_t *)805306380B]
  62 0048 13071009 		li	a4,145		# tmp80,
  63 004c 23A6E700 		sw	a4,12(a5)	# tmp80, MEM[(volatile uint32_t *)805306380B]
  64 0050 13072008 		li	a4,130		# tmp83,
  65 0054 23A6E700 		sw	a4,12(a5)	# tmp83, MEM[(volatile uint32_t *)805306380B]
  66 0058 13070008 		li	a4,128		# tmp86,
  67 005c 23A6E700 		sw	a4,12(a5)	# tmp86, MEM[(volatile uint32_t *)805306380B]
  68 0060 13073008 		li	a4,131		# tmp89,
  69 0064 23A6E700 		sw	a4,12(a5)	# tmp89, MEM[(volatile uint32_t *)805306380B]
  70 0068 1307D007 		li	a4,125		# tmp92,
  71 006c 23A6E700 		sw	a4,12(a5)	# tmp92, MEM[(volatile uint32_t *)805306380B]
  72 0070 13077008 		li	a4,135		# tmp95,
  73 0074 23A6E700 		sw	a4,12(a5)	# tmp95, MEM[(volatile uint32_t *)805306380B]
  74 0078 13076000 		li	a4,6		# tmp98,
  75 007c 23A6E700 		sw	a4,12(a5)	# tmp98, MEM[(volatile uint32_t *)805306380B]
  76 0080 1307A008 		li	a4,138		# tmp101,
  77 0084 23A6E700 		sw	a4,12(a5)	# tmp101, MEM[(volatile uint32_t *)805306380B]
  78 0088 13074006 		li	a4,100		# tmp104,
  79 008c 23A6E700 		sw	a4,12(a5)	# tmp104, MEM[(volatile uint32_t *)805306380B]
  80 0090 9306B008 		li	a3,139		# tmp107,
  81 0094 23A6D700 		sw	a3,12(a5)	# tmp107, MEM[(volatile uint32_t *)805306380B]
  82 0098 93068007 		li	a3,120		# tmp110,
  83 009c 23A6D700 		sw	a3,12(a5)	# tmp110, MEM[(volatile uint32_t *)805306380B]
  84 00a0 9306C008 		li	a3,140		# tmp113,
  85 00a4 23A6D700 		sw	a3,12(a5)	# tmp113, MEM[(volatile uint32_t *)805306380B]
  86 00a8 23A6E700 		sw	a4,12(a5)	# tmp104, MEM[(volatile uint32_t *)805306380B]
  87 00ac 1307000A 		li	a4,160		# tmp119,
  88 00b0 23A6E700 		sw	a4,12(a5)	# tmp119, MEM[(volatile uint32_t *)805306380B]
  89 00b4 13072007 		li	a4,114		# tmp122,
  90 00b8 23A6E700 		sw	a4,12(a5)	# tmp122, MEM[(volatile uint32_t *)805306380B]
  91 00bc 1307100A 		li	a4,161		# tmp125,
  92 00c0 23A6E700 		sw	a4,12(a5)	# tmp125, MEM[(volatile uint32_t *)805306380B]
  93 00c4 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
  94 00c8 1307200A 		li	a4,162		# tmp130,
  95 00cc 23A6E700 		sw	a4,12(a5)	# tmp130, MEM[(volatile uint32_t *)805306380B]
  96 00d0 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
  97 00d4 1307400A 		li	a4,164		# tmp135,
  98 00d8 23A6E700 		sw	a4,12(a5)	# tmp135, MEM[(volatile uint32_t *)805306380B]
  99 00dc 1307800A 		li	a4,168		# tmp138,
 100 00e0 23A6E700 		sw	a4,12(a5)	# tmp138, MEM[(volatile uint32_t *)805306380B]
 101 00e4 1307F003 		li	a4,63		# tmp141,
 102 00e8 23A6E700 		sw	a4,12(a5)	# tmp141, MEM[(volatile uint32_t *)805306380B]
 103 00ec 1307D00A 		li	a4,173		# tmp144,
 104 00f0 23A6E700 		sw	a4,12(a5)	# tmp144, MEM[(volatile uint32_t *)805306380B]
 105 00f4 1307E008 		li	a4,142		# tmp147,
 106 00f8 23A6E700 		sw	a4,12(a5)	# tmp147, MEM[(volatile uint32_t *)805306380B]
 107 00fc 1307000B 		li	a4,176		# tmp150,
 108 0100 23A6E700 		sw	a4,12(a5)	# tmp150, MEM[(volatile uint32_t *)805306380B]
 109 0104 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
 110 0108 1307100B 		li	a4,177		# tmp155,
 111 010c 23A6E700 		sw	a4,12(a5)	# tmp155, MEM[(volatile uint32_t *)805306380B]
 112 0110 13071003 		li	a4,49		# tmp158,
 113 0114 23A6E700 		sw	a4,12(a5)	# tmp158, MEM[(volatile uint32_t *)805306380B]
 114 0118 1307300B 		li	a4,179		# tmp161,
 115 011c 23A6E700 		sw	a4,12(a5)	# tmp161, MEM[(volatile uint32_t *)805306380B]
 116 0120 1307000F 		li	a4,240		# tmp164,
 117 0124 23A6E700 		sw	a4,12(a5)	# tmp164, MEM[(volatile uint32_t *)805306380B]
 118 0128 1307B00B 		li	a4,187		# tmp167,
 119 012c 23A6E700 		sw	a4,12(a5)	# tmp167, MEM[(volatile uint32_t *)805306380B]
 120 0130 1307A003 		li	a4,58		# tmp170,
 121 0134 23A6E700 		sw	a4,12(a5)	# tmp170, MEM[(volatile uint32_t *)805306380B]
 122 0138 1307E00B 		li	a4,190		# tmp173,
 123 013c 23A6E700 		sw	a4,12(a5)	# tmp173, MEM[(volatile uint32_t *)805306380B]
 124 0140 1307E003 		li	a4,62		# tmp176,
 125 0144 23A6E700 		sw	a4,12(a5)	# tmp176, MEM[(volatile uint32_t *)805306380B]
 126 0148 1307E002 		li	a4,46		# tmp179,
 127 014c 23A6E700 		sw	a4,12(a5)	# tmp179, MEM[(volatile uint32_t *)805306380B]
 128 0150 1307F00A 		li	a4,175		# tmp182,
 129 0154 23A6E700 		sw	a4,12(a5)	# tmp182, MEM[(volatile uint32_t *)805306380B]
 130              	# kianv_stdlib.h:120: }
 131 0158 67800000 		ret	
 133              		.align	2
 134              		.globl	set_reg
 136              	set_reg:
 137              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 138 015c 03270500 		lw	a4,0(a0)		# _1,* p
 139              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 140 0160 93071000 		li	a5,1		# tmp85,
 141 0164 B397B700 		sll	a5,a5,a1	# tmp88, _12, tmp85
 142              	# kianv_stdlib.h:124:     if (bit) {
 143 0168 63080600 		beq	a2,zero,.L7	#, tmp89,,
 144              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 145 016c B3E7E700 		or	a5,a5,a4	# _1, _5, _12
 146 0170 2320F500 		sw	a5,0(a0)	# _5,* p
 147 0174 67800000 		ret	
 148              	.L7:
 149              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 150 0178 93C7F7FF 		not	a5,a5	# tmp86, _12
 151              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 152 017c B3F7E700 		and	a5,a5,a4	# _13, _18, tmp86
 153 0180 2320F500 		sw	a5,0(a0)	# _18,* p
 154              	# kianv_stdlib.h:129: }
 155 0184 67800000 		ret	
 157              		.align	2
 158              		.globl	gpio_set_value
 160              	gpio_set_value:
 161              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 162 0188 37070030 		li	a4,805306368		# tmp86,
 163 018c 8326C701 		lw	a3,28(a4)		# _7,
 164              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 165 0190 93071000 		li	a5,1		# tmp84,
 166 0194 B397A700 		sll	a5,a5,a0	# tmp94, _6, tmp84
 167              	# kianv_stdlib.h:124:     if (bit) {
 168 0198 63880500 		beq	a1,zero,.L10	#, tmp95,,
 169              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 170 019c B3E7D700 		or	a5,a5,a3	# _7, _11, _6
 171 01a0 232EF700 		sw	a5,28(a4)	# _11,
 172              	# kianv_stdlib.h:133: }
 173 01a4 67800000 		ret	
 174              	.L10:
 175              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 176 01a8 93C7F7FF 		not	a5,a5	# tmp91, _6
 177              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 178 01ac B3F7D700 		and	a5,a5,a3	# _12, _17, tmp91
 179 01b0 232EF700 		sw	a5,28(a4)	# _17,
 180              	# kianv_stdlib.h:133: }
 181 01b4 67800000 		ret	
 183              		.align	2
 184              		.globl	gpio_get_input_value
 186              	gpio_get_input_value:
 187              	# kianv_stdlib.h:136:   uint32_t read = IO_IN(GPIO_INPUT);
 188 01b8 B7070030 		li	a5,805306368		# tmp77,
 189 01bc 83A70702 		lw	a5,32(a5)		# read, MEM[(volatile uint32_t *)805306400B]
 190              	# kianv_stdlib.h:139:   return ((read >> gpio) & 0x01);
 191 01c0 33D5A700 		srl	a0,a5,a0	# tmp80, tmp79, read
 192              	# kianv_stdlib.h:140: }
 193 01c4 13751500 		andi	a0,a0,1	#,, tmp79
 194 01c8 67800000 		ret	
 196              		.align	2
 197              		.globl	gpio_set_direction
 199              	gpio_set_direction:
 200              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 201 01cc 37070030 		li	a4,805306368		# tmp86,
 202 01d0 83264701 		lw	a3,20(a4)		# _4,
 203              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 204 01d4 93071000 		li	a5,1		# tmp84,
 205 01d8 B397A700 		sll	a5,a5,a0	# tmp94, _19, tmp84
 206              	# kianv_stdlib.h:124:     if (bit) {
 207 01dc 63880500 		beq	a1,zero,.L14	#, tmp95,,
 208              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 209 01e0 B3E7D700 		or	a5,a5,a3	# _4, _8, _19
 210 01e4 232AF700 		sw	a5,20(a4)	# _8,
 211 01e8 67800000 		ret	
 212              	.L14:
 213              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 214 01ec 93C7F7FF 		not	a5,a5	# tmp91, _19
 215              	# kianv_stdlib.h:127:       *p &= ~( 0x01 << (gpio & 0x1f));
 216 01f0 B3F7D700 		and	a5,a5,a3	# _12, _17, tmp91
 217 01f4 232AF700 		sw	a5,20(a4)	# _17,
 218              	# kianv_stdlib.h:144: }
 219 01f8 67800000 		ret	
 221              		.align	2
 222              		.globl	get_cycles
 224              	get_cycles:
 225 01fc 130101FF 		addi	sp,sp,-16	#,,
 226              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 227              	 #APP
 228              	# 150 "kianv_stdlib.h" 1
   1              	#include <stdint.h>
   2              	#include <math.h>
   3              	#include "SSD1331.h"
   4              	
   5              	/* kian hardware register */
   6              	#define IO_BASE 0x30000000
   7              	#define UART_TX             (volatile uint32_t *) (IO_BASE + 0x0000)
   8              	#define UART_READY          (volatile uint32_t *) (IO_BASE + 0x0000)
   9              	#define VIDEOENABLE         (volatile uint32_t *) (IO_BASE + 0x0008)
  10              	#define VIDEO               (volatile uint32_t *) (IO_BASE + 0x0008)
  11              	#define VIDEO_RAW           (volatile uint32_t *) (IO_BASE + 0x000C)
  12              	#define CPU_FREQ            (volatile uint32_t *) (IO_BASE + 0x0010)
  13              	// gpio hack stuff
  14              	#define GPIO_DIR            ( volatile uint32_t  *) (IO_BASE + 0x0014)
  15              	#define GPIO_PULLUP         ( volatile uint32_t  *) (IO_BASE + 0x0018) // not implemented
  16              	#define GPIO_OUTPUT         ( volatile uint32_t  *) (IO_BASE + 0x001C)
  17              	#define GPIO_INPUT          ( volatile uint32_t  *) (IO_BASE + 0x0020)
  18              	#define IO_OUT(reg, value) *((volatile uint32_t  *) (reg)) = (value)
  19              	#define IO_IN(reg)         *((volatile uint32_t  *) reg)
  20              	// dma stuff
  21              	#define DMA_SRC             ( volatile uint32_t  *) (IO_BASE + 0x002C)
  22              	#define DMA_DST             ( volatile uint32_t  *) (IO_BASE + 0x0030)
  23              	#define DMA_LEN             ( volatile uint32_t  *) (IO_BASE + 0x0034)
  24              	#define DMA_CTRL            ( volatile uint32_t  *) (IO_BASE + 0x0038)
  25              	#define DMA_MEMCPY          (1 << 0)
  26              	#define DMA_MEMSET          (1 << 1)
  27              	
  28              	#define GPIO_INPUT_PIN  0
  29              	#define GPIO_OUTPUT_PIN 1
  30              	//#define RV32_FASTCODE __attribute((section(".fastcode")))
  31              	#define RV32_FASTCODE
  32              	
  33              	//__attribute((section(".fastcode")))
  34              	
  35              	#define RED   "\x1B[31m"
  36              	#define GRN   "\x1B[32m"
  37              	#define YEL   "\x1B[33m"
  38              	#define BLU   "\x1B[34m"
  39              	#define MAG   "\x1B[35m"
  40              	#define CYN   "\x1B[36m"
  41              	#define WHT   "\x1B[37m"
  42              	#define RESET "\x1B[0m"
  43              	
  44              	#define CLS       "\x1B[2J"
  45              	#define BOLD      "\x1B[1m"
  46              	#define BLINK     "\x1B[5m"
  47              	#define BLINK_OFF "\x1B[25m"
  48              	
  49              	// dma stuff
  50              	void dma_action(uint32_t src, uint32_t dst, uint32_t len, uint32_t ctrl) {
  51              	  *( (volatile uint32_t*) DMA_SRC  ) = src;
  52              	  *( (volatile uint32_t*) DMA_DST  ) = dst;
  53              	  *( (volatile uint32_t*) DMA_LEN  ) = len;
  54              	  *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
  55              	}
  56              	
  57              	void _sendCmd(uint8_t c)
  58              	{
  59              	    //digitalWrite(_dc,LOW);
  60              	    //digitalWrite(_cs,LOW);
  61              	    // SPI.transfer(c);
  62              	    *((volatile uint32_t *) VIDEO_RAW) = ((0x00) << 8) | c;
  63              	    //digitalWrite(_cs,HIGH);
  64              	}
  65              	
  66              	void _sendData(uint8_t c)
  67              	{
  68              	    //digitalWrite(_dc,LOW);
  69              	    //digitalWrite(_cs,LOW);
  70              	    // SPI.transfer(c);
  71              	    *((volatile uint32_t *) VIDEO_RAW) = ((0x01) << 8) | c;
  72              	    //digitalWrite(_cs,HIGH);
  73              	}
  74              	
  75              	void init_oled1331(void)
  76              	{
  77              	    //pinMode(_dc, OUTPUT);
  78              	    //pinMode(_cs, OUTPUT);
  79              	
  80              	    //SPI.begin();
  81              	
  82              	    _sendCmd(CMD_DISPLAY_OFF);	//Display Off
  83              	    _sendCmd(CMD_SET_CONTRAST_A);	//Set contrast for color A
  84              	    _sendCmd(0x91);		//145
  85              	    _sendCmd(CMD_SET_CONTRAST_B);	//Set contrast for color B
  86              	    _sendCmd(0x80);		//80
  87              	    _sendCmd(CMD_SET_CONTRAST_C);	//Set contrast for color C
  88              	    _sendCmd(0x7D);		//125
  89              	    _sendCmd(CMD_MASTER_CURRENT_CONTROL);	//master current control
  90              	    _sendCmd(0x06);		//6
  91              	    _sendCmd(CMD_SET_PRECHARGE_SPEED_A);	//Set Second Pre-change Speed For ColorA
  92              	    _sendCmd(0x64);		//100
  93              	    _sendCmd(CMD_SET_PRECHARGE_SPEED_B);	//Set Second Pre-change Speed For ColorB
  94              	    _sendCmd(0x78);		//120
  95              	    _sendCmd(CMD_SET_PRECHARGE_SPEED_C);	//Set Second Pre-change Speed For ColorC
  96              	    _sendCmd(0x64);		//100
  97              	    _sendCmd(CMD_SET_REMAP);	//set remap & data format
  98              	    _sendCmd(0x72);		//0x72
  99              	    _sendCmd(CMD_SET_DISPLAY_START_LINE);	//Set display Start Line
 100              	    _sendCmd(0x0);
 101              	    _sendCmd(CMD_SET_DISPLAY_OFFSET);	//Set display offset
 102              	    _sendCmd(0x0);
 103              	    _sendCmd(CMD_NORMAL_DISPLAY);	//Set display mode
 104              	    _sendCmd(CMD_SET_MULTIPLEX_RATIO);	//Set multiplex ratio
 105              	    _sendCmd(0x3F);
 106              	    _sendCmd(CMD_SET_MASTER_CONFIGURE);	//Set master configuration
 107              	    _sendCmd(0x8E);
 108              	    _sendCmd(CMD_POWER_SAVE_MODE);	//Set Power Save Mode
 109              	    _sendCmd(0x00);		//0x00
 110              	    _sendCmd(CMD_PHASE_PERIOD_ADJUSTMENT);	//phase 1 and 2 period adjustment
 111              	    _sendCmd(0x31);		//0x31
 112              	    _sendCmd(CMD_DISPLAY_CLOCK_DIV);	//display clock divider/oscillator frequency
 113              	    _sendCmd(0xF0);
 114              	    _sendCmd(CMD_SET_PRECHARGE_VOLTAGE);	//Set Pre-Change Level
 115              	    _sendCmd(0x3A);
 116              	    _sendCmd(CMD_SET_V_VOLTAGE);	//Set vcomH
 117              	    _sendCmd(0x3E);
 118              	    _sendCmd(CMD_DEACTIVE_SCROLLING);	//disable scrolling
 119              	    _sendCmd(CMD_NORMAL_BRIGHTNESS_DISPLAY_ON);	//set display on
 120              	}
 121              	
 122              	
 123              	void set_reg(volatile uint32_t *p, int gpio, int bit) {
 124              	    if (bit) {
 125              	      *p |=  (0x01 << (gpio & 0x1f));
 126              	    } else {
 127              	      *p &= ~( 0x01 << (gpio & 0x1f));
 128              	    }
 129              	}
 130              	
 131              	void gpio_set_value(int gpio, int bit) {
 132              	    set_reg(GPIO_OUTPUT, gpio, bit);
 133              	}
 134              	
 135              	uint32_t gpio_get_input_value(int gpio) {
 136              	  uint32_t read = IO_IN(GPIO_INPUT);
 137              	
 138              	  //  return ((read & (1<<gpio)) >> gpio);
 139              	  return ((read >> gpio) & 0x01);
 140              	}
 141              	
 142              	void gpio_set_direction(int gpio, int bit) {
 143              	    set_reg(GPIO_DIR, gpio, bit);
 144              	}
 145              	
 146              	uint64_t get_cycles() {
 147              	  volatile uint32_t tmph0;
 148              	  volatile uint32_t tmpl0;
 149              	
 150 0200 F32700C8 	  asm volatile ("rdcycleh %0" : "=r"(tmph0));
 151              	  asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 229              		rdcycleh a5	# tmp78
 230              	# 0 "" 2
 231              	 #NO_APP
 232 0204 2324F100 		sw	a5,8(sp)	# tmp78, tmph0
 233              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 234              	 #APP
 235              	# 151 "kianv_stdlib.h" 1
 152              	
 236              		rdcycle  a5	# tmp79
 237              	# 0 "" 2
 238              	 #NO_APP
 239 020c 2326F100 		sw	a5,12(sp)	# tmp79, tmpl0
 240              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 241 0210 83258100 		lw	a1,8(sp)		# tmph0.0_1, tmph0
 242              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 243 0214 0325C100 		lw	a0,12(sp)		# tmpl0.1_4, tmpl0
 244              	# kianv_stdlib.h:155: }
 245 0218 13010101 		addi	sp,sp,16	#,,
 246 021c 67800000 		jr	ra		#
 248              		.align	2
 249              		.globl	wait_cycles
 251              	wait_cycles:
 252 0220 130101FF 		addi	sp,sp,-16	#,,
 253              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 254              	 #APP
 255              	# 150 "kianv_stdlib.h" 1
 256              		rdcycleh a5	# tmp86
 257              	# 0 "" 2
 258              	 #NO_APP
 259 0228 2320F100 		sw	a5,0(sp)	# tmp86, tmph0
 260              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 261              	 #APP
 262              	# 151 "kianv_stdlib.h" 1
 263              		rdcycle  a5	# tmp87
 264              	# 0 "" 2
 265              	 #NO_APP
 266 0230 2322F100 		sw	a5,4(sp)	# tmp87, tmpl0
 267              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 268 0234 83270100 		lw	a5,0(sp)		# tmph0.0_5, tmph0
 269              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 270 0238 03264100 		lw	a2,4(sp)		# tmpl0.1_8, tmpl0
 271              	# kianv_stdlib.h:162:   uint64_t lim = get_cycles() + wait;
 272 023c B387B700 		add	a5,a5,a1	# wait, tmp126, tmph0.0_5
 273 0240 3306C500 		add	a2,a0,a2	# tmpl0.1_8, tmp129, wait
 274 0244 3335A600 		sltu	a0,a2,a0	# wait, tmp98, tmp129
 275 0248 3307F500 		add	a4,a0,a5	# tmp126, tmp100, tmp98
 276              	.L21:
 277              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 278              	 #APP
 279              	# 150 "kianv_stdlib.h" 1
 280              		rdcycleh a5	# tmp101
 281              	# 0 "" 2
 282              	 #NO_APP
 283 0250 2324F100 		sw	a5,8(sp)	# tmp101, tmph0
 284              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 285              	 #APP
 286              	# 151 "kianv_stdlib.h" 1
 287              		rdcycle  a5	# tmp102
 288              	# 0 "" 2
 289              	 #NO_APP
 290 0258 2326F100 		sw	a5,12(sp)	# tmp102, tmpl0
 291              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 292 025c 83278100 		lw	a5,8(sp)		# tmph0.0_11, tmph0
 293              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 294 0260 8326C100 		lw	a3,12(sp)		# tmpl0.1_14, tmpl0
 295              	# kianv_stdlib.h:163:   while (get_cycles() < lim)
 296 0264 E3E4E7FE 		bgtu	a4,a5,.L21	#, tmp100, tmph0.0_11,
 297 0268 6314F700 		bne	a4,a5,.L18	#, tmp100, tmph0.0_11,
 298 026c E3E0C6FE 		bgtu	a2,a3,.L21	#, tmp129, tmpl0.1_14,
 299              	.L18:
 300              	# kianv_stdlib.h:165: }
 301 0270 13010101 		addi	sp,sp,16	#,,
 302 0274 67800000 		jr	ra		#
 304              		.align	2
 305              		.globl	usleep
 307              	usleep:
 308              	# kianv_stdlib.h:168:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 309 0278 63080506 		beq	a0,zero,.L32	#, us,,
 310              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 311 027c B7070030 		li	a5,805306368		# tmp91,
 312              	# kianv_stdlib.h:167: void usleep(uint32_t us) {
 313 0280 130101FF 		addi	sp,sp,-16	#,,
 314              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 315 0284 83A70701 		lw	a5,16(a5)		# _20, MEM[(volatile uint32_t *)805306384B]
 316              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 317              	 #APP
 318              	# 150 "kianv_stdlib.h" 1
 319              		rdcycleh a4	# tmp92
 320              	# 0 "" 2
 321              	 #NO_APP
 322 028c 2324E100 		sw	a4,8(sp)	# tmp92, tmph0
 323              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 324              	 #APP
 325              	# 151 "kianv_stdlib.h" 1
 326              		rdcycle  a3	# tmp93
 327              	# 0 "" 2
 328              	# kianv_stdlib.h:168:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 329              	 #NO_APP
 330 0294 37470F00 		li	a4,999424		# tmp97,
 331 0298 13070724 		addi	a4,a4,576	#, tmp96, tmp97
 332 029c B3D7E702 		divu	a5,a5,a4	# tmp96, tmp95, _20
 333              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 334 02a0 2326D100 		sw	a3,12(sp)	# tmp93, tmpl0
 335              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 336 02a4 03278100 		lw	a4,8(sp)		# tmph0.0_7, tmph0
 337              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 338 02a8 0326C100 		lw	a2,12(sp)		# tmpl0.1_10, tmpl0
 339              	# kianv_stdlib.h:168:   if (us) wait_cycles(us * (get_cpu_freq() / 1000000));
 340 02ac B387A702 		mul	a5,a5,a0	# tmp98, tmp95, us
 341              	# kianv_stdlib.h:162:   uint64_t lim = get_cycles() + wait;
 342 02b0 3386C700 		add	a2,a5,a2	# tmpl0.1_10, tmp141, tmp98
 343 02b4 B337F600 		sltu	a5,a2,a5	# tmp98, tmp110, tmp141
 344 02b8 B387E700 		add	a5,a5,a4	# tmph0.0_7, tmp112, tmp110
 345              	.L29:
 346              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 347              	 #APP
 348              	# 150 "kianv_stdlib.h" 1
 349              		rdcycleh a4	# tmp113
 350              	# 0 "" 2
 351              	 #NO_APP
 352 02c0 2320E100 		sw	a4,0(sp)	# tmp113, tmph0
 353              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 354              	 #APP
 355              	# 151 "kianv_stdlib.h" 1
 356              		rdcycle  a4	# tmp114
 357              	# 0 "" 2
 358              	 #NO_APP
 359 02c8 2322E100 		sw	a4,4(sp)	# tmp114, tmpl0
 360              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 361 02cc 03270100 		lw	a4,0(sp)		# tmph0.0_14, tmph0
 362              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 363 02d0 83264100 		lw	a3,4(sp)		# tmpl0.1_17, tmpl0
 364              	# kianv_stdlib.h:163:   while (get_cycles() < lim)
 365 02d4 E364F7FE 		bgtu	a5,a4,.L29	#, tmp112, tmph0.0_14,
 366 02d8 6394E700 		bne	a5,a4,.L23	#, tmp112, tmph0.0_14,
 367 02dc E3E0C6FE 		bgtu	a2,a3,.L29	#, tmp141, tmpl0.1_17,
 368              	.L23:
 369              	# kianv_stdlib.h:169: }
 370 02e0 13010101 		addi	sp,sp,16	#,,
 371 02e4 67800000 		jr	ra		#
 372              	.L32:
 373 02e8 67800000 		ret	
 375              		.align	2
 376              		.globl	msleep
 378              	msleep:
 379              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 380 02ec 63060506 		beq	a0,zero,.L44	#, ms,,
 381              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 382 02f0 B7070030 		li	a5,805306368		# tmp91,
 383              	# kianv_stdlib.h:171: void msleep(uint32_t ms) {
 384 02f4 130101FF 		addi	sp,sp,-16	#,,
 385              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 386 02f8 83A70701 		lw	a5,16(a5)		# _20, MEM[(volatile uint32_t *)805306384B]
 387              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 388              	 #APP
 389              	# 150 "kianv_stdlib.h" 1
 390              		rdcycleh a4	# tmp92
 391              	# 0 "" 2
 392              	 #NO_APP
 393 0300 2324E100 		sw	a4,8(sp)	# tmp92, tmph0
 394              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 395              	 #APP
 396              	# 151 "kianv_stdlib.h" 1
 397              		rdcycle  a4	# tmp93
 398              	# 0 "" 2
 399              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 400              	 #NO_APP
 401 0308 9306803E 		li	a3,1000		# tmp95,
 402 030c B3D7D702 		divu	a5,a5,a3	# tmp95, tmp96, _20
 403              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 404 0310 2326E100 		sw	a4,12(sp)	# tmp93, tmpl0
 405              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 406 0314 03278100 		lw	a4,8(sp)		# tmph0.0_7, tmph0
 407              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 408 0318 0326C100 		lw	a2,12(sp)		# tmpl0.1_10, tmpl0
 409              	# kianv_stdlib.h:172:   if (ms) wait_cycles(ms * (get_cpu_freq() / 1000));
 410 031c B387A702 		mul	a5,a5,a0	# tmp97, tmp96, ms
 411              	# kianv_stdlib.h:162:   uint64_t lim = get_cycles() + wait;
 412 0320 3386C700 		add	a2,a5,a2	# tmpl0.1_10, tmp140, tmp97
 413 0324 B337F600 		sltu	a5,a2,a5	# tmp97, tmp109, tmp140
 414 0328 B387E700 		add	a5,a5,a4	# tmph0.0_7, tmp111, tmp109
 415              	.L41:
 416              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 417              	 #APP
 418              	# 150 "kianv_stdlib.h" 1
 419              		rdcycleh a4	# tmp112
 420              	# 0 "" 2
 421              	 #NO_APP
 422 0330 2320E100 		sw	a4,0(sp)	# tmp112, tmph0
 423              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 424              	 #APP
 425              	# 151 "kianv_stdlib.h" 1
 426              		rdcycle  a4	# tmp113
 427              	# 0 "" 2
 428              	 #NO_APP
 429 0338 2322E100 		sw	a4,4(sp)	# tmp113, tmpl0
 430              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 431 033c 03270100 		lw	a4,0(sp)		# tmph0.0_14, tmph0
 432              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 433 0340 83264100 		lw	a3,4(sp)		# tmpl0.1_17, tmpl0
 434              	# kianv_stdlib.h:163:   while (get_cycles() < lim)
 435 0344 E364F7FE 		bgtu	a5,a4,.L41	#, tmp111, tmph0.0_14,
 436 0348 6394E700 		bne	a5,a4,.L35	#, tmp111, tmph0.0_14,
 437 034c E3E0C6FE 		bgtu	a2,a3,.L41	#, tmp140, tmpl0.1_17,
 438              	.L35:
 439              	# kianv_stdlib.h:173: }
 440 0350 13010101 		addi	sp,sp,16	#,,
 441 0354 67800000 		jr	ra		#
 442              	.L44:
 443 0358 67800000 		ret	
 445              		.align	2
 446              		.globl	sleep
 448              	sleep:
 449              	# kianv_stdlib.h:176:   if (sec) wait_cycles(sec * get_cpu_freq());
 450 035c 63020506 		beq	a0,zero,.L56	#, sec,,
 451              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 452 0360 B7070030 		li	a5,805306368		# tmp90,
 453              	# kianv_stdlib.h:175: void sleep(uint32_t sec) {
 454 0364 130101FF 		addi	sp,sp,-16	#,,
 455              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 456 0368 03A70701 		lw	a4,16(a5)		# _19, MEM[(volatile uint32_t *)805306384B]
 457              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 458              	 #APP
 459              	# 150 "kianv_stdlib.h" 1
 460              		rdcycleh a5	# tmp91
 461              	# 0 "" 2
 462              	 #NO_APP
 463 0370 2324F100 		sw	a5,8(sp)	# tmp91, tmph0
 464              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 465              	 #APP
 466              	# 151 "kianv_stdlib.h" 1
 467              		rdcycle  a5	# tmp92
 468              	# 0 "" 2
 469              	# kianv_stdlib.h:176:   if (sec) wait_cycles(sec * get_cpu_freq());
 470              	 #NO_APP
 471 0378 3305E502 		mul	a0,a0,a4	# tmp101, sec, _19
 472              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 473 037c 2326F100 		sw	a5,12(sp)	# tmp92, tmpl0
 474              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 475 0380 83278100 		lw	a5,8(sp)		# tmph0.0_6, tmph0
 476              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 477 0384 0327C100 		lw	a4,12(sp)		# tmpl0.1_9, tmpl0
 478              	# kianv_stdlib.h:162:   uint64_t lim = get_cycles() + wait;
 479 0388 3305A700 		add	a0,a4,a0	# tmp101, tmp136, tmpl0.1_9
 480 038c 3337E500 		sltu	a4,a0,a4	# tmpl0.1_9, tmp105, tmp136
 481 0390 3307F700 		add	a4,a4,a5	# tmph0.0_6, tmp107, tmp105
 482              	.L53:
 483              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 484              	 #APP
 485              	# 150 "kianv_stdlib.h" 1
 486              		rdcycleh a5	# tmp108
 487              	# 0 "" 2
 488              	 #NO_APP
 489 0398 2320F100 		sw	a5,0(sp)	# tmp108, tmph0
 490              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 491              	 #APP
 492              	# 151 "kianv_stdlib.h" 1
 493              		rdcycle  a5	# tmp109
 494              	# 0 "" 2
 495              	 #NO_APP
 496 03a0 2322F100 		sw	a5,4(sp)	# tmp109, tmpl0
 497              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 498 03a4 83270100 		lw	a5,0(sp)		# tmph0.0_13, tmph0
 499              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 500 03a8 83264100 		lw	a3,4(sp)		# tmpl0.1_16, tmpl0
 501              	# kianv_stdlib.h:163:   while (get_cycles() < lim)
 502 03ac E3E4E7FE 		bgtu	a4,a5,.L53	#, tmp107, tmph0.0_13,
 503 03b0 6314F700 		bne	a4,a5,.L47	#, tmp107, tmph0.0_13,
 504 03b4 E3E0A6FE 		bgtu	a0,a3,.L53	#, tmp136, tmpl0.1_16,
 505              	.L47:
 506              	# kianv_stdlib.h:177: }
 507 03b8 13010101 		addi	sp,sp,16	#,,
 508 03bc 67800000 		jr	ra		#
 509              	.L56:
 510 03c0 67800000 		ret	
 512              		.globl	__udivdi3
 513              		.align	2
 514              		.globl	nanoseconds
 516              	nanoseconds:
 517 03c4 130101FE 		addi	sp,sp,-32	#,,
 518 03c8 232E1100 		sw	ra,28(sp)	#,
 519              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 520              	 #APP
 521              	# 150 "kianv_stdlib.h" 1
 522              		rdcycleh a5	# tmp82
 523              	# 0 "" 2
 524              	 #NO_APP
 525 03d0 2324F100 		sw	a5,8(sp)	# tmp82, tmph0
 526              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 527              	 #APP
 528              	# 151 "kianv_stdlib.h" 1
 529              		rdcycle  a5	# tmp83
 530              	# 0 "" 2
 531              	 #NO_APP
 532 03d8 2326F100 		sw	a5,12(sp)	# tmp83, tmpl0
 533              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 534 03dc B7070030 		li	a5,805306368		# tmp85,
 535              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 536 03e0 83258100 		lw	a1,8(sp)		# tmph0.0_6, tmph0
 537              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 538 03e4 0325C100 		lw	a0,12(sp)		# tmpl0.1_9, tmpl0
 539              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 540 03e8 03A60701 		lw	a2,16(a5)		# _5, MEM[(volatile uint32_t *)805306384B]
 541              	# kianv_stdlib.h:180:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000000);
 542 03ec B7470F00 		li	a5,999424		# tmp98,
 543 03f0 93870724 		addi	a5,a5,576	#, tmp97, tmp98
 544              	# kianv_stdlib.h:180:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000000);
 545 03f4 3356F602 		divu	a2,a2,a5	# tmp97,, _5
 546 03f8 93060000 		li	a3,0		#,
 547 03fc 97000000 		call	__udivdi3		#
 547      E7800000 
 548              	# kianv_stdlib.h:181: }
 549 0404 8320C101 		lw	ra,28(sp)		#,
 550 0408 13010102 		addi	sp,sp,32	#,,
 551 040c 67800000 		jr	ra		#
 553              		.align	2
 554              		.globl	milliseconds
 556              	milliseconds:
 557 0410 130101FE 		addi	sp,sp,-32	#,,
 558 0414 232E1100 		sw	ra,28(sp)	#,
 559              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 560              	 #APP
 561              	# 150 "kianv_stdlib.h" 1
 562              		rdcycleh a5	# tmp82
 563              	# 0 "" 2
 564              	 #NO_APP
 565 041c 2324F100 		sw	a5,8(sp)	# tmp82, tmph0
 566              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 567              	 #APP
 568              	# 151 "kianv_stdlib.h" 1
 569              		rdcycle  a5	# tmp83
 570              	# 0 "" 2
 571              	 #NO_APP
 572 0424 2326F100 		sw	a5,12(sp)	# tmp83, tmpl0
 573              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 574 0428 B7070030 		li	a5,805306368		# tmp85,
 575              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 576 042c 83258100 		lw	a1,8(sp)		# tmph0.0_6, tmph0
 577              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 578 0430 0325C100 		lw	a0,12(sp)		# tmpl0.1_9, tmpl0
 579              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 580 0434 03A60701 		lw	a2,16(a5)		# _5, MEM[(volatile uint32_t *)805306384B]
 581              	# kianv_stdlib.h:184:   return get_cycles() / (uint64_t) (get_cpu_freq() / 1000);
 582 0438 9307803E 		li	a5,1000		# tmp96,
 583 043c 93060000 		li	a3,0		#,
 584 0440 3356F602 		divu	a2,a2,a5	# tmp96,, _5
 585 0444 97000000 		call	__udivdi3		#
 585      E7800000 
 586              	# kianv_stdlib.h:185: }
 587 044c 8320C101 		lw	ra,28(sp)		#,
 588 0450 13010102 		addi	sp,sp,32	#,,
 589 0454 67800000 		jr	ra		#
 591              		.align	2
 592              		.globl	seconds
 594              	seconds:
 595 0458 130101FE 		addi	sp,sp,-32	#,,
 596 045c 232E1100 		sw	ra,28(sp)	#,
 597              	# kianv_stdlib.h:150:   asm volatile ("rdcycleh %0" : "=r"(tmph0));
 598              	 #APP
 599              	# 150 "kianv_stdlib.h" 1
 600              		rdcycleh a5	# tmp81
 601              	# 0 "" 2
 602              	 #NO_APP
 603 0464 2324F100 		sw	a5,8(sp)	# tmp81, tmph0
 604              	# kianv_stdlib.h:151:   asm volatile ("rdcycle  %0" : "=r"(tmpl0));
 605              	 #APP
 606              	# 151 "kianv_stdlib.h" 1
 607              		rdcycle  a5	# tmp82
 608              	# 0 "" 2
 609              	 #NO_APP
 610 046c 2326F100 		sw	a5,12(sp)	# tmp82, tmpl0
 611              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 612 0470 B7070030 		li	a5,805306368		# tmp84,
 613              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 614 0474 83258100 		lw	a1,8(sp)		# tmph0.0_5, tmph0
 615              	# kianv_stdlib.h:153:   return ((uint64_t)(tmph0)<<32) + tmpl0;
 616 0478 0325C100 		lw	a0,12(sp)		# tmpl0.1_8, tmpl0
 617              	# kianv_stdlib.h:158:   return *((volatile uint32_t*) CPU_FREQ);
 618 047c 03A60701 		lw	a2,16(a5)		# _4, MEM[(volatile uint32_t *)805306384B]
 619              	# kianv_stdlib.h:188:   return get_cycles() / (uint64_t) (get_cpu_freq());
 620 0480 93060000 		li	a3,0		#,
 621 0484 97000000 		call	__udivdi3		#
 621      E7800000 
 622              	# kianv_stdlib.h:189: }
 623 048c 8320C101 		lw	ra,28(sp)		#,
 624 0490 13010102 		addi	sp,sp,32	#,,
 625 0494 67800000 		jr	ra		#
 627              		.align	2
 628              		.globl	putchar
 630              	putchar:
 631              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 632 0498 37070030 		li	a4,805306368		# tmp75,
 633              	.L66:
 634              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 635 049c 83270700 		lw	a5,0(a4)		# _1, MEM[(volatile uint32_t *)805306368B]
 636              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 637 04a0 E38E07FE 		beq	a5,zero,.L66	#, _1,,
 638              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 639 04a4 2320A700 		sw	a0,0(a4)	# c, MEM[(volatile uint32_t *)805306368B]
 640              	# kianv_stdlib.h:195:    if (c == 13) {
 641 04a8 9307D000 		li	a5,13		# tmp77,
 642 04ac 6304F500 		beq	a0,a5,.L70	#, c, tmp77,
 643              	# kianv_stdlib.h:198: }
 644 04b0 67800000 		ret	
 645              	.L70:
 646              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 647 04b4 9307A000 		li	a5,10		# tmp79,
 648 04b8 2320F700 		sw	a5,0(a4)	# tmp79, MEM[(volatile uint32_t *)805306368B]
 649              	# kianv_stdlib.h:198: }
 650 04bc 67800000 		ret	
 652              		.align	2
 653              		.globl	print_chr
 655              	print_chr:
 656 04c0 37070030 		li	a4,805306368		# tmp75,
 657              	.L72:
 658 04c4 83270700 		lw	a5,0(a4)		# _4, MEM[(volatile uint32_t *)805306368B]
 659 04c8 E38E07FE 		beq	a5,zero,.L72	#, _4,,
 660 04cc 2320A700 		sw	a0,0(a4)	# ch, MEM[(volatile uint32_t *)805306368B]
 661 04d0 9307D000 		li	a5,13		# tmp77,
 662 04d4 6304F500 		beq	a0,a5,.L76	#, ch, tmp77,
 663 04d8 67800000 		ret	
 664              	.L76:
 665 04dc 9307A000 		li	a5,10		# tmp79,
 666 04e0 2320F700 		sw	a5,0(a4)	# tmp79, MEM[(volatile uint32_t *)805306368B]
 667 04e4 67800000 		ret	
 669              		.align	2
 670              		.globl	print_char
 672              	print_char:
 673 04e8 37070030 		li	a4,805306368		# tmp75,
 674              	.L78:
 675 04ec 83270700 		lw	a5,0(a4)		# _4, MEM[(volatile uint32_t *)805306368B]
 676 04f0 E38E07FE 		beq	a5,zero,.L78	#, _4,,
 677 04f4 2320A700 		sw	a0,0(a4)	# ch, MEM[(volatile uint32_t *)805306368B]
 678 04f8 9307D000 		li	a5,13		# tmp77,
 679 04fc 6304F500 		beq	a0,a5,.L82	#, ch, tmp77,
 680 0500 67800000 		ret	
 681              	.L82:
 682 0504 9307A000 		li	a5,10		# tmp79,
 683 0508 2320F700 		sw	a5,0(a4)	# tmp79, MEM[(volatile uint32_t *)805306368B]
 684 050c 67800000 		ret	
 686              		.align	2
 687              		.globl	print_str
 689              	print_str:
 690              	# kianv_stdlib.h:209:   while (*p != 0) {
 691 0510 83460500 		lbu	a3,0(a0)	# _3, *p_6(D)
 692              	# kianv_stdlib.h:209:   while (*p != 0) {
 693 0514 638A0602 		beq	a3,zero,.L83	#, _3,,
 694              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 695 0518 B7070030 		li	a5,805306368		# tmp77,
 696              	# kianv_stdlib.h:195:    if (c == 13) {
 697 051c 1306D000 		li	a2,13		# tmp80,
 698              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 699 0520 9305A000 		li	a1,10		# tmp83,
 700              	.L85:
 701              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 702 0524 03A70700 		lw	a4,0(a5)		# _1, MEM[(volatile uint32_t *)805306368B]
 703              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 704 0528 E30E07FE 		beq	a4,zero,.L85	#, _1,,
 705              	# kianv_stdlib.h:212:     putchar(*(p++));
 706 052c 13051500 		addi	a0,a0,1	#, p, p
 707              	.L86:
 708              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 709 0530 03A70700 		lw	a4,0(a5)		# _9, MEM[(volatile uint32_t *)805306368B]
 710              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 711 0534 E30E07FE 		beq	a4,zero,.L86	#, _9,,
 712              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 713 0538 23A0D700 		sw	a3,0(a5)	# _3, MEM[(volatile uint32_t *)805306368B]
 714              	# kianv_stdlib.h:195:    if (c == 13) {
 715 053c 6388C600 		beq	a3,a2,.L100	#, _3, tmp80,
 716              	# kianv_stdlib.h:209:   while (*p != 0) {
 717 0540 83460500 		lbu	a3,0(a0)	# _3, MEM[(char *)p_8]
 718              	# kianv_stdlib.h:209:   while (*p != 0) {
 719 0544 E39006FE 		bne	a3,zero,.L85	#, _3,,
 720              	.L83:
 721              	# kianv_stdlib.h:214: }
 722 0548 67800000 		ret	
 723              	.L100:
 724              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 725 054c 23A0B700 		sw	a1,0(a5)	# tmp83, MEM[(volatile uint32_t *)805306368B]
 726              	# kianv_stdlib.h:209:   while (*p != 0) {
 727 0550 83460500 		lbu	a3,0(a0)	# _3, MEM[(char *)p_8]
 728              	# kianv_stdlib.h:209:   while (*p != 0) {
 729 0554 E39806FC 		bne	a3,zero,.L85	#, _3,,
 730 0558 67800000 		ret	
 732              		.align	2
 733              		.globl	print_str_ln
 735              	print_str_ln:
 736              	# kianv_stdlib.h:209:   while (*p != 0) {
 737 055c 83460500 		lbu	a3,0(a0)	# _9, *p_2(D)
 738              	# kianv_stdlib.h:209:   while (*p != 0) {
 739 0560 638A0602 		beq	a3,zero,.L102	#, _9,,
 740              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 741 0564 B7070030 		li	a5,805306368		# tmp78,
 742              	# kianv_stdlib.h:195:    if (c == 13) {
 743 0568 1306D000 		li	a2,13		# tmp81,
 744              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 745 056c 9305A000 		li	a1,10		# tmp89,
 746              	.L103:
 747              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 748 0570 03A70700 		lw	a4,0(a5)		# _5, MEM[(volatile uint32_t *)805306368B]
 749              	# kianv_stdlib.h:210:     while (!*((volatile uint32_t*) UART_READY))
 750 0574 E30E07FE 		beq	a4,zero,.L103	#, _5,,
 751              	# kianv_stdlib.h:212:     putchar(*(p++));
 752 0578 13051500 		addi	a0,a0,1	#, p, p
 753              	.L104:
 754              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 755 057c 03A70700 		lw	a4,0(a5)		# _8, MEM[(volatile uint32_t *)805306368B]
 756              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 757 0580 E30E07FE 		beq	a4,zero,.L104	#, _8,,
 758              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 759 0584 23A0D700 		sw	a3,0(a5)	# _9, MEM[(volatile uint32_t *)805306368B]
 760              	# kianv_stdlib.h:195:    if (c == 13) {
 761 0588 6386C602 		beq	a3,a2,.L121	#, _9, tmp81,
 762              	# kianv_stdlib.h:209:   while (*p != 0) {
 763 058c 83460500 		lbu	a3,0(a0)	# _9, MEM[(char *)p_7]
 764              	# kianv_stdlib.h:209:   while (*p != 0) {
 765 0590 E39006FE 		bne	a3,zero,.L103	#, _9,,
 766              	.L102:
 767              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 768 0594 37070030 		li	a4,805306368		# tmp84,
 769              	.L108:
 770 0598 83270700 		lw	a5,0(a4)		# _3, MEM[(volatile uint32_t *)805306368B]
 771              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 772 059c E38E07FE 		beq	a5,zero,.L108	#, _3,,
 773              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 774 05a0 9307D000 		li	a5,13		# tmp86,
 775 05a4 2320F700 		sw	a5,0(a4)	# tmp86, MEM[(volatile uint32_t *)805306368B]
 776              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 777 05a8 9307A000 		li	a5,10		# tmp88,
 778 05ac 2320F700 		sw	a5,0(a4)	# tmp88, MEM[(volatile uint32_t *)805306368B]
 779              	# kianv_stdlib.h:219: }
 780 05b0 67800000 		ret	
 781              	.L121:
 782              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 783 05b4 23A0B700 		sw	a1,0(a5)	# tmp89, MEM[(volatile uint32_t *)805306368B]
 784              	# kianv_stdlib.h:209:   while (*p != 0) {
 785 05b8 83460500 		lbu	a3,0(a0)	# _9, MEM[(char *)p_7]
 786              	# kianv_stdlib.h:209:   while (*p != 0) {
 787 05bc E39A06FA 		bne	a3,zero,.L103	#, _9,,
 788 05c0 6FF05FFD 		j	.L102		#
 790              		.align	2
 791              		.globl	print_dec
 793              	print_dec:
 794 05c4 130101FF 		addi	sp,sp,-16	#,,
 795              	# kianv_stdlib.h:223:   char *p = buffer;
 796 05c8 13064100 		addi	a2,sp,4	#, tmp92,
 797 05cc 13070600 		mv	a4,a2	# p, tmp92
 798              	# kianv_stdlib.h:225:     *(p++) = val % 10;
 799 05d0 9307A000 		li	a5,10		# tmp93,
 800              	.L123:
 801              	# kianv_stdlib.h:224:   while (val || p == buffer) {
 802 05d4 63140500 		bne	a0,zero,.L124	#, val,,
 803              	# kianv_stdlib.h:224:   while (val || p == buffer) {
 804 05d8 631CC700 		bne	a4,a2,.L131	#, p, tmp92,
 805              	.L124:
 806              	# kianv_stdlib.h:225:     *(p++) = val % 10;
 807 05dc B376F502 		remu	a3,a0,a5	# tmp93, tmp83, val
 808              	# kianv_stdlib.h:225:     *(p++) = val % 10;
 809 05e0 13071700 		addi	a4,a4,1	#, p, p
 810              	# kianv_stdlib.h:226:     val = val / 10;
 811 05e4 3355F502 		divu	a0,a0,a5	# tmp93, val, val
 812              	# kianv_stdlib.h:225:     *(p++) = val % 10;
 813 05e8 A30FD7FE 		sb	a3,-1(a4)	# tmp83, MEM[(char *)p_18 + 4294967295B]
 814 05ec 6FF09FFE 		j	.L123		#
 815              	.L131:
 816              	# kianv_stdlib.h:230:     while (!*((volatile uint32_t*) UART_READY))
 817 05f0 B7060030 		li	a3,805306368		# tmp88,
 818              	.L125:
 819              	# kianv_stdlib.h:230:     while (!*((volatile uint32_t*) UART_READY))
 820 05f4 83A70600 		lw	a5,0(a3)		# _3, MEM[(volatile uint32_t *)805306368B]
 821              	# kianv_stdlib.h:230:     while (!*((volatile uint32_t*) UART_READY))
 822 05f8 E38E07FE 		beq	a5,zero,.L125	#, _3,,
 823              	# kianv_stdlib.h:232:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 824 05fc 8347F7FF 		lbu	a5,-1(a4)	# MEM[(char *)p_16], MEM[(char *)p_16]
 825              	# kianv_stdlib.h:232:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 826 0600 1307F7FF 		addi	a4,a4,-1	#, p, p
 827              	# kianv_stdlib.h:232:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 828 0604 93870703 		addi	a5,a5,48	#, _7, MEM[(char *)p_16]
 829              	# kianv_stdlib.h:232:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 830 0608 23A0F600 		sw	a5,0(a3)	# _7, MEM[(volatile uint32_t *)805306368B]
 831              	# kianv_stdlib.h:229:   while (p != buffer) {
 832 060c E314C7FE 		bne	a4,a2,.L125	#, p, tmp92,
 833              	# kianv_stdlib.h:234: }
 834 0610 13010101 		addi	sp,sp,16	#,,
 835 0614 67800000 		jr	ra		#
 837              		.align	2
 838              		.globl	print_dec64
 840              	print_dec64:
 841 0618 130101FE 		addi	sp,sp,-32	#,,
 842              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 843 061c B7DECCCC 		li	t4,-858992640		# tmp258,
 844              	# kianv_stdlib.h:238:   char *p = buffer;
 845 0620 130EC100 		addi	t3,sp,12	#, tmp254,
 846              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 847 0624 37030010 		li	t1,268435456		# tmp255,
 848 0628 9388DECC 		addi	a7,t4,-819	#, tmp259, tmp258
 849              	# kianv_stdlib.h:236: void print_dec64(uint64_t val) {
 850 062c 13070500 		mv	a4,a0	# val, tmp261
 851 0630 13880500 		mv	a6,a1	# val, tmp262
 852              	# kianv_stdlib.h:238:   char *p = buffer;
 853 0634 13060E00 		mv	a2,t3	# p, tmp254
 854              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 855 0638 1303F3FF 		addi	t1,t1,-1	#, tmp256, tmp255
 856 063c 130F5000 		li	t5,5		# tmp257,
 857 0640 938ECECC 		addi	t4,t4,-820	#, tmp260, tmp258
 858              	# kianv_stdlib.h:239:   while (val || p == buffer) {
 859 0644 6F008005 		j	.L133		#
 860              	.L134:
 861              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 862 0648 B3F7E703 		remu	a5,a5,t5	# tmp257, tmp97, tmp94
 863              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 864 064c 13061600 		addi	a2,a2,1	#, p, p
 865              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 866 0650 B307F740 		sub	a5,a4,a5	# tmp214, val, tmp97
 867 0654 B335F700 		sgtu	a1,a5,a4	# tmp101, tmp214, val
 868 0658 B305B840 		sub	a1,a6,a1	# tmp103, val, tmp101
 869 065c 3385D703 		mul	a0,a5,t4	# tmp107, tmp214, tmp260
 870 0660 B3851503 		mul	a1,a1,a7	# tmp104, tmp103, tmp259
 871 0664 B3B61703 		mulhu	a3,a5,a7	# tmp217, tmp214, tmp259
 872 0668 B385A500 		add	a1,a1,a0	# tmp107, tmp110, tmp104
 873 066c B3871703 		mul	a5,a5,a7	# tmp114, tmp214, tmp259
 874 0670 B385D500 		add	a1,a1,a3	# tmp217, tmp115, tmp110
 875 0674 9396F501 		slli	a3,a1,31	#, tmp133, tmp115
 876              	# kianv_stdlib.h:241:     val = val / 10;
 877 0678 13D81500 		srli	a6,a1,1	#, val, tmp115
 878              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 879 067c 93D71700 		srli	a5,a5,1	#, tmp224, tmp114
 880 0680 B3E7F600 		or	a5,a3,a5	# tmp224, tmp224, tmp133
 881 0684 13952700 		slli	a0,a5,2	#, tmp228, tmp224
 882 0688 3305F500 		add	a0,a0,a5	# tmp224, tmp230, tmp228
 883 068c 13151500 		slli	a0,a0,1	#, tmp232, tmp230
 884 0690 3305A740 		sub	a0,a4,a0	# tmp234, val, tmp232
 885              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 886 0694 A30FA6FE 		sb	a0,-1(a2)	# tmp234, MEM[(char *)p_18 + 4294967295B]
 887              	# kianv_stdlib.h:241:     val = val / 10;
 888 0698 13870700 		mv	a4,a5	# val, tmp224
 889              	.L133:
 890              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 891 069c 93174800 		slli	a5,a6,4	#, tmp88, val
 892 06a0 9356C701 		srli	a3,a4,28	#, tmp208, val
 893 06a4 B3E6D700 		or	a3,a5,a3	# tmp208, tmp208, tmp88
 894 06a8 B3F66600 		and	a3,a3,t1	# tmp256, tmp89, tmp208
 895 06ac B3776700 		and	a5,a4,t1	# tmp256, tmp84, val
 896 06b0 B387D700 		add	a5,a5,a3	# tmp89, tmp92, tmp84
 897 06b4 93558801 		srli	a1,a6,24	#, tmp210, val
 898              	# kianv_stdlib.h:239:   while (val || p == buffer) {
 899 06b8 B3660701 		or	a3,a4,a6	# val, val, val
 900              	# kianv_stdlib.h:240:     *(p++) = val % 10;
 901 06bc B387B700 		add	a5,a5,a1	# tmp210, tmp94, tmp92
 902              	# kianv_stdlib.h:239:   while (val || p == buffer) {
 903 06c0 E39406F8 		bne	a3,zero,.L134	#, val,,
 904              	# kianv_stdlib.h:239:   while (val || p == buffer) {
 905 06c4 E302C6F9 		beq	a2,t3,.L134	#, p, tmp254,
 906              	# kianv_stdlib.h:245:     while (!*((volatile uint32_t*) UART_READY))
 907 06c8 37070030 		li	a4,805306368		# tmp202,
 908              	.L135:
 909              	# kianv_stdlib.h:245:     while (!*((volatile uint32_t*) UART_READY))
 910 06cc 83270700 		lw	a5,0(a4)		# _3, MEM[(volatile uint32_t *)805306368B]
 911              	# kianv_stdlib.h:245:     while (!*((volatile uint32_t*) UART_READY))
 912 06d0 E38E07FE 		beq	a5,zero,.L135	#, _3,,
 913              	# kianv_stdlib.h:247:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 914 06d4 8347F6FF 		lbu	a5,-1(a2)	# MEM[(char *)p_16], MEM[(char *)p_16]
 915              	# kianv_stdlib.h:247:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 916 06d8 1306F6FF 		addi	a2,a2,-1	#, p, p
 917              	# kianv_stdlib.h:247:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 918 06dc 93870703 		addi	a5,a5,48	#, _7, MEM[(char *)p_16]
 919              	# kianv_stdlib.h:247:     *((volatile uint32_t*) UART_TX) = '0' + *(--p);
 920 06e0 2320F700 		sw	a5,0(a4)	# _7, MEM[(volatile uint32_t *)805306368B]
 921              	# kianv_stdlib.h:244:   while (p != buffer) {
 922 06e4 E314C6FF 		bne	a2,t3,.L135	#, p, tmp254,
 923              	# kianv_stdlib.h:249: }
 924 06e8 13010102 		addi	sp,sp,32	#,,
 925 06ec 67800000 		jr	ra		#
 927              		.section	.rodata.str1.4,"aMS",@progbits,1
 928              		.align	2
 929              	.LC0:
 930 0000 30313233 		.string	"0123456789ABCDEF"
 930      34353637 
 930      38394142 
 930      43444546 
 930      00
 931              		.text
 932              		.align	2
 933              		.globl	print_hex
 935              	print_hex:
 936              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 937 06f0 9386F5FF 		addi	a3,a1,-1	#, tmp85, tmp98
 938              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 939 06f4 93962600 		slli	a3,a3,2	#, i, tmp85
 940              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 941 06f8 63CC0602 		blt	a3,zero,.L141	#, i,,
 942 06fc 37060000 		lui	a2,%hi(.LC0)	# tmp95,
 943 0700 9305C0FF 		li	a1,-4		# _8,
 944 0704 13060600 		addi	a2,a2,%lo(.LC0)	# tmp94, tmp95,
 945              	# kianv_stdlib.h:253:     while (!*((volatile uint32_t*) UART_READY))
 946 0708 37070030 		li	a4,805306368		# tmp87,
 947              	.L143:
 948              	# kianv_stdlib.h:253:     while (!*((volatile uint32_t*) UART_READY))
 949 070c 83270700 		lw	a5,0(a4)		# _2, MEM[(volatile uint32_t *)805306368B]
 950              	# kianv_stdlib.h:253:     while (!*((volatile uint32_t*) UART_READY))
 951 0710 E38E07FE 		beq	a5,zero,.L143	#, _2,,
 952              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 953 0714 B357D500 		srl	a5,a0,a3	# i, tmp90, val
 954              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 955 0718 93F7F700 		andi	a5,a5,15	#, tmp91, tmp90
 956              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 957 071c B307F600 		add	a5,a2,a5	# tmp91, tmp92, tmp94
 958 0720 83C70700 		lbu	a5,0(a5)	# _6, "0123456789ABCDEF"[_4]
 959              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 960 0724 9386C6FF 		addi	a3,a3,-4	#, i, i
 961              	# kianv_stdlib.h:255:     *((volatile uint32_t*) UART_TX) = "0123456789ABCDEF"[(val >> i) % 16];
 962 0728 2320F700 		sw	a5,0(a4)	# _6, MEM[(volatile uint32_t *)805306368B]
 963              	# kianv_stdlib.h:252:   for (int i = (4*digits)-4; i >= 0; i -= 4) {
 964 072c E390D5FE 		bne	a1,a3,.L143	#, _8, i,
 965              	.L141:
 966              	# kianv_stdlib.h:257: }
 967 0730 67800000 		ret	
 969              		.align	2
 970              		.globl	setpixel
 972              	setpixel:
 973              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 974 0734 B7070100 		li	a5,65536		# tmp88,
 975 0738 9387F7FF 		addi	a5,a5,-1	#, tmp87, tmp88
 976 073c 93958500 		slli	a1,a1,8	#, tmp85, tmp94
 977 0740 B3F5F500 		and	a1,a1,a5	# tmp87, tmp86, tmp85
 978              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 979 0744 93960601 		slli	a3,a3,16	#, tmp89, tmp96
 980              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 981 0748 B3E5D500 		or	a1,a1,a3	# tmp89, tmp90, tmp86
 982              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 983 074c 1376F60F 		andi	a2,a2,0xff	# tmp91, tmp95
 984              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 985 0750 B3E5C500 		or	a1,a1,a2	# tmp91, _9, tmp90
 986              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 987 0754 B7070030 		li	a5,805306368		# tmp93,
 988 0758 23A4B700 		sw	a1,8(a5)	# _9, MEM[(volatile uint32_t *)805306376B]
 989              	# kianv_stdlib.h:272: }
 990 075c 67800000 		ret	
 992              		.align	2
 993              		.globl	draw_bresenham
 995              	draw_bresenham:
 996 0760 130101FE 		addi	sp,sp,-32	#,,
 997              	# kianv_stdlib.h:277:   int dx =  abs(x1 - x0);
 998 0764 3385B640 		sub	a0,a3,a1	#, x1, x0
 999              	# kianv_stdlib.h:275: {
 1000 0768 232E1100 		sw	ra,28(sp)	#,
 1001 076c 232C8100 		sw	s0,24(sp)	#,
 1002 0770 232A9100 		sw	s1,20(sp)	#,
 1003 0774 13840500 		mv	s0,a1	# x0, tmp114
 1004 0778 93040600 		mv	s1,a2	# y0, tmp115
 1005 077c 23282101 		sw	s2,16(sp)	#,
 1006 0780 23263101 		sw	s3,12(sp)	#,
 1007 0784 23244101 		sw	s4,8(sp)	#,
 1008 0788 93890700 		mv	s3,a5	# color, tmp118
 1009 078c 138A0600 		mv	s4,a3	# x1, tmp116
 1010 0790 23225101 		sw	s5,4(sp)	#,
 1011 0794 23206101 		sw	s6,0(sp)	#,
 1012              	# kianv_stdlib.h:275: {
 1013 0798 130B0700 		mv	s6,a4	# y1, tmp117
 1014              	# kianv_stdlib.h:277:   int dx =  abs(x1 - x0);
 1015 079c 97000000 		call	abs		#
 1015      E7800000 
 1016 07a4 13090500 		mv	s2,a0	# tmp119,
 1017              	# kianv_stdlib.h:279:   int dy = -abs(y1 - y0);
 1018 07a8 33059B40 		sub	a0,s6,s1	#, y1, y0
 1019 07ac 97000000 		call	abs		#
 1019      E7800000 
 1020              	# kianv_stdlib.h:278:   int sx = x0 < x1 ? 1 : -1;
 1021 07b4 B32A4401 		sgt	s5,s4,s0	# tmp109, x1, x0
 1022              	# kianv_stdlib.h:280:   int sy = y0 < y1 ? 1 : -1;
 1023 07b8 33AF6401 		sgt	t5,s6,s1	# tmp112, y1, y0
 1024              	# kianv_stdlib.h:278:   int sx = x0 < x1 ? 1 : -1;
 1025 07bc 939A1A00 		slli	s5,s5,1	#, iftmp.6_9, tmp109
 1026              	# kianv_stdlib.h:280:   int sy = y0 < y1 ? 1 : -1;
 1027 07c0 131F1F00 		slli	t5,t5,1	#, iftmp.7_10, tmp112
 1028              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1029 07c4 B7060100 		li	a3,65536		# tmp103,
 1030              	# kianv_stdlib.h:278:   int sx = x0 < x1 ? 1 : -1;
 1031 07c8 938AFAFF 		addi	s5,s5,-1	#, iftmp.6_9, iftmp.6_9
 1032              	# kianv_stdlib.h:279:   int dy = -abs(y1 - y0);
 1033 07cc B30EA040 		neg	t4,a0	# dy, _3
 1034              	# kianv_stdlib.h:280:   int sy = y0 < y1 ? 1 : -1;
 1035 07d0 130FFFFF 		addi	t5,t5,-1	#, iftmp.7_10, iftmp.7_10
 1036 07d4 3308A940 		sub	a6,s2,a0	# err, dx, _3
 1037              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1038 07d8 13930901 		slli	t1,s3,16	#, _33, color
 1039 07dc 93F8F40F 		andi	a7,s1,255	#, tmp106, y0
 1040 07e0 93158400 		slli	a1,s0,8	#, tmp107, x0
 1041              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1042 07e4 9386F6FF 		addi	a3,a3,-1	#, tmp102, tmp103
 1043              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1044 07e8 370E0030 		li	t3,805306368		# tmp105,
 1045              	.L152:
 1046              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1047 07ec B3E76800 		or	a5,a7,t1	# _33, tmp99, tmp106
 1048              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1049 07f0 33F6D500 		and	a2,a1,a3	# tmp102, tmp101, tmp107
 1050              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1051 07f4 B3E7C700 		or	a5,a5,a2	# tmp101, _40, tmp99
 1052              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1053 07f8 2324FE00 		sw	a5,8(t3)	# _40, MEM[(volatile uint32_t *)805306376B]
 1054              	# kianv_stdlib.h:286:     e2 = 2*err;
 1055 07fc 93171800 		slli	a5,a6,1	#, e2, err
 1056              	# kianv_stdlib.h:285:     if (x0 == x1 && y0 == y1) break;
 1057 0800 630E4403 		beq	s0,s4,.L160	#, x0, x1,
 1058              	.L153:
 1059              	# kianv_stdlib.h:287:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 1060 0804 63C8D701 		bgt	t4,a5,.L155	#, dy, e2,
 1061              	# kianv_stdlib.h:287:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 1062 0808 33045401 		add	s0,s0,s5	# iftmp.6_9, x0, x0
 1063 080c 3308A840 		sub	a6,a6,a0	# err, err, _3
 1064 0810 93158400 		slli	a1,s0,8	#, tmp107, x0
 1065              	.L155:
 1066              	# kianv_stdlib.h:288:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 1067 0814 E34CF9FC 		blt	s2,a5,.L152	#, dx, e2,
 1068              	# kianv_stdlib.h:288:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 1069 0818 B384E401 		add	s1,s1,t5	# iftmp.7_10, y0, y0
 1070 081c 93F8F40F 		andi	a7,s1,255	#, tmp106, y0
 1071              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1072 0820 B3E76800 		or	a5,a7,t1	# _33, tmp99, tmp106
 1073              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1074 0824 33F6D500 		and	a2,a1,a3	# tmp102, tmp101, tmp107
 1075              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1076 0828 B3E7C700 		or	a5,a5,a2	# tmp101, _40, tmp99
 1077              	# kianv_stdlib.h:288:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 1078 082c 33082801 		add	a6,a6,s2	# dx, err, err
 1079              	# kianv_stdlib.h:271: *((volatile uint32_t*) VIDEO) = (((uint32_t) color & 0xffff) << 16Ul) | ((x &
 1080 0830 2324FE00 		sw	a5,8(t3)	# _40, MEM[(volatile uint32_t *)805306376B]
 1081              	# kianv_stdlib.h:286:     e2 = 2*err;
 1082 0834 93171800 		slli	a5,a6,1	#, e2, err
 1083              	# kianv_stdlib.h:285:     if (x0 == x1 && y0 == y1) break;
 1084 0838 E31644FD 		bne	s0,s4,.L153	#, x0, x1,
 1085              	.L160:
 1086              	# kianv_stdlib.h:285:     if (x0 == x1 && y0 == y1) break;
 1087 083c E39464FD 		bne	s1,s6,.L153	#, y0, y1,
 1088              	# kianv_stdlib.h:290: }
 1089 0840 8320C101 		lw	ra,28(sp)		#,
 1090 0844 03248101 		lw	s0,24(sp)		#,
 1091 0848 83244101 		lw	s1,20(sp)		#,
 1092 084c 03290101 		lw	s2,16(sp)		#,
 1093 0850 8329C100 		lw	s3,12(sp)		#,
 1094 0854 032A8100 		lw	s4,8(sp)		#,
 1095 0858 832A4100 		lw	s5,4(sp)		#,
 1096 085c 032B0100 		lw	s6,0(sp)		#,
 1097 0860 13010102 		addi	sp,sp,32	#,,
 1098 0864 67800000 		jr	ra		#
 1100              		.align	2
 1101              		.globl	time
 1103              	time:
 1104              	# stdlib.c:33: 	asm volatile ("rdcycle %0" : "=r"(cycles));
 1105              	 #APP
 1106              	# 33 "stdlib.c" 1
   1              	// This is free and unencumbered software released into the public domain.
   2              	//
   3              	// Anyone is free to copy, modify, publish, use, compile, sell, or
   4              	// distribute this software, either in source code form or as a compiled
   5              	// binary, for any purpose, commercial or non-commercial, and by any
   6              	// means.
   7              	
   8              	#ifndef KV_STDLIB_H
   9              	#define KV_STDLIB_H
  10              	
  11              	#include <stdarg.h>
  12              	#include <stdint.h>
  13              	#include "kianv_stdlib.h"
  14              	extern long time();
  15              	extern long insn();
  16              	
  17              	#if defined(NOT_USE_MYSTDLIB)
  18              	#else
  19              	extern char *malloc();
  20              	extern int printf(const char *format, ...);
  21              	
  22              	extern void *memcpy(void *dest, const void *src, long n);
  23              	extern char *strcpy(char *dest, const char *src);
  24              	extern int strcmp(const char *s1, const char *s2);
  25              	
  26              	char heap_memory[1024];
  27              	int heap_memory_used = 0;
  28              	#endif
  29              	
  30              	long time()
  31              	{
  32              		int cycles;
  33 0868 732500C0 		asm volatile ("rdcycle %0" : "=r"(cycles));
  34              		// printf("[time() -> %d]", cycles);
 1107              		rdcycle a0	# cycles
 1108              	# 0 "" 2
 1109              	# stdlib.c:36: }
 1110              	 #NO_APP
 1111 086c 67800000 		ret	
 1113              		.align	2
 1114              		.globl	insn
 1116              	insn:
 1117              	# stdlib.c:41: 	asm volatile ("rdinstret %0" : "=r"(insns));
 1118              	 #APP
 1119              	# 41 "stdlib.c" 1
  35              		return cycles;
  36              	}
  37              	
  38              	long insn()
  39              	{
  40              		int insns;
  41 0870 732520C0 		asm volatile ("rdinstret %0" : "=r"(insns));
  42              		// printf("[insn() -> %d]", insns);
 1120              		rdinstret a0	# insns
 1121              	# 0 "" 2
 1122              	# stdlib.c:44: }
 1123              	 #NO_APP
 1124 0874 67800000 		ret	
 1126              		.align	2
 1127              		.globl	printf
 1129              	printf:
 1130 0878 130101FA 		addi	sp,sp,-96	#,,
 1131 087c 232E8102 		sw	s0,60(sp)	#,
 1132              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1133 0880 03430500 		lbu	t1,0(a0)	# _14, *format_22(D)
 1134              	# stdlib.c:90: {
 1135 0884 232AF104 		sw	a5,84(sp)	#,
 1136              	# stdlib.c:94: 	va_start(ap, format);
 1137 0888 93074104 		addi	a5,sp,68	#, tmp119,
 1138              	# stdlib.c:90: {
 1139 088c 2322B104 		sw	a1,68(sp)	#,
 1140 0890 2324C104 		sw	a2,72(sp)	#,
 1141 0894 2326D104 		sw	a3,76(sp)	#,
 1142 0898 2328E104 		sw	a4,80(sp)	#,
 1143 089c 232C0105 		sw	a6,88(sp)	#,
 1144 08a0 232E1105 		sw	a7,92(sp)	#,
 1145              	# stdlib.c:94: 	va_start(ap, format);
 1146 08a4 2326F100 		sw	a5,12(sp)	# tmp119, MEM[(void * *)&ap]
 1147              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1148 08a8 630A0304 		beq	t1,zero,.L164	#, _14,,
 1149              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1150 08ac 93060000 		li	a3,0		# i,
 1151              	# stdlib.c:97: 		if (format[i] == '%') {
 1152 08b0 93035002 		li	t2,37		# tmp120,
 1153              	# stdlib.c:99: 				if (format[i] == 'c') {
 1154 08b4 93083006 		li	a7,99		# tmp205,
 1155              	# stdlib.c:103: 				if (format[i] == 's') {
 1156 08b8 130E3007 		li	t3,115		# tmp206,
 1157              	# stdlib.c:107: 				if (format[i] == 'd') {
 1158 08bc 930E4006 		li	t4,100		# tmp207,
 1159              	# stdlib.c:111: 				if (format[i] == 'u') {
 1160 08c0 130F5007 		li	t5,117		# tmp208,
 1161              	# stdlib.c:78: 	char *p = buffer;
 1162 08c4 930F0101 		addi	t6,sp,16	#, tmp213,
 1163              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 1164 08c8 9305A000 		li	a1,10		# tmp214,
 1165              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1166 08cc B7070030 		li	a5,805306368		# tmp215,
 1167              	# kianv_stdlib.h:195:    if (c == 13) {
 1168 08d0 9302D000 		li	t0,13		# tmp216,
 1169              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1170 08d4 1304D002 		li	s0,45		# tmp218,
 1171              	.L189:
 1172              	# stdlib.c:97: 		if (format[i] == '%') {
 1173 08d8 63027304 		beq	t1,t2,.L165	#, _14, tmp120,
 1174              	.L166:
 1175              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1176 08dc 03A70700 		lw	a4,0(a5)		# _42, MEM[(volatile uint32_t *)805306368B]
 1177              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1178 08e0 E30E07FE 		beq	a4,zero,.L166	#, _42,,
 1179              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1180 08e4 23A06700 		sw	t1,0(a5)	# _14, MEM[(volatile uint32_t *)805306368B]
 1181              	# kianv_stdlib.h:195:    if (c == 13) {
 1182 08e8 63085306 		beq	t1,t0,.L218	#, _14, tmp216,
 1183              	.L169:
 1184              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1185 08ec 93861600 		addi	a3,a3,1	#, i, i
 1186              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1187 08f0 3307D500 		add	a4,a0,a3	# i, tmp193, format
 1188 08f4 03430700 		lbu	t1,0(a4)	# _14, *_13
 1189              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1190 08f8 E31003FE 		bne	t1,zero,.L189	#, _14,,
 1191              	.L164:
 1192              	# stdlib.c:121: }
 1193 08fc 0324C103 		lw	s0,60(sp)		#,
 1194 0900 13050000 		li	a0,0		#,
 1195 0904 13010106 		addi	sp,sp,96	#,,
 1196 0908 67800000 		jr	ra		#
 1197              	.L188:
 1198              	# stdlib.c:99: 				if (format[i] == 'c') {
 1199 090c 63021703 		beq	a4,a7,.L219	#, _10, tmp205,
 1200              	# stdlib.c:103: 				if (format[i] == 's') {
 1201 0910 6308C705 		beq	a4,t3,.L220	#, _10, tmp206,
 1202              	# stdlib.c:107: 				if (format[i] == 'd') {
 1203 0914 6304D709 		beq	a4,t4,.L221	#, _10, tmp207,
 1204              	# stdlib.c:111: 				if (format[i] == 'u') {
 1205 0918 6300E711 		beq	a4,t5,.L222	#, _10, tmp208,
 1206              	.L165:
 1207              	# stdlib.c:98: 			while (format[++i]) {
 1208 091c 93861600 		addi	a3,a3,1	#, i, i
 1209              	# stdlib.c:98: 			while (format[++i]) {
 1210 0920 3307D500 		add	a4,a0,a3	# i, tmp187, format
 1211 0924 03470700 		lbu	a4,0(a4)	# _10, MEM[(const char *)_131]
 1212              	# stdlib.c:98: 			while (format[++i]) {
 1213 0928 E31207FE 		bne	a4,zero,.L188	#, _10,,
 1214 092c 6FF01FFC 		j	.L169		#
 1215              	.L219:
 1216              	# stdlib.c:100: 					printf_c(va_arg(ap,int));
 1217 0930 0327C100 		lw	a4,12(sp)		# D.2659, ap
 1218 0934 03260700 		lw	a2,0(a4)		# _4, MEM[(int *)_121]
 1219 0938 13074700 		addi	a4,a4,4	#, D.2660, D.2659
 1220 093c 2326E100 		sw	a4,12(sp)	# D.2660, ap
 1221              	# stdlib.c:49:     print_chr(c);
 1222 0940 1378F60F 		andi	a6,a2,0xff	# _33, _4
 1223              	.L168:
 1224              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1225 0944 03A70700 		lw	a4,0(a5)		# _34, MEM[(volatile uint32_t *)805306368B]
 1226              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1227 0948 E30E07FE 		beq	a4,zero,.L168	#, _34,,
 1228              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1229 094c 1376F60F 		andi	a2,a2,255	#, _36, _4
 1230 0950 23A0C700 		sw	a2,0(a5)	# _36, MEM[(volatile uint32_t *)805306368B]
 1231              	# kianv_stdlib.h:195:    if (c == 13) {
 1232 0954 E31C58F8 		bne	a6,t0,.L169	#, _33, tmp216,
 1233              	.L218:
 1234              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 1235 0958 23A0B700 		sw	a1,0(a5)	# tmp214,
 1236 095c 6FF01FF9 		j	.L169		#
 1237              	.L220:
 1238              	# stdlib.c:104: 					printf_s(va_arg(ap,char*));
 1239 0960 0327C100 		lw	a4,12(sp)		# D.2661, ap
 1240 0964 03280700 		lw	a6,0(a4)		# p, MEM[(char * *)_87]
 1241 0968 13074700 		addi	a4,a4,4	#, D.2662, D.2661
 1242 096c 2326E100 		sw	a4,12(sp)	# D.2662, ap
 1243              	.L217:
 1244              	# stdlib.c:54: 	while (*p)
 1245 0970 03460800 		lbu	a2,0(a6)	# _40,* p
 1246 0974 E30C06F6 		beq	a2,zero,.L169	#, _40,,
 1247              	.L174:
 1248              	# stdlib.c:56:     print_chr(*(p++));
 1249 0978 13081800 		addi	a6,a6,1	#, p, p
 1250              	.L171:
 1251              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1252 097c 03A70700 		lw	a4,0(a5)		# _39, MEM[(volatile uint32_t *)805306368B]
 1253              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1254 0980 E30E07FE 		beq	a4,zero,.L171	#, _39,,
 1255              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1256 0984 23A0C700 		sw	a2,0(a5)	# _40, MEM[(volatile uint32_t *)805306368B]
 1257              	# kianv_stdlib.h:195:    if (c == 13) {
 1258 0988 E31456FE 		bne	a2,t0,.L217	#, _40, tmp216,
 1259              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 1260 098c 23A0B700 		sw	a1,0(a5)	# tmp214, MEM[(volatile uint32_t *)805306368B]
 1261              	# stdlib.c:54: 	while (*p)
 1262 0990 03460800 		lbu	a2,0(a6)	# _40,* p
 1263 0994 E31206FE 		bne	a2,zero,.L174	#, _40,,
 1264 0998 6FF05FF5 		j	.L169		#
 1265              	.L221:
 1266              	# stdlib.c:108: 					printf_d(va_arg(ap,int));
 1267 099c 0326C100 		lw	a2,12(sp)		# D.2663, ap
 1268 09a0 03270600 		lw	a4,0(a2)		# val, MEM[(int *)_122]
 1269 09a4 13064600 		addi	a2,a2,4	#, D.2664, D.2663
 1270 09a8 2326C100 		sw	a2,12(sp)	# D.2664, ap
 1271              	# stdlib.c:63: 	if (val < 0) {
 1272 09ac 63440702 		blt	a4,zero,.L177	#, val,,
 1273              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1274 09b0 13860F00 		mv	a2,t6	# p, tmp213
 1275              	.L178:
 1276              	# stdlib.c:67: 	while (val || p == buffer) {
 1277 09b4 63140700 		bne	a4,zero,.L179	#, val,,
 1278 09b8 6310F605 		bne	a2,t6,.L182	#, p, tmp213,
 1279              	.L179:
 1280              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 1281 09bc 3368B702 		rem	a6,a4,a1	# tmp214, tmp145, val
 1282              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 1283 09c0 13061600 		addi	a2,a2,1	#, p, p
 1284              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 1285 09c4 13080803 		addi	a6,a6,48	#, tmp147, tmp145
 1286              	# stdlib.c:69: 		val = val / 10;
 1287 09c8 3347B702 		div	a4,a4,a1	# tmp214, val, val
 1288              	# stdlib.c:68: 		*(p++) = '0' + val % 10;
 1289 09cc A30F06FF 		sb	a6,-1(a2)	# tmp147, MEM[(char *)p_59 + 4294967295B]
 1290 09d0 6FF05FFE 		j	.L178		#
 1291              	.L177:
 1292              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1293 09d4 03A60700 		lw	a2,0(a5)		# _53, MEM[(volatile uint32_t *)805306368B]
 1294              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1295 09d8 E30E06FE 		beq	a2,zero,.L177	#, _53,,
 1296              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1297 09dc 23A08700 		sw	s0,0(a5)	# tmp218, MEM[(volatile uint32_t *)805306368B]
 1298              	# stdlib.c:65: 		val = -val;
 1299 09e0 3307E040 		neg	a4,a4	# val, val
 1300              	# stdlib.c:96: 	for (i = 0; format[i]; i++)
 1301 09e4 13860F00 		mv	a2,t6	# p, tmp213
 1302 09e8 6FF0DFFC 		j	.L178		#
 1303              	.L224:
 1304              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1305 09ec 23A00701 		sw	a6,0(a5)	# _64, MEM[(volatile uint32_t *)805306368B]
 1306              	# kianv_stdlib.h:195:    if (c == 13) {
 1307 09f0 630E5800 		beq	a6,t0,.L223	#, _64, tmp216,
 1308              	# stdlib.c:71: 	while (p != buffer)
 1309 09f4 E30CF6EF 		beq	a2,t6,.L169	#, p, tmp213,
 1310              	.L182:
 1311              	# stdlib.c:72: 		printf_c(*(--p));
 1312 09f8 0348F6FF 		lbu	a6,-1(a2)	# _64, MEM[(char *)p_63]
 1313              	# stdlib.c:72: 		printf_c(*(--p));
 1314 09fc 1306F6FF 		addi	a2,a2,-1	#, p, p
 1315              	.L180:
 1316              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1317 0a00 03A70700 		lw	a4,0(a5)		# _65, MEM[(volatile uint32_t *)805306368B]
 1318              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1319 0a04 E30E07FE 		beq	a4,zero,.L180	#, _65,,
 1320 0a08 6FF05FFE 		j	.L224		#
 1321              	.L223:
 1322              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 1323 0a0c 23A0B700 		sw	a1,0(a5)	# tmp214, MEM[(volatile uint32_t *)805306368B]
 1324              	# stdlib.c:71: 	while (p != buffer)
 1325 0a10 E314F6FF 		bne	a2,t6,.L182	#, p, tmp213,
 1326 0a14 6FF09FED 		j	.L169		#
 1327              	.L222:
 1328              	# stdlib.c:112: 					printf_u(va_arg(ap,int));
 1329 0a18 0328C100 		lw	a6,12(sp)		# D.2665, ap
 1330              	# stdlib.c:78: 	char *p = buffer;
 1331 0a1c 13860F00 		mv	a2,t6	# p, tmp213
 1332              	# stdlib.c:80:   val = val >= 0 ? val : -val;
 1333 0a20 03270800 		lw	a4,0(a6)		# MEM[(int *)_125], MEM[(int *)_125]
 1334              	# stdlib.c:112: 					printf_u(va_arg(ap,int));
 1335 0a24 13084800 		addi	a6,a6,4	#, D.2666, D.2665
 1336 0a28 23260101 		sw	a6,12(sp)	# D.2666, ap
 1337              	# stdlib.c:80:   val = val >= 0 ? val : -val;
 1338 0a2c 1358F741 		srai	a6,a4,31	#, tmp163, MEM[(int *)_125]
 1339 0a30 3347E800 		xor	a4,a6,a4	# MEM[(int *)_125], val, tmp163
 1340 0a34 33070741 		sub	a4,a4,a6	# val, val, tmp163
 1341              	.L183:
 1342              	# stdlib.c:81: 	while (val || p == buffer) {
 1343 0a38 63140700 		bne	a4,zero,.L184	#, val,,
 1344 0a3c 6314F603 		bne	a2,t6,.L187	#, p, tmp213,
 1345              	.L184:
 1346              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 1347 0a40 3368B702 		rem	a6,a4,a1	# tmp214, tmp171, val
 1348              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 1349 0a44 13061600 		addi	a2,a2,1	#, p, p
 1350              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 1351 0a48 13080803 		addi	a6,a6,48	#, tmp173, tmp171
 1352              	# stdlib.c:83: 		val = val / 10;
 1353 0a4c 3347B702 		div	a4,a4,a1	# tmp214, val, val
 1354              	# stdlib.c:82: 		*(p++) = '0' + val % 10;
 1355 0a50 A30F06FF 		sb	a6,-1(a2)	# tmp173, MEM[(char *)p_75 + 4294967295B]
 1356 0a54 6FF05FFE 		j	.L183		#
 1357              	.L226:
 1358              	# kianv_stdlib.h:194:   *((volatile uint32_t*) UART_TX) = c;
 1359 0a58 23A00701 		sw	a6,0(a5)	# _80, MEM[(volatile uint32_t *)805306368B]
 1360              	# kianv_stdlib.h:195:    if (c == 13) {
 1361 0a5c 630E5800 		beq	a6,t0,.L225	#, _80, tmp216,
 1362              	# stdlib.c:85: 	while (p != buffer)
 1363 0a60 E306F6E9 		beq	a2,t6,.L169	#, p, tmp213,
 1364              	.L187:
 1365              	# stdlib.c:86: 		printf_c(*(--p));
 1366 0a64 0348F6FF 		lbu	a6,-1(a2)	# _80, MEM[(char *)p_79]
 1367              	# stdlib.c:86: 		printf_c(*(--p));
 1368 0a68 1306F6FF 		addi	a2,a2,-1	#, p, p
 1369              	.L185:
 1370              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1371 0a6c 03A70700 		lw	a4,0(a5)		# _81, MEM[(volatile uint32_t *)805306368B]
 1372              	# kianv_stdlib.h:192:   while (!*((volatile uint32_t*) UART_READY))
 1373 0a70 E30E07FE 		beq	a4,zero,.L185	#, _81,,
 1374 0a74 6FF05FFE 		j	.L226		#
 1375              	.L225:
 1376              	# kianv_stdlib.h:196:     *((volatile uint32_t*) UART_TX) = 10;
 1377 0a78 23A0B700 		sw	a1,0(a5)	# tmp214, MEM[(volatile uint32_t *)805306368B]
 1378              	# stdlib.c:85: 	while (p != buffer)
 1379 0a7c E314F6FF 		bne	a2,t6,.L187	#, p, tmp213,
 1380 0a80 6FF0DFE6 		j	.L169		#
 1382              		.align	2
 1383              		.globl	malloc
 1385              	malloc:
 1386              	# stdlib.c:126: 	char *p = heap_memory + heap_memory_used;
 1387 0a84 B7060000 		lui	a3,%hi(heap_memory_used)	# tmp77,
 1388 0a88 03A70600 		lw	a4,%lo(heap_memory_used)(a3)		# heap_memory_used.19_1, heap_memory_used
 1389              	# stdlib.c:128: 	heap_memory_used += size;
 1390 0a8c B307A700 		add	a5,a4,a0	# tmp83, _3, heap_memory_used.19_1
 1391              	# stdlib.c:126: 	char *p = heap_memory + heap_memory_used;
 1392 0a90 37050000 		lui	a0,%hi(.LANCHOR0)	# tmp79,
 1393              	# stdlib.c:128: 	heap_memory_used += size;
 1394 0a94 23A0F600 		sw	a5,%lo(heap_memory_used)(a3)	# _3, heap_memory_used
 1395              	# stdlib.c:126: 	char *p = heap_memory + heap_memory_used;
 1396 0a98 13050500 		addi	a0,a0,%lo(.LANCHOR0)	# tmp78, tmp79,
 1397              	# stdlib.c:129: 	if (heap_memory_used > 1024)
 1398 0a9c 93060040 		li	a3,1024		# tmp81,
 1399              	# stdlib.c:126: 	char *p = heap_memory + heap_memory_used;
 1400 0aa0 3305E500 		add	a0,a0,a4	# heap_memory_used.19_1, <retval>, tmp78
 1401              	# stdlib.c:129: 	if (heap_memory_used > 1024)
 1402 0aa4 63D4F600 		ble	a5,a3,.L227	#, _3, tmp81,
 1403              	# stdlib.c:130: 		asm volatile ("ebreak");
 1404              	 #APP
 1405              	# 130 "stdlib.c" 1
  43              		return insns;
  44              	}
  45              	
  46              	static void printf_c(int c)
  47              	{
  48              		//*((volatile int*)0x10000000) = c;
  49              	    print_chr(c);
  50              	}
  51              	
  52              	static void printf_s(char *p)
  53              	{
  54              		while (*p)
  55              			//*((volatile int*)0x10000000) = *(p++);
  56              	    print_chr(*(p++));
  57              	}
  58              	
  59              	static void printf_d(int val)
  60              	{
  61              		char buffer[32];
  62              		char *p = buffer;
  63              		if (val < 0) {
  64              			printf_c('-');
  65              			val = -val;
  66              		}
  67              		while (val || p == buffer) {
  68              			*(p++) = '0' + val % 10;
  69              			val = val / 10;
  70              		}
  71              		while (p != buffer)
  72              			printf_c(*(--p));
  73              	}
  74              	
  75              	static void printf_u(int val)
  76              	{
  77              		char buffer[32];
  78              		char *p = buffer;
  79              	
  80              	  val = val >= 0 ? val : -val;
  81              		while (val || p == buffer) {
  82              			*(p++) = '0' + val % 10;
  83              			val = val / 10;
  84              		}
  85              		while (p != buffer)
  86              			printf_c(*(--p));
  87              	}
  88              	
  89              	int printf(const char *format, ...)
  90              	{
  91              		int i;
  92              		va_list ap;
  93              	
  94              		va_start(ap, format);
  95              	
  96              		for (i = 0; format[i]; i++)
  97              			if (format[i] == '%') {
  98              				while (format[++i]) {
  99              					if (format[i] == 'c') {
 100              						printf_c(va_arg(ap,int));
 101              						break;
 102              					}
 103              					if (format[i] == 's') {
 104              						printf_s(va_arg(ap,char*));
 105              						break;
 106              					}
 107              					if (format[i] == 'd') {
 108              						printf_d(va_arg(ap,int));
 109              						break;
 110              					}
 111              					if (format[i] == 'u') {
 112              						printf_u(va_arg(ap,int));
 113              						break;
 114              					}
 115              				}
 116              			} else
 117              				printf_c(format[i]);
 118              	
 119              		va_end(ap);
 120              	  return 0;
 121              	}
 122              	
 123              	#if !defined(NOT_USE_MYSTDLIB)
 124              	char *malloc(int size)
 125              	{
 126              		char *p = heap_memory + heap_memory_used;
 127              		// printf("[malloc(%d) -> %d (%d..%d)]", size, (int)p, heap_memory_used, heap_memory_used + size);
 128              		heap_memory_used += size;
 129              		if (heap_memory_used > 1024)
 130 0aa8 73001000 			asm volatile ("ebreak");
 131              		return p;
 1406              		ebreak
 1407              	# 0 "" 2
 1408              	 #NO_APP
 1409              	.L227:
 1410              	# stdlib.c:132: }
 1411 0aac 67800000 		ret	
 1413              		.align	2
 1414              		.globl	memcpy
 1416              	memcpy:
 1417              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1418 0ab0 9308F6FF 		addi	a7,a2,-1	#, n, n
 1419              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1420 0ab4 6306060A 		beq	a2,zero,.L230	#, n,,
 1421 0ab8 13871500 		addi	a4,a1,1	#, bb, bb
 1422 0abc B307E540 		sub	a5,a0,a4	# tmp111, aa, bb
 1423 0ac0 93B73700 		sltiu	a5,a5,3	#, tmp114, tmp111
 1424 0ac4 93B67800 		sltiu	a3,a7,7	#, tmp117, n
 1425 0ac8 93C71700 		xori	a5,a5,1	#, tmp113, tmp114
 1426 0acc 93C61600 		xori	a3,a3,1	#, tmp116, tmp117
 1427 0ad0 B3F7D700 		and	a5,a5,a3	# tmp116, tmp120, tmp113
 1428 0ad4 63880706 		beq	a5,zero,.L231	#, tmp120,,
 1429 0ad8 B367B500 		or	a5,a0,a1	# bb, tmp121, aa
 1430 0adc 93F73700 		andi	a5,a5,3	#, tmp122, tmp121
 1431 0ae0 63920706 		bne	a5,zero,.L231	#, tmp122,,
 1432 0ae4 1378C6FF 		andi	a6,a2,-4	#, tmp127, n
 1433 0ae8 93870500 		mv	a5,a1	# ivtmp.330, bb
 1434 0aec 13070500 		mv	a4,a0	# ivtmp.333, aa
 1435 0af0 3308B800 		add	a6,a6,a1	# bb, _77, tmp127
 1436              	.L232:
 1437              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1438 0af4 83A60700 		lw	a3,0(a5)		# vect__1.316, MEM <const vector(4) char> [(const char *)_43]
 1439 0af8 93874700 		addi	a5,a5,4	#, ivtmp.330, ivtmp.330
 1440 0afc 13074700 		addi	a4,a4,4	#, ivtmp.333, ivtmp.333
 1441              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1442 0b00 232ED7FE 		sw	a3,-4(a4)	# vect__1.316, MEM <vector(4) char> [(char *)_45]
 1443 0b04 E39807FF 		bne	a5,a6,.L232	#, ivtmp.330, _77,
 1444 0b08 9377C6FF 		andi	a5,a2,-4	#, niters_vector_mult_vf.310, n
 1445 0b0c 3307F500 		add	a4,a0,a5	# niters_vector_mult_vf.310, tmp.311, aa
 1446 0b10 B385F500 		add	a1,a1,a5	# niters_vector_mult_vf.310, tmp.312, bb
 1447 0b14 B388F840 		sub	a7,a7,a5	# tmp.313, n, niters_vector_mult_vf.310
 1448 0b18 6304F604 		beq	a2,a5,.L230	#, n, niters_vector_mult_vf.310,
 1449              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1450 0b1c 83C70500 		lbu	a5,0(a1)	# _10, *tmp.312_55
 1451              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1452 0b20 2300F700 		sb	a5,0(a4)	# _10, *tmp.311_54
 1453              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1454 0b24 638E0802 		beq	a7,zero,.L230	#, tmp.313,,
 1455              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1456 0b28 83C61500 		lbu	a3,1(a1)	# _72, MEM[(const char *)tmp.312_55 + 1B]
 1457              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1458 0b2c 93071000 		li	a5,1		# tmp128,
 1459              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1460 0b30 A300D700 		sb	a3,1(a4)	# _72, MEM[(char *)tmp.311_54 + 1B]
 1461              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1462 0b34 6386F802 		beq	a7,a5,.L230	#, tmp.313, tmp128,
 1463              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1464 0b38 83C72500 		lbu	a5,2(a1)	# _48, MEM[(const char *)tmp.312_55 + 2B]
 1465              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1466 0b3c 2301F700 		sb	a5,2(a4)	# _48, MEM[(char *)tmp.311_54 + 2B]
 1467 0b40 67800000 		ret	
 1468              	.L231:
 1469 0b44 3306C500 		add	a2,a0,a2	# n, _23, aa
 1470              	# stdlib.c:138: 	char *a = (char *) aa;
 1471 0b48 93070500 		mv	a5,a0	# a, aa
 1472              	.L234:
 1473              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1474 0b4c 8346F7FF 		lbu	a3,-1(a4)	# _37, MEM[(const char *)b_35 + 4294967295B]
 1475              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1476 0b50 93871700 		addi	a5,a5,1	#, a, a
 1477 0b54 13071700 		addi	a4,a4,1	#, bb, bb
 1478              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1479 0b58 A38FD7FE 		sb	a3,-1(a5)	# _37, MEM[(char *)a_36 + 4294967295B]
 1480              	# stdlib.c:140: 	while (n--) *(a++) = *(b++);
 1481 0b5c E318F6FE 		bne	a2,a5,.L234	#, _23, a,
 1482              	.L230:
 1483              	# stdlib.c:142: }
 1484 0b60 67800000 		ret	
 1486              		.align	2
 1487              		.globl	strcpy
 1489              	strcpy:
 1490              	# stdlib.c:148: 	while ((((uint32_t)dst | (uint32_t)src) & 3) != 0)
 1491 0b64 93070500 		mv	a5,a0	# dst, dst
 1492 0b68 6F008001 		j	.L251		#
 1493              	.L253:
 1494              	# stdlib.c:150: 		char c = *(src++);
 1495 0b6c 03C70500 		lbu	a4,0(a1)	# c, MEM[(const char *)src_40 + 4294967295B]
 1496              	# stdlib.c:151: 		*(dst++) = c;
 1497 0b70 93871700 		addi	a5,a5,1	#, dst, dst
 1498              	# stdlib.c:150: 		char c = *(src++);
 1499 0b74 93851500 		addi	a1,a1,1	#, src, src
 1500              	# stdlib.c:151: 		*(dst++) = c;
 1501 0b78 A38FE7FE 		sb	a4,-1(a5)	# c, MEM[(char *)dst_42 + 4294967295B]
 1502              	# stdlib.c:152: 		if (!c) return r;
 1503 0b7c 63040708 		beq	a4,zero,.L255	#, c,,
 1504              	.L251:
 1505              	# stdlib.c:148: 	while ((((uint32_t)dst | (uint32_t)src) & 3) != 0)
 1506 0b80 33E7B700 		or	a4,a5,a1	# src, tmp101, dst
 1507              	# stdlib.c:148: 	while ((((uint32_t)dst | (uint32_t)src) & 3) != 0)
 1508 0b84 13773700 		andi	a4,a4,3	#, tmp102, tmp101
 1509              	# stdlib.c:148: 	while ((((uint32_t)dst | (uint32_t)src) & 3) != 0)
 1510 0b88 E31207FE 		bne	a4,zero,.L253	#, tmp102,,
 1511              	# stdlib.c:157: 		uint32_t v = *(uint32_t*)src;
 1512 0b8c 83A60500 		lw	a3,0(a1)		# v, MEM[(uint32_t *)src_20]
 1513              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1514 0b90 B708FFFE 		li	a7,-16842752		# tmp105,
 1515 0b94 9388F8EF 		addi	a7,a7,-257	#, tmp104, tmp105
 1516 0b98 33871601 		add	a4,a3,a7	# tmp104, tmp103, v
 1517              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1518 0b9c 13C6F6FF 		not	a2,a3	# tmp106, v
 1519              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1520 0ba0 37888080 		li	a6,-2139062272		# tmp110,
 1521              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1522 0ba4 3377C700 		and	a4,a4,a2	# tmp106, tmp107, tmp103
 1523              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1524 0ba8 13080808 		addi	a6,a6,128	#, tmp109, tmp110
 1525 0bac 33770701 		and	a4,a4,a6	# tmp109, tmp108, tmp107
 1526              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1527 0bb0 63140702 		bne	a4,zero,.L256	#, tmp108,,
 1528              	.L254:
 1529              	# stdlib.c:180: 		*(uint32_t*)dst = v;
 1530 0bb4 23A0D700 		sw	a3,0(a5)	# v, MEM[(uint32_t *)dst_51]
 1531              	# stdlib.c:157: 		uint32_t v = *(uint32_t*)src;
 1532 0bb8 83A64500 		lw	a3,4(a1)		# v, MEM[(uint32_t *)src_31]
 1533              	# stdlib.c:182: 		dst += 4;
 1534 0bbc 93874700 		addi	a5,a5,4	#, dst, dst
 1535              	# stdlib.c:181: 		src += 4;
 1536 0bc0 93854500 		addi	a1,a1,4	#, src, src
 1537              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1538 0bc4 33871601 		add	a4,a3,a7	# tmp104, tmp115, v
 1539              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1540 0bc8 13C6F6FF 		not	a2,a3	# tmp118, v
 1541              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1542 0bcc 3377C700 		and	a4,a4,a2	# tmp118, tmp119, tmp115
 1543              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1544 0bd0 33770701 		and	a4,a4,a6	# tmp109, tmp120, tmp119
 1545              	# stdlib.c:159: 		if (__builtin_expect((((v) - 0x01010101UL) & ~(v) & 0x80808080UL), 0))
 1546 0bd4 E30007FE 		beq	a4,zero,.L254	#, tmp120,,
 1547              	.L256:
 1548              	# stdlib.c:161: 			dst[0] = v & 0xff;
 1549 0bd8 2380D700 		sb	a3,0(a5)	# v, *dst_50
 1550              	# stdlib.c:162: 			if ((v & 0xff) == 0)
 1551 0bdc 13F7F60F 		andi	a4,a3,255	#, tmp111, v
 1552              	# stdlib.c:162: 			if ((v & 0xff) == 0)
 1553 0be0 63020702 		beq	a4,zero,.L255	#, tmp111,,
 1554              	# stdlib.c:164: 			v = v >> 8;
 1555 0be4 13D78600 		srli	a4,a3,8	#, v, v
 1556              	# stdlib.c:166: 			dst[1] = v & 0xff;
 1557 0be8 A380E700 		sb	a4,1(a5)	# v, MEM[(char *)dst_50 + 1B]
 1558              	# stdlib.c:167: 			if ((v & 0xff) == 0)
 1559 0bec 1377F70F 		andi	a4,a4,255	#, tmp112, v
 1560              	# stdlib.c:167: 			if ((v & 0xff) == 0)
 1561 0bf0 630A0700 		beq	a4,zero,.L255	#, tmp112,,
 1562              	# stdlib.c:169: 			v = v >> 8;
 1563 0bf4 13D70601 		srli	a4,a3,16	#, v, v
 1564              	# stdlib.c:171: 			dst[2] = v & 0xff;
 1565 0bf8 2381E700 		sb	a4,2(a5)	# v, MEM[(char *)dst_50 + 2B]
 1566              	# stdlib.c:172: 			if ((v & 0xff) == 0)
 1567 0bfc 1377F70F 		andi	a4,a4,255	#, tmp113, v
 1568              	# stdlib.c:172: 			if ((v & 0xff) == 0)
 1569 0c00 63140700 		bne	a4,zero,.L271	#, tmp113,,
 1570              	.L255:
 1571              	# stdlib.c:184: }
 1572 0c04 67800000 		ret	
 1573              	.L271:
 1574              	# stdlib.c:174: 			v = v >> 8;
 1575 0c08 93D68601 		srli	a3,a3,24	#, v, v
 1576              	# stdlib.c:176: 			dst[3] = v & 0xff;
 1577 0c0c A381D700 		sb	a3,3(a5)	# v, MEM[(char *)dst_50 + 3B]
 1578              	# stdlib.c:177: 			return r;
 1579 0c10 67800000 		ret	
 1581              		.align	2
 1582              		.globl	strcmp
 1584              	strcmp:
 1585              	# stdlib.c:188: 	while ((((uint32_t)s1 | (uint32_t)s2) & 3) != 0)
 1586 0c14 6F00C001 		j	.L273		#
 1587              	.L277:
 1588              	# stdlib.c:190: 		char c1 = *(s1++);
 1589 0c18 83470500 		lbu	a5,0(a0)	# c1, MEM[(const char *)s1_48 + 4294967295B]
 1590              	# stdlib.c:191: 		char c2 = *(s2++);
 1591 0c1c 03C70500 		lbu	a4,0(a1)	# c2, MEM[(const char *)s2_50 + 4294967295B]
 1592              	# stdlib.c:190: 		char c1 = *(s1++);
 1593 0c20 13051500 		addi	a0,a0,1	#, s1, s1
 1594              	# stdlib.c:191: 		char c2 = *(s2++);
 1595 0c24 93851500 		addi	a1,a1,1	#, s2, s2
 1596              	# stdlib.c:193: 		if (c1 != c2)
 1597 0c28 6392E706 		bne	a5,a4,.L302	#, c1, c2,
 1598              	# stdlib.c:195: 		else if (!c1)
 1599 0c2c 638C0704 		beq	a5,zero,.L292	#, c1,,
 1600              	.L273:
 1601              	# stdlib.c:188: 	while ((((uint32_t)s1 | (uint32_t)s2) & 3) != 0)
 1602 0c30 B367B500 		or	a5,a0,a1	# s2, tmp101, s1
 1603              	# stdlib.c:188: 	while ((((uint32_t)s1 | (uint32_t)s2) & 3) != 0)
 1604 0c34 93F73700 		andi	a5,a5,3	#, tmp102, tmp101
 1605              	# stdlib.c:188: 	while ((((uint32_t)s1 | (uint32_t)s2) & 3) != 0)
 1606 0c38 E39007FE 		bne	a5,zero,.L277	#, tmp102,,
 1607              	# stdlib.c:201: 		uint32_t v1 = *(uint32_t*)s1;
 1608 0c3c 83270500 		lw	a5,0(a0)		# v1, MEM[(uint32_t *)s1_14]
 1609              	# stdlib.c:202: 		uint32_t v2 = *(uint32_t*)s2;
 1610 0c40 03A70500 		lw	a4,0(a1)		# v2, MEM[(uint32_t *)s2_16]
 1611              	# stdlib.c:204: 		if (__builtin_expect(v1 != v2, 0))
 1612 0c44 639CE704 		bne	a5,a4,.L282	#, v1, v2,
 1613              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1614 0c48 3706FFFE 		li	a2,-16842752		# tmp111,
 1615              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1616 0c4c B7868080 		li	a3,-2139062272		# tmp116,
 1617              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1618 0c50 1306F6EF 		addi	a2,a2,-257	#, tmp110, tmp111
 1619              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1620 0c54 93860608 		addi	a3,a3,128	#, tmp115, tmp116
 1621 0c58 6F000001 		j	.L278		#
 1622              	.L303:
 1623              	# stdlib.c:201: 		uint32_t v1 = *(uint32_t*)s1;
 1624 0c5c 83270500 		lw	a5,0(a0)		# v1, MEM[(uint32_t *)s1_29]
 1625              	# stdlib.c:202: 		uint32_t v2 = *(uint32_t*)s2;
 1626 0c60 03A70500 		lw	a4,0(a1)		# v2, MEM[(uint32_t *)s2_30]
 1627              	# stdlib.c:204: 		if (__builtin_expect(v1 != v2, 0))
 1628 0c64 639CE702 		bne	a5,a4,.L282	#, v1, v2,
 1629              	.L278:
 1630              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1631 0c68 3387C700 		add	a4,a5,a2	# tmp110, tmp109, v1
 1632              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1633 0c6c 93C7F7FF 		not	a5,a5	# tmp112, v1
 1634              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1635 0c70 B377F700 		and	a5,a4,a5	# tmp112, tmp113, tmp109
 1636              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1637 0c74 B3F7D700 		and	a5,a5,a3	# tmp115, tmp114, tmp113
 1638              	# stdlib.c:231: 		s1 += 4;
 1639 0c78 13054500 		addi	a0,a0,4	#, s1, s1
 1640              	# stdlib.c:232: 		s2 += 4;
 1641 0c7c 93854500 		addi	a1,a1,4	#, s2, s2
 1642              	# stdlib.c:228: 		if (__builtin_expect((((v1) - 0x01010101UL) & ~(v1) & 0x80808080UL), 0))
 1643 0c80 E38E07FC 		beq	a5,zero,.L303	#, tmp114,,
 1644              	.L292:
 1645              	# stdlib.c:196: 			return 0;
 1646 0c84 13050000 		li	a0,0		# <retval>,
 1647              	.L272:
 1648              	# stdlib.c:234: }
 1649 0c88 67800000 		ret	
 1650              	.L302:
 1651              	# stdlib.c:194: 			return c1 < c2 ? -1 : +1;
 1652 0c8c 33B5E700 		sltu	a0,a5,a4	# c2, tmp119, c1
 1653 0c90 3305A040 		neg	a0,a0	# tmp120, tmp119
 1654 0c94 13651500 		ori	a0,a0,1	#, <retval>, tmp120
 1655 0c98 67800000 		ret	
 1656              	.L282:
 1657              	# stdlib.c:208: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1658 0c9c 93F6F70F 		andi	a3,a5,0xff	# c1, v1
 1659              	# stdlib.c:208: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1660 0ca0 1376F70F 		andi	a2,a4,0xff	# c2, v2
 1661              	# stdlib.c:209: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1662 0ca4 639AC604 		bne	a3,a2,.L300	#, c1, c2,
 1663              	# stdlib.c:196: 			return 0;
 1664 0ca8 13050000 		li	a0,0		# <retval>,
 1665              	# stdlib.c:210: 			if (!c1) return 0;
 1666 0cac E38E06FC 		beq	a3,zero,.L272	#, c1,,
 1667              	# stdlib.c:211: 			v1 = v1 >> 8, v2 = v2 >> 8;
 1668 0cb0 93D68700 		srli	a3,a5,8	#, v1, v1
 1669              	# stdlib.c:211: 			v1 = v1 >> 8, v2 = v2 >> 8;
 1670 0cb4 13568700 		srli	a2,a4,8	#, v2, v2
 1671              	# stdlib.c:213: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1672 0cb8 93F6F60F 		andi	a3,a3,0xff	# c1, v1
 1673              	# stdlib.c:213: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1674 0cbc 1376F60F 		andi	a2,a2,0xff	# c2, v2
 1675              	# stdlib.c:214: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1676 0cc0 639CC602 		bne	a3,a2,.L300	#, c1, c2,
 1677              	# stdlib.c:215: 			if (!c1) return 0;
 1678 0cc4 E38206FC 		beq	a3,zero,.L272	#, c1,,
 1679              	# stdlib.c:216: 			v1 = v1 >> 8, v2 = v2 >> 8;
 1680 0cc8 93D60701 		srli	a3,a5,16	#, v1, v1
 1681              	# stdlib.c:216: 			v1 = v1 >> 8, v2 = v2 >> 8;
 1682 0ccc 13560701 		srli	a2,a4,16	#, v2, v2
 1683              	# stdlib.c:218: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1684 0cd0 93F6F60F 		andi	a3,a3,0xff	# c1, v1
 1685              	# stdlib.c:218: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1686 0cd4 1376F60F 		andi	a2,a2,0xff	# c2, v2
 1687              	# stdlib.c:219: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1688 0cd8 6390C602 		bne	a3,a2,.L300	#, c1, c2,
 1689              	# stdlib.c:220: 			if (!c1) return 0;
 1690 0cdc E38606FA 		beq	a3,zero,.L272	#, c1,,
 1691              	# stdlib.c:223: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1692 0ce0 93D78701 		srli	a5,a5,24	#, c1, v1
 1693              	# stdlib.c:223: 			c1 = v1 & 0xff, c2 = v2 & 0xff;
 1694 0ce4 13578701 		srli	a4,a4,24	#, c2, v2
 1695              	# stdlib.c:224: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1696 0ce8 E380E7FA 		beq	a5,a4,.L272	#, c1, c2,
 1697              	# stdlib.c:194: 			return c1 < c2 ? -1 : +1;
 1698 0cec 13051000 		li	a0,1		# <retval>,
 1699              	# stdlib.c:224: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1700 0cf0 E3FCE7F8 		bgeu	a5,a4,.L272	#, c1, c2,
 1701 0cf4 6F00C000 		j	.L298		#
 1702              	.L300:
 1703              	# stdlib.c:194: 			return c1 < c2 ? -1 : +1;
 1704 0cf8 13051000 		li	a0,1		# <retval>,
 1705              	# stdlib.c:219: 			if (c1 != c2) return c1 < c2 ? -1 : +1;
 1706 0cfc E3F6C6F8 		bgeu	a3,a2,.L272	#, c1, c2,
 1707              	.L298:
 1708              	# stdlib.c:194: 			return c1 < c2 ? -1 : +1;
 1709 0d00 1305F0FF 		li	a0,-1		# <retval>,
 1710 0d04 67800000 		ret	
 1712              		.align	2
 1713              		.globl	sin1
 1715              	sin1:
 1716              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1717 0d08 635A0500 		bge	a0,zero,.L305	#, angle,,
 1718              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1719 0d0c B787FFFF 		li	a5,-32768		# tmp96,
 1720 0d10 3305F500 		add	a0,a0,a5	# tmp96, tmp98, angle
 1721 0d14 13150501 		slli	a0,a0,16	#, angle, tmp98
 1722 0d18 13550541 		srai	a0,a0,16	#, angle, angle
 1723              	.L305:
 1724              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 1725 0d1c 93578540 		srai	a5,a0,8	#, v0, angle
 1726              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1727 0d20 93960701 		slli	a3,a5,16	#, v0.41_4, v0
 1728              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1729 0d24 13F70702 		andi	a4,a5,32	#, tmp102, v0
 1730              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1731 0d28 93D60601 		srli	a3,a3,16	#, v0.41_4, v0.41_4
 1732              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1733 0d2c 630A0700 		beq	a4,zero,.L306	#, tmp102,,
 1734              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1735 0d30 93C7F7FF 		not	a5,a5	# tmp104, v0
 1736 0d34 93970701 		slli	a5,a5,16	#, v0, tmp104
 1737 0d38 93D70741 		srai	a5,a5,16	#, v0, v0
 1738              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1739 0d3c 1345F5FF 		not	a0,a0	# angle, angle
 1740              	.L306:
 1741              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1742 0d40 93F7F701 		andi	a5,a5,31	#, _6, v0
 1743              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1744 0d44 13861700 		addi	a2,a5,1	#, tmp114, _6
 1745              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1746 0d48 37070000 		lui	a4,%hi(.LANCHOR1)	# tmp109,
 1747 0d4c 13070700 		addi	a4,a4,%lo(.LANCHOR1)	# tmp108, tmp109,
 1748              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1749 0d50 13161600 		slli	a2,a2,1	#, tmp115, tmp114
 1750              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1751 0d54 93971700 		slli	a5,a5,1	#, tmp110, _6
 1752 0d58 B307F700 		add	a5,a4,a5	# tmp110, tmp111, tmp108
 1753              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1754 0d5c 3307C700 		add	a4,a4,a2	# tmp115, tmp116, tmp108
 1755              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1756 0d60 03960700 		lh	a2,0(a5)		# _7, sin90[_6]
 1757              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1758 0d64 83170700 		lh	a5,0(a4)		# sin90[_9], sin90[_9]
 1759              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1760 0d68 1377F50F 		andi	a4,a0,0xff	# tmp121, angle
 1761              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1762 0d6c 93F60604 		andi	a3,a3,64	#, tmp129, v0.41_4
 1763              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1764 0d70 3385C740 		sub	a0,a5,a2	# tmp118, sin90[_9], _7
 1765              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1766 0d74 3305E502 		mul	a0,a0,a4	# tmp122, tmp118, tmp121
 1767              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1768 0d78 13558540 		srai	a0,a0,8	#, tmp123, tmp122
 1769              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1770 0d7c 3305C500 		add	a0,a0,a2	# _7, tmp126, tmp123
 1771 0d80 13150501 		slli	a0,a0,16	#, _5, tmp126
 1772 0d84 13550501 		srli	a0,a0,16	#, _5, _5
 1773              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1774 0d88 63880600 		beq	a3,zero,.L307	#, tmp129,,
 1775              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1776 0d8c 3305A040 		neg	a0,a0	# tmp131, _5
 1777 0d90 13150501 		slli	a0,a0,16	#, _5, tmp131
 1778 0d94 13550501 		srli	a0,a0,16	#, _5, _5
 1779              	.L307:
 1780              	# gfx_lib_hdmi.h:94: }
 1781 0d98 13150501 		slli	a0,a0,16	#,, _5
 1782 0d9c 13550541 		srai	a0,a0,16	#,,
 1783 0da0 67800000 		ret	
 1785              		.align	2
 1786              		.globl	cos1
 1788              	cos1:
 1789              	# gfx_lib_hdmi.h:108:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1790 0da4 13160501 		slli	a2,a0,16	#, prephitmp_78, angle
 1791 0da8 13560601 		srli	a2,a2,16	#, prephitmp_78, prephitmp_78
 1792              	# gfx_lib_hdmi.h:108:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1793 0dac 63560500 		bge	a0,zero,.L315	#, angle,,
 1794              	# gfx_lib_hdmi.h:108:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1795 0db0 B7870000 		li	a5,32768		# tmp98,
 1796 0db4 3346F600 		xor	a2,a2,a5	# tmp98, prephitmp_78, prephitmp_78
 1797              	.L315:
 1798              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 1799 0db8 B7A7FFFF 		li	a5,-24576		# tmp101,
 1800 0dbc 93871700 		addi	a5,a5,1	#, tmp100, tmp101
 1801 0dc0 B307F600 		add	a5,a2,a5	# tmp100, tmp99, prephitmp_78
 1802              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 1803 0dc4 93960701 		slli	a3,a5,16	#, angle, tmp99
 1804              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 1805 0dc8 13970701 		slli	a4,a5,16	#, _4, tmp99
 1806              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 1807 0dcc 93D60641 		srai	a3,a3,16	#, angle, angle
 1808              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 1809 0dd0 13570701 		srli	a4,a4,16	#, _4, _4
 1810              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1811 0dd4 63D00602 		bge	a3,zero,.L316	#, angle,,
 1812              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 1813 0dd8 B7270000 		li	a5,8192		# tmp104,
 1814 0ddc 93871700 		addi	a5,a5,1	#, tmp103, tmp104
 1815 0de0 3306F600 		add	a2,a2,a5	# tmp103, tmp102, prephitmp_78
 1816 0de4 13170601 		slli	a4,a2,16	#, _4, tmp102
 1817 0de8 93160601 		slli	a3,a2,16	#, angle, tmp102
 1818 0dec 13570701 		srli	a4,a4,16	#, _4, _4
 1819 0df0 93D60641 		srai	a3,a3,16	#, angle, angle
 1820              	.L316:
 1821              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 1822 0df4 93D78640 		srai	a5,a3,8	#, v0, angle
 1823              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1824 0df8 13960701 		slli	a2,a5,16	#, v0.41_16, v0
 1825              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1826 0dfc 93F50702 		andi	a1,a5,32	#, tmp108, v0
 1827              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1828 0e00 13560601 		srli	a2,a2,16	#, v0.41_16, v0.41_16
 1829              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1830 0e04 638A0500 		beq	a1,zero,.L317	#, tmp108,,
 1831              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1832 0e08 93C6F6FF 		not	a3,a3	# tmp112, angle
 1833              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1834 0e0c 13970601 		slli	a4,a3,16	#, _4, tmp112
 1835              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 1836 0e10 93C7F7FF 		not	a5,a5	# v0, v0
 1837              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1838 0e14 13570701 		srli	a4,a4,16	#, _4, _4
 1839              	.L317:
 1840              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1841 0e18 93F7F701 		andi	a5,a5,31	#, _22, v0
 1842              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1843 0e1c 93851700 		addi	a1,a5,1	#, tmp120, _22
 1844              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1845 0e20 B7060000 		lui	a3,%hi(.LANCHOR1)	# tmp115,
 1846 0e24 93860600 		addi	a3,a3,%lo(.LANCHOR1)	# tmp114, tmp115,
 1847              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1848 0e28 93951500 		slli	a1,a1,1	#, tmp121, tmp120
 1849              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1850 0e2c 93971700 		slli	a5,a5,1	#, tmp116, _22
 1851 0e30 B387F600 		add	a5,a3,a5	# tmp116, tmp117, tmp114
 1852              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1853 0e34 B386B600 		add	a3,a3,a1	# tmp121, tmp122, tmp114
 1854 0e38 03950600 		lh	a0,0(a3)		# sin90[_25], sin90[_25]
 1855              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1856 0e3c 83950700 		lh	a1,0(a5)		# _23, sin90[_22]
 1857              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1858 0e40 9377F70F 		andi	a5,a4,0xff	# tmp126, _4
 1859              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1860 0e44 13770604 		andi	a4,a2,64	#, tmp134, v0.41_16
 1861              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1862 0e48 3305B540 		sub	a0,a0,a1	# tmp124, sin90[_25], _23
 1863              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1864 0e4c 3305F502 		mul	a0,a0,a5	# tmp127, tmp124, tmp126
 1865              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1866 0e50 13558540 		srai	a0,a0,8	#, tmp128, tmp127
 1867              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 1868 0e54 3305B500 		add	a0,a0,a1	# _23, tmp131, tmp128
 1869 0e58 13150501 		slli	a0,a0,16	#, _37, tmp131
 1870 0e5c 13550501 		srli	a0,a0,16	#, _37, _37
 1871              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1872 0e60 63080700 		beq	a4,zero,.L318	#, tmp134,,
 1873              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 1874 0e64 3305A040 		neg	a0,a0	# tmp136, _37
 1875 0e68 13150501 		slli	a0,a0,16	#, _37, tmp136
 1876 0e6c 13550501 		srli	a0,a0,16	#, _37, _37
 1877              	.L318:
 1878              	# gfx_lib_hdmi.h:110: }
 1879 0e70 13150501 		slli	a0,a0,16	#,, _37
 1880 0e74 13550541 		srai	a0,a0,16	#,,
 1881 0e78 67800000 		ret	
 1883              		.align	2
 1884              		.globl	oled_spi_tx
 1886              	oled_spi_tx:
 1887              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1888 0e7c 93958500 		slli	a1,a1,8	#, tmp80, tmp85
 1889 0e80 93F50510 		andi	a1,a1,256	#, tmp81, tmp80
 1890              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1891 0e84 B3E5A500 		or	a1,a1,a0	# tmp84, _6, tmp81
 1892              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1893 0e88 B7070030 		li	a5,805306368		# tmp83,
 1894 0e8c 23A6B700 		sw	a1,12(a5)	# _6, MEM[(volatile uint32_t *)805306380B]
 1895              	# gfx_lib_hdmi.h:115: }
 1896 0e90 67800000 		ret	
 1898              		.align	2
 1899              		.globl	oled_max_window
 1901              	oled_max_window:
 1902              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1903 0e94 B7070030 		li	a5,805306368		# tmp73,
 1904 0e98 13075001 		li	a4,21		# tmp74,
 1905 0e9c 23A6E700 		sw	a4,12(a5)	# tmp74, MEM[(volatile uint32_t *)805306380B]
 1906 0ea0 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
 1907 0ea4 1307F005 		li	a4,95		# tmp79,
 1908 0ea8 23A6E700 		sw	a4,12(a5)	# tmp79, MEM[(volatile uint32_t *)805306380B]
 1909 0eac 13075007 		li	a4,117		# tmp82,
 1910 0eb0 23A6E700 		sw	a4,12(a5)	# tmp82, MEM[(volatile uint32_t *)805306380B]
 1911 0eb4 23A60700 		sw	zero,12(a5)	#, MEM[(volatile uint32_t *)805306380B]
 1912 0eb8 1307F003 		li	a4,63		# tmp87,
 1913 0ebc 23A6E700 		sw	a4,12(a5)	# tmp87, MEM[(volatile uint32_t *)805306380B]
 1914              	# gfx_lib_hdmi.h:120: }
 1915 0ec0 67800000 		ret	
 1917              		.align	2
 1918              		.globl	oled_show_fb_8or16
 1920              	oled_show_fb_8or16:
 1921              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
 1922 0ec4 B7070030 		li	a5,805306368		# tmp78,
 1923 0ec8 23A6A702 		sw	a0,44(a5)	# framebuffer, MEM[(volatile uint32_t *)805306412B]
 1924              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 1925 0ecc 37170000 		li	a4,4096		# tmp84,
 1926              	# kianv_stdlib.h:52:   *( (volatile uint32_t*) DMA_DST  ) = dst;
 1927 0ed0 23A8B702 		sw	a1,48(a5)	# target_fb, MEM[(volatile uint32_t *)805306416B]
 1928              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 1929 0ed4 1307072C 		addi	a4,a4,704	#, tmp83, tmp84
 1930 0ed8 23AAE702 		sw	a4,52(a5)	# tmp83, MEM[(volatile uint32_t *)805306420B]
 1931              	# kianv_stdlib.h:54:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
 1932 0edc 13071000 		li	a4,1		# tmp87,
 1933 0ee0 23ACE702 		sw	a4,56(a5)	# tmp87, MEM[(volatile uint32_t *)805306424B]
 1934              	# gfx_lib_hdmi.h:132: }
 1935 0ee4 67800000 		ret	
 1937              		.align	2
 1938              		.globl	init_oled8bit_colors
 1940              	init_oled8bit_colors:
 1941 0ee8 B7070000 		lui	a5,%hi(.LANCHOR2)	# tmp78,
 1942 0eec 93870700 		addi	a5,a5,%lo(.LANCHOR2)	# ivtmp.392, tmp78,
 1943 0ef0 13865702 		addi	a2,a5,37	#, _15, ivtmp.392
 1944              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1945 0ef4 B7060030 		li	a3,805306368		# tmp80,
 1946              	.L329:
 1947              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1948 0ef8 03C70700 		lbu	a4,0(a5)	# _7, MEM[(char *)_13]
 1949              	# gfx_lib_hdmi.h:192:   for (int i = 0; i < sizeof(oled_8bit_init_seq)/
 1950 0efc 93871700 		addi	a5,a5,1	#, ivtmp.392, ivtmp.392
 1951              	# gfx_lib_hdmi.h:114:   *((volatile uint32_t *) VIDEO_RAW) = ((data_cmd & 0x01) << 8) | tx;
 1952 0f00 23A6E600 		sw	a4,12(a3)	# _7, MEM[(volatile uint32_t *)805306380B]
 1953              	# gfx_lib_hdmi.h:192:   for (int i = 0; i < sizeof(oled_8bit_init_seq)/
 1954 0f04 E39AC7FE 		bne	a5,a2,.L329	#, ivtmp.392, _15,
 1955              	# gfx_lib_hdmi.h:198: }
 1956 0f08 67800000 		ret	
 1958              		.align	2
 1959              		.globl	fb_setpixel
 1961              	fb_setpixel:
 1962              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 1963 0f0c 9307F004 		li	a5,79		# tmp84,
 1964 0f10 63E4B702 		bgtu	a1,a5,.L331	#, x, tmp84,
 1965              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 1966 0f14 9307B003 		li	a5,59		# tmp85,
 1967 0f18 63E0C702 		bgtu	a2,a5,.L331	#, y, tmp85,
 1968              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 1969 0f1c 93172600 		slli	a5,a2,2	#, tmp87, y
 1970 0f20 B387C700 		add	a5,a5,a2	# y, tmp88, tmp87
 1971 0f24 93974700 		slli	a5,a5,4	#, tmp89, tmp88
 1972 0f28 B387B700 		add	a5,a5,a1	# x, tmp90, tmp89
 1973              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 1974 0f2c 93972700 		slli	a5,a5,2	#, tmp91, tmp90
 1975 0f30 3305F500 		add	a0,a0,a5	# tmp91, tmp92, fb
 1976 0f34 2320D500 		sw	a3,0(a0)	# color, *_12
 1977              	.L331:
 1978              	# gfx_lib_hdmi.h:207: }
 1979 0f38 67800000 		ret	
 1981              		.align	2
 1982              		.globl	fb_draw_bresenham
 1984              	fb_draw_bresenham:
 1985 0f3c 130101FD 		addi	sp,sp,-48	#,,
 1986 0f40 232C4101 		sw	s4,24(sp)	#,
 1987 0f44 130A0500 		mv	s4,a0	# tmp116, fb
 1988              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 1989 0f48 3385B640 		sub	a0,a3,a1	#, x1, x0
 1990              	# gfx_lib_hdmi.h:210: {
 1991 0f4c 23261102 		sw	ra,44(sp)	#,
 1992 0f50 23248102 		sw	s0,40(sp)	#,
 1993 0f54 23229102 		sw	s1,36(sp)	#,
 1994 0f58 13040600 		mv	s0,a2	# y0, tmp118
 1995 0f5c 93840500 		mv	s1,a1	# x0, tmp117
 1996 0f60 23202103 		sw	s2,32(sp)	#,
 1997 0f64 232E3101 		sw	s3,28(sp)	#,
 1998 0f68 232A5101 		sw	s5,20(sp)	#,
 1999 0f6c 93890600 		mv	s3,a3	# x1, tmp119
 2000 0f70 23286101 		sw	s6,16(sp)	#,
 2001 0f74 23267101 		sw	s7,12(sp)	#,
 2002              	# gfx_lib_hdmi.h:210: {
 2003 0f78 130B0700 		mv	s6,a4	# y1, tmp120
 2004 0f7c 938B0700 		mv	s7,a5	# color, tmp121
 2005              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 2006 0f80 97000000 		call	abs		#
 2006      E7800000 
 2007 0f88 13090500 		mv	s2,a0	# tmp122,
 2008              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 2009 0f8c 33058B40 		sub	a0,s6,s0	#, y1, y0
 2010 0f90 97000000 		call	abs		#
 2010      E7800000 
 2011              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 2012 0f98 B3AA3401 		sgt	s5,s3,s1	# tmp107, x1, x0
 2013              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 2014 0f9c 332E6401 		sgt	t3,s6,s0	# tmp111, y1, y0
 2015              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 2016 0fa0 939A1A00 		slli	s5,s5,1	#, iftmp.50_9, tmp107
 2017              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 2018 0fa4 131E1E00 		slli	t3,t3,1	#, iftmp.51_10, tmp111
 2019              	# gfx_lib_hdmi.h:212:   int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
 2020 0fa8 938AFAFF 		addi	s5,s5,-1	#, iftmp.50_9, iftmp.50_9
 2021              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 2022 0fac B308A040 		neg	a7,a0	# dy, _3
 2023              	# gfx_lib_hdmi.h:213:   int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
 2024 0fb0 130EFEFF 		addi	t3,t3,-1	#, iftmp.51_10, iftmp.51_10
 2025 0fb4 3306A940 		sub	a2,s2,a0	# err, dx, _3
 2026              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 2027 0fb8 9306F004 		li	a3,79		# tmp97,
 2028              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 2029 0fbc 1303B003 		li	t1,59		# tmp115,
 2030              	.L336:
 2031              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 2032 0fc0 13182400 		slli	a6,s0,2	#, tmp100, y0
 2033 0fc4 33088800 		add	a6,a6,s0	# y0, tmp101, tmp100
 2034 0fc8 13184800 		slli	a6,a6,4	#, tmp102, tmp101
 2035 0fcc 33089800 		add	a6,a6,s1	# x0, tmp103, tmp102
 2036              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 2037 0fd0 13182800 		slli	a6,a6,2	#, tmp104, tmp103
 2038              	# gfx_lib_hdmi.h:220:     e2 = 2*err;
 2039 0fd4 93151600 		slli	a1,a2,1	#, e2, err
 2040              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 2041 0fd8 33080A01 		add	a6,s4,a6	# tmp104, tmp105, fb
 2042              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 2043 0fdc 63E69600 		bgtu	s1,a3,.L337	#, x0, tmp97,
 2044              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 2045 0fe0 63648300 		bgtu	s0,t1,.L337	#, y0, tmp115,
 2046              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 2047 0fe4 23207801 		sw	s7,0(a6)	# color, *_38
 2048              	.L337:
 2049              	# gfx_lib_hdmi.h:218:     if (x0 == x1 && y0 == y1) break;
 2050 0fe8 63803403 		beq	s1,s3,.L345	#, x0, x1,
 2051              	.L338:
 2052              	# gfx_lib_hdmi.h:221:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 2053 0fec 63C61501 		bgt	a7,a1,.L340	#, dy, e2,
 2054 0ff0 3306A640 		sub	a2,a2,a0	# err, err, _3
 2055              	# gfx_lib_hdmi.h:221:     if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
 2056 0ff4 B3845401 		add	s1,s1,s5	# iftmp.50_9, x0, x0
 2057              	.L340:
 2058              	# gfx_lib_hdmi.h:222:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 2059 0ff8 E344B9FC 		blt	s2,a1,.L336	#, dx, e2,
 2060              	# gfx_lib_hdmi.h:222:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 2061 0ffc 33062601 		add	a2,a2,s2	# dx, err, err
 2062              	# gfx_lib_hdmi.h:222:     if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
 2063 1000 3304C401 		add	s0,s0,t3	# iftmp.51_10, y0, y0
 2064 1004 6FF0DFFB 		j	.L336		#
 2065              	.L345:
 2066              	# gfx_lib_hdmi.h:218:     if (x0 == x1 && y0 == y1) break;
 2067 1008 E31264FF 		bne	s0,s6,.L338	#, y0, y1,
 2068              	# gfx_lib_hdmi.h:224: }
 2069 100c 8320C102 		lw	ra,44(sp)		#,
 2070 1010 03248102 		lw	s0,40(sp)		#,
 2071 1014 83244102 		lw	s1,36(sp)		#,
 2072 1018 03290102 		lw	s2,32(sp)		#,
 2073 101c 8329C101 		lw	s3,28(sp)		#,
 2074 1020 032A8101 		lw	s4,24(sp)		#,
 2075 1024 832A4101 		lw	s5,20(sp)		#,
 2076 1028 032B0101 		lw	s6,16(sp)		#,
 2077 102c 832BC100 		lw	s7,12(sp)		#,
 2078 1030 13010103 		addi	sp,sp,48	#,,
 2079 1034 67800000 		jr	ra		#
 2081              		.align	2
 2082              		.globl	fill_oled
 2084              	fill_oled:
 2085              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
 2086 1038 B7070030 		li	a5,805306368		# tmp77,
 2087 103c 23A6A702 		sw	a0,44(a5)	# framebuffer, MEM[(volatile uint32_t *)805306412B]
 2088              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 2089 1040 37170000 		li	a4,4096		# tmp83,
 2090              	# kianv_stdlib.h:52:   *( (volatile uint32_t*) DMA_DST  ) = dst;
 2091 1044 23A8B702 		sw	a1,48(a5)	# rgb, MEM[(volatile uint32_t *)805306416B]
 2092              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 2093 1048 1307072C 		addi	a4,a4,704	#, tmp82, tmp83
 2094 104c 23AAE702 		sw	a4,52(a5)	# tmp82, MEM[(volatile uint32_t *)805306420B]
 2095              	# kianv_stdlib.h:54:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
 2096 1050 13072000 		li	a4,2		# tmp86,
 2097 1054 23ACE702 		sw	a4,56(a5)	# tmp86, MEM[(volatile uint32_t *)805306424B]
 2098              	# gfx_lib_hdmi.h:233: }
 2099 1058 67800000 		ret	
 2101              		.align	2
 2102              		.globl	mirror_x_axis
 2104              	mirror_x_axis:
 2105              	# gfx_lib_hdmi.h:236:   point transformed = {p->x, 1.0 * p->y};
 2106 105c 03A74500 		lw	a4,4(a1)		# vect__1.408, MEM[(int *)p_4(D) + 4B]
 2107              	# gfx_lib_hdmi.h:237:   return transformed;
 2108 1060 83A60500 		lw	a3,0(a1)		# MEM[(int *)p_4(D)], MEM[(int *)p_4(D)]
 2109 1064 23240500 		sw	zero,8(a0)	#, <retval>.z
 2110 1068 2322E500 		sw	a4,4(a0)	# vect__1.408, MEM[(int *)&<retval> + 4B]
 2111 106c 2320D500 		sw	a3,0(a0)	# MEM[(int *)p_4(D)], MEM[(int *)&<retval>]
 2112              	# gfx_lib_hdmi.h:238: }
 2113 1070 67800000 		ret	
 2115              		.globl	__floatsidf
 2116              		.globl	__fixdfsi
 2117              		.align	2
 2118              		.globl	mirror_y_axis
 2120              	mirror_y_axis:
 2121 1074 130101FF 		addi	sp,sp,-16	#,,
 2122 1078 23248100 		sw	s0,8(sp)	#,
 2123 107c 13040500 		mv	s0,a0	# tmp88, .result_ptr
 2124              	# gfx_lib_hdmi.h:241:   point transformed = {-1.0 * p->x, p->y};
 2125 1080 03A50500 		lw	a0,0(a1)		#, p_7(D)->x
 2126              	# gfx_lib_hdmi.h:240: point mirror_y_axis(point *p) {
 2127 1084 23261100 		sw	ra,12(sp)	#,
 2128 1088 23229100 		sw	s1,4(sp)	#,
 2129              	# gfx_lib_hdmi.h:241:   point transformed = {-1.0 * p->x, p->y};
 2130 108c 83A44500 		lw	s1,4(a1)		# _5, p_7(D)->y
 2131              	# gfx_lib_hdmi.h:241:   point transformed = {-1.0 * p->x, p->y};
 2132 1090 97000000 		call	__floatsidf		#
 2132      E7800000 
 2133              	# gfx_lib_hdmi.h:241:   point transformed = {-1.0 * p->x, p->y};
 2134 1098 B7070080 		li	a5,-2147483648		# tmp81,
 2135 109c 13070500 		mv	a4,a0	# tmp93, tmp90
 2136 10a0 B3C7B700 		xor	a5,a5,a1	# tmp91, tmp94, tmp81
 2137 10a4 13050700 		mv	a0,a4	# tmp95, tmp93
 2138 10a8 93850700 		mv	a1,a5	#, tmp94
 2139 10ac 97000000 		call	__fixdfsi		#
 2139      E7800000 
 2140 10b4 2320A400 		sw	a0,0(s0)	# tmp92, <retval>.x
 2141              	# gfx_lib_hdmi.h:242:   return transformed;
 2142 10b8 23229400 		sw	s1,4(s0)	# _5, <retval>.y
 2143              	# gfx_lib_hdmi.h:243: }
 2144 10bc 8320C100 		lw	ra,12(sp)		#,
 2145              	# gfx_lib_hdmi.h:242:   return transformed;
 2146 10c0 23240400 		sw	zero,8(s0)	#, <retval>.z
 2147              	# gfx_lib_hdmi.h:243: }
 2148 10c4 13050400 		mv	a0,s0	#, .result_ptr
 2149 10c8 03248100 		lw	s0,8(sp)		#,
 2150 10cc 83244100 		lw	s1,4(sp)		#,
 2151 10d0 13010101 		addi	sp,sp,16	#,,
 2152 10d4 67800000 		jr	ra		#
 2154              		.align	2
 2155              		.globl	mirror_z_axis
 2157              	mirror_z_axis:
 2158 10d8 130101FF 		addi	sp,sp,-16	#,,
 2159 10dc 23248100 		sw	s0,8(sp)	#,
 2160 10e0 13040500 		mv	s0,a0	# tmp89, .result_ptr
 2161              	# gfx_lib_hdmi.h:246:   point transformed = {p->x, p->y, -1.0 * p->z};
 2162 10e4 03A58500 		lw	a0,8(a1)		#, p_8(D)->z
 2163              	# gfx_lib_hdmi.h:245: point mirror_z_axis(point *p) {
 2164 10e8 23261100 		sw	ra,12(sp)	#,
 2165 10ec 23229100 		sw	s1,4(sp)	#,
 2166 10f0 23202101 		sw	s2,0(sp)	#,
 2167              	# gfx_lib_hdmi.h:245: point mirror_z_axis(point *p) {
 2168 10f4 93840500 		mv	s1,a1	# p, tmp90
 2169              	# gfx_lib_hdmi.h:246:   point transformed = {p->x, p->y, -1.0 * p->z};
 2170 10f8 03A94500 		lw	s2,4(a1)		# vect__1.420, MEM[(int *)p_8(D) + 4B]
 2171              	# gfx_lib_hdmi.h:246:   point transformed = {p->x, p->y, -1.0 * p->z};
 2172 10fc 97000000 		call	__floatsidf		#
 2172      E7800000 
 2173              	# gfx_lib_hdmi.h:246:   point transformed = {p->x, p->y, -1.0 * p->z};
 2174 1104 B7070080 		li	a5,-2147483648		# tmp82,
 2175 1108 B3C7B700 		xor	a5,a5,a1	# tmp92, tmp95, tmp82
 2176 110c 13070500 		mv	a4,a0	# tmp94, tmp91
 2177 1110 93850700 		mv	a1,a5	#, tmp95
 2178 1114 13050700 		mv	a0,a4	# tmp96, tmp94
 2179 1118 97000000 		call	__fixdfsi		#
 2179      E7800000 
 2180              	# gfx_lib_hdmi.h:247:   return transformed;
 2181 1120 83A70400 		lw	a5,0(s1)		# MEM[(int *)p_8(D)], MEM[(int *)p_8(D)]
 2182 1124 23222401 		sw	s2,4(s0)	# vect__1.420, MEM[(int *)&<retval> + 4B]
 2183 1128 2324A400 		sw	a0,8(s0)	# tmp93, <retval>.z
 2184              	# gfx_lib_hdmi.h:248: }
 2185 112c 8320C100 		lw	ra,12(sp)		#,
 2186              	# gfx_lib_hdmi.h:247:   return transformed;
 2187 1130 2320F400 		sw	a5,0(s0)	# MEM[(int *)p_8(D)], MEM[(int *)&<retval>]
 2188              	# gfx_lib_hdmi.h:248: }
 2189 1134 13050400 		mv	a0,s0	#, .result_ptr
 2190 1138 03248100 		lw	s0,8(sp)		#,
 2191 113c 83244100 		lw	s1,4(sp)		#,
 2192 1140 03290100 		lw	s2,0(sp)		#,
 2193 1144 13010101 		addi	sp,sp,16	#,,
 2194 1148 67800000 		jr	ra		#
 2196              		.globl	__floatsisf
 2197              		.globl	__mulsf3
 2198              		.globl	__fixsfsi
 2199              		.align	2
 2200              		.globl	scale
 2202              	scale:
 2203 114c 130101FE 		addi	sp,sp,-32	#,,
 2204 1150 232C8100 		sw	s0,24(sp)	#,
 2205 1154 13040500 		mv	s0,a0	# tmp96, .result_ptr
 2206              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2207 1158 03A54500 		lw	a0,4(a1)		#, p_14(D)->y
 2208              	# gfx_lib_hdmi.h:250: point scale(point *p, float sx, float sy, float sz) {
 2209 115c 232E1100 		sw	ra,28(sp)	#,
 2210 1160 232A9100 		sw	s1,20(sp)	#,
 2211 1164 23282101 		sw	s2,16(sp)	#,
 2212 1168 23263101 		sw	s3,12(sp)	#,
 2213 116c 13890600 		mv	s2,a3	# sy, tmp99
 2214 1170 93090600 		mv	s3,a2	# sx, tmp98
 2215 1174 23244101 		sw	s4,8(sp)	#,
 2216              	# gfx_lib_hdmi.h:250: point scale(point *p, float sx, float sy, float sz) {
 2217 1178 93840500 		mv	s1,a1	# p, tmp97
 2218 117c 130A0700 		mv	s4,a4	# sz, tmp100
 2219              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2220 1180 97000000 		call	__floatsisf		#
 2220      E7800000 
 2221 1188 93050900 		mv	a1,s2	#, sy
 2222 118c 97000000 		call	__mulsf3		#
 2222      E7800000 
 2223              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2224 1194 97000000 		call	__fixsfsi		#
 2224      E7800000 
 2225 119c 13090500 		mv	s2,a0	# tmp101,
 2226              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2227 11a0 03A58400 		lw	a0,8(s1)		#, p_14(D)->z
 2228 11a4 97000000 		call	__floatsisf		#
 2228      E7800000 
 2229 11ac 93050A00 		mv	a1,s4	#, sz
 2230 11b0 97000000 		call	__mulsf3		#
 2230      E7800000 
 2231              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2232 11b8 97000000 		call	__fixsfsi		#
 2232      E7800000 
 2233 11c0 93070500 		mv	a5,a0	# tmp102,
 2234              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2235 11c4 03A50400 		lw	a0,0(s1)		#, p_14(D)->x
 2236              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2237 11c8 93840700 		mv	s1,a5	# _12, tmp102
 2238              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2239 11cc 97000000 		call	__floatsisf		#
 2239      E7800000 
 2240 11d4 93850900 		mv	a1,s3	#, sx
 2241 11d8 97000000 		call	__mulsf3		#
 2241      E7800000 
 2242              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 2243 11e0 97000000 		call	__fixsfsi		#
 2243      E7800000 
 2244 11e8 2320A400 		sw	a0,0(s0)	# tmp103, <retval>.x
 2245              	# gfx_lib_hdmi.h:252:   return transformed;
 2246 11ec 23222401 		sw	s2,4(s0)	# _8, <retval>.y
 2247 11f0 23249400 		sw	s1,8(s0)	# _12, <retval>.z
 2248              	# gfx_lib_hdmi.h:253: }
 2249 11f4 8320C101 		lw	ra,28(sp)		#,
 2250 11f8 13050400 		mv	a0,s0	#, .result_ptr
 2251 11fc 03248101 		lw	s0,24(sp)		#,
 2252 1200 83244101 		lw	s1,20(sp)		#,
 2253 1204 03290101 		lw	s2,16(sp)		#,
 2254 1208 8329C100 		lw	s3,12(sp)		#,
 2255 120c 032A8100 		lw	s4,8(sp)		#,
 2256 1210 13010102 		addi	sp,sp,32	#,,
 2257 1214 67800000 		jr	ra		#
 2259              		.align	2
 2260              		.globl	translate
 2262              	translate:
 2263              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2264 1218 83A84500 		lw	a7,4(a1)		# p_8(D)->y, p_8(D)->y
 2265              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2266 121c 03A88500 		lw	a6,8(a1)		# p_8(D)->z, p_8(D)->z
 2267              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2268 1220 83A50500 		lw	a1,0(a1)		# p_8(D)->x, p_8(D)->x
 2269              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2270 1224 B3861601 		add	a3,a3,a7	# p_8(D)->y, _4, tmp90
 2271              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2272 1228 33070701 		add	a4,a4,a6	# p_8(D)->z, _6, tmp91
 2273              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 2274 122c B385C500 		add	a1,a1,a2	# tmp89, tmp85, p_8(D)->x
 2275              	# gfx_lib_hdmi.h:257:   return transformed;
 2276 1230 2320B500 		sw	a1,0(a0)	# tmp85, <retval>.x
 2277 1234 2322D500 		sw	a3,4(a0)	# _4, <retval>.y
 2278 1238 2324E500 		sw	a4,8(a0)	# _6, <retval>.z
 2279              	# gfx_lib_hdmi.h:258: }
 2280 123c 67800000 		ret	
 2282              		.globl	__muldf3
 2283              		.globl	__divdf3
 2284              		.globl	__truncdfsf2
 2285              		.globl	__subsf3
 2286              		.globl	__addsf3
 2287              		.align	2
 2288              		.globl	rotateX_pivot
 2290              	rotateX_pivot:
 2291 1240 130101FD 		addi	sp,sp,-48	#,,
 2292 1244 23248102 		sw	s0,40(sp)	#,
 2293 1248 13040500 		mv	s0,a0	# tmp259, .result_ptr
 2294              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2295 124c 13850600 		mv	a0,a3	#, tmp262
 2296              	# gfx_lib_hdmi.h:261: point rotateX_pivot(point *p, point *pivot, int angle) {
 2297 1250 23261102 		sw	ra,44(sp)	#,
 2298 1254 23229102 		sw	s1,36(sp)	#,
 2299 1258 23202103 		sw	s2,32(sp)	#,
 2300              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2301 125c 83A48500 		lw	s1,8(a1)		# p_32(D)->z, p_32(D)->z
 2302              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2303 1260 03A94500 		lw	s2,4(a1)		# p_32(D)->y, p_32(D)->y
 2304              	# gfx_lib_hdmi.h:261: point rotateX_pivot(point *p, point *pivot, int angle) {
 2305 1264 232E3101 		sw	s3,28(sp)	#,
 2306 1268 232C4101 		sw	s4,24(sp)	#,
 2307              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2308 126c 83298600 		lw	s3,8(a2)		# _6, pivot_33(D)->z
 2309              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2310 1270 032A4600 		lw	s4,4(a2)		# _3, pivot_33(D)->y
 2311              	# gfx_lib_hdmi.h:261: point rotateX_pivot(point *p, point *pivot, int angle) {
 2312 1274 23286101 		sw	s6,16(sp)	#,
 2313 1278 23248101 		sw	s8,8(sp)	#,
 2314              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2315 127c 03AB0500 		lw	s6,0(a1)		# _1, p_32(D)->x
 2316              	# gfx_lib_hdmi.h:261: point rotateX_pivot(point *p, point *pivot, int angle) {
 2317 1280 232A5101 		sw	s5,20(sp)	#,
 2318 1284 23267101 		sw	s7,12(sp)	#,
 2319 1288 23229101 		sw	s9,4(sp)	#,
 2320              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2321 128c 97000000 		call	__floatsidf		#
 2321      E7800000 
 2322 1294 B7070000 		lui	a5,%hi(.LC1)	# tmp156,
 2323 1298 03A60700 		lw	a2,%lo(.LC1)(a5)		#,
 2324 129c 83A64700 		lw	a3,%lo(.LC1+4)(a5)		#,
 2325              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2326 12a0 33094941 		sub	s2,s2,s4	# _4, p_32(D)->y, _3
 2327              	# gfx_lib_hdmi.h:262:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2328 12a4 B3843441 		sub	s1,s1,s3	# _7, p_32(D)->z, _6
 2329              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2330 12a8 97000000 		call	__muldf3		#
 2330      E7800000 
 2331 12b0 B7070000 		lui	a5,%hi(.LC2)	# tmp158,
 2332 12b4 03A60700 		lw	a2,%lo(.LC2)(a5)		#,
 2333 12b8 83A64700 		lw	a3,%lo(.LC2+4)(a5)		#,
 2334 12bc 97000000 		call	__divdf3		#
 2334      E7800000 
 2335 12c4 97000000 		call	__fixdfsi		#
 2335      E7800000 
 2336 12cc 13170501 		slli	a4,a0,16	#, angle, tmp263
 2337              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2338 12d0 131C0501 		slli	s8,a0,16	#, prephitmp_203, tmp263
 2339              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2340 12d4 13570741 		srai	a4,a4,16	#, angle, angle
 2341              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2342 12d8 135C0C01 		srli	s8,s8,16	#, prephitmp_203, prephitmp_203
 2343              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2344 12dc 635A0700 		bge	a4,zero,.L356	#, angle,,
 2345              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2346 12e0 B7870000 		li	a5,32768		# tmp163,
 2347 12e4 334CFC00 		xor	s8,s8,a5	# tmp163, prephitmp_203, prephitmp_203
 2348 12e8 13170C01 		slli	a4,s8,16	#, angle, prephitmp_203
 2349 12ec 13570741 		srai	a4,a4,16	#, angle, angle
 2350              	.L356:
 2351              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 2352 12f0 93578740 		srai	a5,a4,8	#, v0, angle
 2353              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2354 12f4 13960701 		slli	a2,a5,16	#, v0.41_53, v0
 2355              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2356 12f8 93F50702 		andi	a1,a5,32	#, tmp167, v0
 2357              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2358 12fc 13560601 		srli	a2,a2,16	#, v0.41_53, v0.41_53
 2359 1300 93060C00 		mv	a3,s8	# _235, prephitmp_203
 2360              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2361 1304 638A0500 		beq	a1,zero,.L357	#, tmp167,,
 2362              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2363 1308 1347F7FF 		not	a4,a4	# tmp171, angle
 2364              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2365 130c 93160701 		slli	a3,a4,16	#, _235, tmp171
 2366              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2367 1310 93C7F7FF 		not	a5,a5	# v0, v0
 2368              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2369 1314 93D60601 		srli	a3,a3,16	#, _235, _235
 2370              	.L357:
 2371              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2372 1318 93F7F701 		andi	a5,a5,31	#, _59, v0
 2373              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2374 131c 13871700 		addi	a4,a5,1	#, tmp179, _59
 2375              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2376 1320 B70B0000 		lui	s7,%hi(.LANCHOR1)	# tmp256,
 2377 1324 938B0B00 		addi	s7,s7,%lo(.LANCHOR1)	# tmp258, tmp256,
 2378 1328 93971700 		slli	a5,a5,1	#, tmp175, _59
 2379              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2380 132c 13171700 		slli	a4,a4,1	#, tmp180, tmp179
 2381              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2382 1330 B387FB00 		add	a5,s7,a5	# tmp175, tmp176, tmp258
 2383              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2384 1334 3387EB00 		add	a4,s7,a4	# tmp180, tmp181, tmp258
 2385              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2386 1338 83950700 		lh	a1,0(a5)		# _60, sin90[_59]
 2387              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2388 133c 03150700 		lh	a0,0(a4)		# sin90[_62], sin90[_62]
 2389              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2390 1340 93F6F60F 		andi	a3,a3,0xff	# tmp185, _235
 2391              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2392 1344 93770604 		andi	a5,a2,64	#, tmp193, v0.41_53
 2393              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2394 1348 3305B540 		sub	a0,a0,a1	# tmp183, sin90[_62], _60
 2395              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2396 134c 3305D502 		mul	a0,a0,a3	# tmp186, tmp183, tmp185
 2397              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2398 1350 13558540 		srai	a0,a0,8	#, tmp187, tmp186
 2399              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2400 1354 3305B500 		add	a0,a0,a1	# _60, tmp190, tmp187
 2401 1358 13150501 		slli	a0,a0,16	#, _74, tmp190
 2402 135c 13550501 		srli	a0,a0,16	#, _74, _74
 2403              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2404 1360 63880700 		beq	a5,zero,.L358	#, tmp193,,
 2405              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2406 1364 3305A040 		neg	a0,a0	# tmp195, _74
 2407 1368 13150501 		slli	a0,a0,16	#, _74, tmp195
 2408 136c 13550501 		srli	a0,a0,16	#, _74, _74
 2409              	.L358:
 2410              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2411 1370 13150501 		slli	a0,a0,16	#,, _74
 2412 1374 13550541 		srai	a0,a0,16	#,,
 2413 1378 97000000 		call	__floatsidf		#
 2413      E7800000 
 2414 1380 B70A0000 		lui	s5,%hi(.LC3)	# tmp257,
 2415 1384 83A64A00 		lw	a3,%lo(.LC3+4)(s5)		#,
 2416 1388 03A60A00 		lw	a2,%lo(.LC3)(s5)		#,
 2417 138c 97000000 		call	__muldf3		#
 2417      E7800000 
 2418              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2419 1394 97000000 		call	__truncdfsf2		#
 2419      E7800000 
 2420              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2421 139c B7A7FFFF 		li	a5,-24576		# tmp203,
 2422 13a0 93871700 		addi	a5,a5,1	#, tmp202, tmp203
 2423 13a4 B307FC00 		add	a5,s8,a5	# tmp202, tmp201, prephitmp_203
 2424              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2425 13a8 93960701 		slli	a3,a5,16	#, angle, tmp201
 2426              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2427 13ac 13970701 		slli	a4,a5,16	#, _42, tmp201
 2428              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2429 13b0 93D60641 		srai	a3,a3,16	#, angle, angle
 2430              	# gfx_lib_hdmi.h:266:   float sin_theta = SIN_FAST(angle);
 2431 13b4 930C0500 		mv	s9,a0	# sin_theta, tmp264
 2432              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2433 13b8 13570701 		srli	a4,a4,16	#, _42, _42
 2434              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2435 13bc 63D00602 		bge	a3,zero,.L359	#, angle,,
 2436              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2437 13c0 B7270000 		li	a5,8192		# tmp206,
 2438 13c4 93871700 		addi	a5,a5,1	#, tmp205, tmp206
 2439 13c8 330CFC00 		add	s8,s8,a5	# tmp205, tmp204, prephitmp_203
 2440 13cc 13170C01 		slli	a4,s8,16	#, _42, tmp204
 2441 13d0 93160C01 		slli	a3,s8,16	#, angle, tmp204
 2442 13d4 13570701 		srli	a4,a4,16	#, _42, _42
 2443 13d8 93D60641 		srai	a3,a3,16	#, angle, angle
 2444              	.L359:
 2445              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 2446 13dc 93D78640 		srai	a5,a3,8	#, v0, angle
 2447              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2448 13e0 13960701 		slli	a2,a5,16	#, v0.41_84, v0
 2449              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2450 13e4 93F50702 		andi	a1,a5,32	#, tmp210, v0
 2451              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2452 13e8 13560601 		srli	a2,a2,16	#, v0.41_84, v0.41_84
 2453              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2454 13ec 638A0500 		beq	a1,zero,.L360	#, tmp210,,
 2455              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2456 13f0 93C6F6FF 		not	a3,a3	# tmp214, angle
 2457              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2458 13f4 13970601 		slli	a4,a3,16	#, _42, tmp214
 2459              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2460 13f8 93C7F7FF 		not	a5,a5	# v0, v0
 2461              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2462 13fc 13570701 		srli	a4,a4,16	#, _42, _42
 2463              	.L360:
 2464              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2465 1400 93F7F701 		andi	a5,a5,31	#, _90, v0
 2466              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2467 1404 93861700 		addi	a3,a5,1	#, tmp222, _90
 2468 1408 93961600 		slli	a3,a3,1	#, tmp223, tmp222
 2469              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2470 140c 93971700 		slli	a5,a5,1	#, tmp218, _90
 2471 1410 B387FB00 		add	a5,s7,a5	# tmp218, tmp219, tmp258
 2472              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2473 1414 B38BDB00 		add	s7,s7,a3	# tmp223, tmp224, tmp258
 2474              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2475 1418 83950700 		lh	a1,0(a5)		# _91, sin90[_90]
 2476              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2477 141c 83970B00 		lh	a5,0(s7)		# sin90[_93], sin90[_93]
 2478              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2479 1420 1377F70F 		andi	a4,a4,0xff	# tmp228, _42
 2480              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2481 1424 93760604 		andi	a3,a2,64	#, tmp236, v0.41_84
 2482              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2483 1428 B387B740 		sub	a5,a5,a1	# tmp226, sin90[_93], _91
 2484              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2485 142c B387E702 		mul	a5,a5,a4	# tmp229, tmp226, tmp228
 2486              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2487 1430 93D78740 		srai	a5,a5,8	#, tmp230, tmp229
 2488              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2489 1434 B387B700 		add	a5,a5,a1	# _91, tmp233, tmp230
 2490 1438 93970701 		slli	a5,a5,16	#, _105, tmp233
 2491 143c 93D70701 		srli	a5,a5,16	#, _105, _105
 2492              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2493 1440 63880600 		beq	a3,zero,.L361	#, tmp236,,
 2494              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2495 1444 B307F040 		neg	a5,a5	# tmp238, _105
 2496 1448 93970701 		slli	a5,a5,16	#, _105, tmp238
 2497 144c 93D70701 		srli	a5,a5,16	#, _105, _105
 2498              	.L361:
 2499              	# gfx_lib_hdmi.h:267:   float cos_theta = COS_FAST(angle);
 2500 1450 13950701 		slli	a0,a5,16	#,, _105
 2501 1454 13550541 		srai	a0,a0,16	#,,
 2502 1458 97000000 		call	__floatsidf		#
 2502      E7800000 
 2503 1460 03A60A00 		lw	a2,%lo(.LC3)(s5)		#,
 2504 1464 83A64A00 		lw	a3,%lo(.LC3+4)(s5)		#,
 2505 1468 97000000 		call	__muldf3		#
 2505      E7800000 
 2506              	# gfx_lib_hdmi.h:267:   float cos_theta = COS_FAST(angle);
 2507 1470 97000000 		call	__truncdfsf2		#
 2507      E7800000 
 2508 1478 93070500 		mv	a5,a0	# tmp265,
 2509              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2510 147c 13050900 		mv	a0,s2	#, _4
 2511              	# gfx_lib_hdmi.h:267:   float cos_theta = COS_FAST(angle);
 2512 1480 13890700 		mv	s2,a5	# tmp243, tmp265
 2513              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2514 1484 97000000 		call	__floatsisf		#
 2514      E7800000 
 2515 148c 930A0500 		mv	s5,a0	# tmp266,
 2516              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2517 1490 13850400 		mv	a0,s1	#, _7
 2518 1494 97000000 		call	__floatsisf		#
 2518      E7800000 
 2519 149c 93040500 		mv	s1,a0	# tmp267,
 2520              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2521 14a0 93050900 		mv	a1,s2	#, tmp243
 2522              	# gfx_lib_hdmi.h:273:   return transformed;
 2523 14a4 23206401 		sw	s6,0(s0)	# _1, <retval>.x
 2524              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2525 14a8 13850A00 		mv	a0,s5	#, _18
 2526 14ac 97000000 		call	__mulsf3		#
 2526      E7800000 
 2527 14b4 130B0500 		mv	s6,a0	# tmp244, tmp268
 2528              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2529 14b8 93850C00 		mv	a1,s9	#, sin_theta
 2530 14bc 13850400 		mv	a0,s1	#, _20
 2531 14c0 97000000 		call	__mulsf3		#
 2531      E7800000 
 2532 14c8 93050500 		mv	a1,a0	# tmp269,
 2533              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2534 14cc 13050B00 		mv	a0,s6	#, tmp244
 2535 14d0 97000000 		call	__subsf3		#
 2535      E7800000 
 2536 14d8 130B0500 		mv	s6,a0	# tmp246, tmp270
 2537              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2538 14dc 13050A00 		mv	a0,s4	#, _3
 2539 14e0 97000000 		call	__floatsisf		#
 2539      E7800000 
 2540 14e8 93050500 		mv	a1,a0	# tmp271,
 2541 14ec 13050B00 		mv	a0,s6	#, tmp246
 2542 14f0 97000000 		call	__addsf3		#
 2542      E7800000 
 2543              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2544 14f8 97000000 		call	__fixsfsi		#
 2544      E7800000 
 2545              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 2546 1500 93850C00 		mv	a1,s9	#, sin_theta
 2547              	# gfx_lib_hdmi.h:270:   transformed.y = pivot->y + (shifted_point.y*cos_theta - shifted_point.z*sin
 2548 1504 2322A400 		sw	a0,4(s0)	# tmp272, <retval>.y
 2549              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 2550 1508 13850A00 		mv	a0,s5	#, _18
 2551 150c 97000000 		call	__mulsf3		#
 2551      E7800000 
 2552 1514 130A0500 		mv	s4,a0	# tmp250, tmp273
 2553              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 2554 1518 93050900 		mv	a1,s2	#, tmp243
 2555 151c 13850400 		mv	a0,s1	#, _20
 2556 1520 97000000 		call	__mulsf3		#
 2556      E7800000 
 2557 1528 93050500 		mv	a1,a0	# tmp274,
 2558              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 2559 152c 13050A00 		mv	a0,s4	#, tmp250
 2560 1530 97000000 		call	__addsf3		#
 2560      E7800000 
 2561 1538 93040500 		mv	s1,a0	# tmp252, tmp275
 2562              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 2563 153c 13850900 		mv	a0,s3	#, _6
 2564 1540 97000000 		call	__floatsisf		#
 2564      E7800000 
 2565 1548 93050500 		mv	a1,a0	# tmp276,
 2566 154c 13850400 		mv	a0,s1	#, tmp252
 2567 1550 97000000 		call	__addsf3		#
 2567      E7800000 
 2568              	# gfx_lib_hdmi.h:271:   transformed.z = pivot->z + (shifted_point.y*sin_theta + shifted_point.z*cos
 2569 1558 97000000 		call	__fixsfsi		#
 2569      E7800000 
 2570 1560 2324A400 		sw	a0,8(s0)	# tmp277, <retval>.z
 2571              	# gfx_lib_hdmi.h:274: }
 2572 1564 8320C102 		lw	ra,44(sp)		#,
 2573 1568 13050400 		mv	a0,s0	#, .result_ptr
 2574 156c 03248102 		lw	s0,40(sp)		#,
 2575 1570 83244102 		lw	s1,36(sp)		#,
 2576 1574 03290102 		lw	s2,32(sp)		#,
 2577 1578 8329C101 		lw	s3,28(sp)		#,
 2578 157c 032A8101 		lw	s4,24(sp)		#,
 2579 1580 832A4101 		lw	s5,20(sp)		#,
 2580 1584 032B0101 		lw	s6,16(sp)		#,
 2581 1588 832BC100 		lw	s7,12(sp)		#,
 2582 158c 032C8100 		lw	s8,8(sp)		#,
 2583 1590 832C4100 		lw	s9,4(sp)		#,
 2584 1594 13010103 		addi	sp,sp,48	#,,
 2585 1598 67800000 		jr	ra		#
 2587              		.align	2
 2588              		.globl	rotateY_pivot
 2590              	rotateY_pivot:
 2591 159c 130101FD 		addi	sp,sp,-48	#,,
 2592 15a0 23248102 		sw	s0,40(sp)	#,
 2593 15a4 13040500 		mv	s0,a0	# tmp259, .result_ptr
 2594              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2595 15a8 13850600 		mv	a0,a3	#, tmp262
 2596              	# gfx_lib_hdmi.h:276: point rotateY_pivot(point *p, point *pivot, int angle) {
 2597 15ac 23261102 		sw	ra,44(sp)	#,
 2598 15b0 23229102 		sw	s1,36(sp)	#,
 2599 15b4 23202103 		sw	s2,32(sp)	#,
 2600              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2601 15b8 83A48500 		lw	s1,8(a1)		# p_32(D)->z, p_32(D)->z
 2602              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2603 15bc 03A90500 		lw	s2,0(a1)		# p_32(D)->x, p_32(D)->x
 2604              	# gfx_lib_hdmi.h:276: point rotateY_pivot(point *p, point *pivot, int angle) {
 2605 15c0 232E3101 		sw	s3,28(sp)	#,
 2606 15c4 232C4101 		sw	s4,24(sp)	#,
 2607              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2608 15c8 83298600 		lw	s3,8(a2)		# _6, pivot_33(D)->z
 2609              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2610 15cc 032A0600 		lw	s4,0(a2)		# _2, pivot_33(D)->x
 2611              	# gfx_lib_hdmi.h:276: point rotateY_pivot(point *p, point *pivot, int angle) {
 2612 15d0 23286101 		sw	s6,16(sp)	#,
 2613 15d4 23248101 		sw	s8,8(sp)	#,
 2614              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2615 15d8 03AB4500 		lw	s6,4(a1)		# _4, p_32(D)->y
 2616              	# gfx_lib_hdmi.h:276: point rotateY_pivot(point *p, point *pivot, int angle) {
 2617 15dc 232A5101 		sw	s5,20(sp)	#,
 2618 15e0 23267101 		sw	s7,12(sp)	#,
 2619 15e4 23229101 		sw	s9,4(sp)	#,
 2620              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2621 15e8 97000000 		call	__floatsidf		#
 2621      E7800000 
 2622 15f0 B7070000 		lui	a5,%hi(.LC1)	# tmp156,
 2623 15f4 03A60700 		lw	a2,%lo(.LC1)(a5)		#,
 2624 15f8 83A64700 		lw	a3,%lo(.LC1+4)(a5)		#,
 2625              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2626 15fc 33094941 		sub	s2,s2,s4	# _3, p_32(D)->x, _2
 2627              	# gfx_lib_hdmi.h:277:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2628 1600 B3843441 		sub	s1,s1,s3	# _7, p_32(D)->z, _6
 2629              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2630 1604 97000000 		call	__muldf3		#
 2630      E7800000 
 2631 160c B7070000 		lui	a5,%hi(.LC2)	# tmp158,
 2632 1610 03A60700 		lw	a2,%lo(.LC2)(a5)		#,
 2633 1614 83A64700 		lw	a3,%lo(.LC2+4)(a5)		#,
 2634 1618 97000000 		call	__divdf3		#
 2634      E7800000 
 2635 1620 97000000 		call	__fixdfsi		#
 2635      E7800000 
 2636 1628 13170501 		slli	a4,a0,16	#, angle, tmp263
 2637              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2638 162c 131C0501 		slli	s8,a0,16	#, prephitmp_203, tmp263
 2639              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2640 1630 13570741 		srai	a4,a4,16	#, angle, angle
 2641              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2642 1634 135C0C01 		srli	s8,s8,16	#, prephitmp_203, prephitmp_203
 2643              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2644 1638 635A0700 		bge	a4,zero,.L375	#, angle,,
 2645              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2646 163c B7870000 		li	a5,32768		# tmp163,
 2647 1640 334CFC00 		xor	s8,s8,a5	# tmp163, prephitmp_203, prephitmp_203
 2648 1644 13170C01 		slli	a4,s8,16	#, angle, prephitmp_203
 2649 1648 13570741 		srai	a4,a4,16	#, angle, angle
 2650              	.L375:
 2651              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 2652 164c 93578740 		srai	a5,a4,8	#, v0, angle
 2653              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2654 1650 13960701 		slli	a2,a5,16	#, v0.41_53, v0
 2655              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2656 1654 93F50702 		andi	a1,a5,32	#, tmp167, v0
 2657              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2658 1658 13560601 		srli	a2,a2,16	#, v0.41_53, v0.41_53
 2659 165c 93060C00 		mv	a3,s8	# _235, prephitmp_203
 2660              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2661 1660 638A0500 		beq	a1,zero,.L376	#, tmp167,,
 2662              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2663 1664 1347F7FF 		not	a4,a4	# tmp171, angle
 2664              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2665 1668 93160701 		slli	a3,a4,16	#, _235, tmp171
 2666              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2667 166c 93C7F7FF 		not	a5,a5	# v0, v0
 2668              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2669 1670 93D60601 		srli	a3,a3,16	#, _235, _235
 2670              	.L376:
 2671              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2672 1674 93F7F701 		andi	a5,a5,31	#, _59, v0
 2673              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2674 1678 13871700 		addi	a4,a5,1	#, tmp179, _59
 2675              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2676 167c B70B0000 		lui	s7,%hi(.LANCHOR1)	# tmp256,
 2677 1680 938B0B00 		addi	s7,s7,%lo(.LANCHOR1)	# tmp258, tmp256,
 2678 1684 93971700 		slli	a5,a5,1	#, tmp175, _59
 2679              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2680 1688 13171700 		slli	a4,a4,1	#, tmp180, tmp179
 2681              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2682 168c B387FB00 		add	a5,s7,a5	# tmp175, tmp176, tmp258
 2683              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2684 1690 3387EB00 		add	a4,s7,a4	# tmp180, tmp181, tmp258
 2685              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2686 1694 83950700 		lh	a1,0(a5)		# _60, sin90[_59]
 2687              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2688 1698 03150700 		lh	a0,0(a4)		# sin90[_62], sin90[_62]
 2689              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2690 169c 93F6F60F 		andi	a3,a3,0xff	# tmp185, _235
 2691              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2692 16a0 93770604 		andi	a5,a2,64	#, tmp193, v0.41_53
 2693              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2694 16a4 3305B540 		sub	a0,a0,a1	# tmp183, sin90[_62], _60
 2695              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2696 16a8 3305D502 		mul	a0,a0,a3	# tmp186, tmp183, tmp185
 2697              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2698 16ac 13558540 		srai	a0,a0,8	#, tmp187, tmp186
 2699              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2700 16b0 3305B500 		add	a0,a0,a1	# _60, tmp190, tmp187
 2701 16b4 13150501 		slli	a0,a0,16	#, _74, tmp190
 2702 16b8 13550501 		srli	a0,a0,16	#, _74, _74
 2703              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2704 16bc 63880700 		beq	a5,zero,.L377	#, tmp193,,
 2705              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2706 16c0 3305A040 		neg	a0,a0	# tmp195, _74
 2707 16c4 13150501 		slli	a0,a0,16	#, _74, tmp195
 2708 16c8 13550501 		srli	a0,a0,16	#, _74, _74
 2709              	.L377:
 2710              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2711 16cc 13150501 		slli	a0,a0,16	#,, _74
 2712 16d0 13550541 		srai	a0,a0,16	#,,
 2713 16d4 97000000 		call	__floatsidf		#
 2713      E7800000 
 2714 16dc B70A0000 		lui	s5,%hi(.LC3)	# tmp257,
 2715 16e0 83A64A00 		lw	a3,%lo(.LC3+4)(s5)		#,
 2716 16e4 03A60A00 		lw	a2,%lo(.LC3)(s5)		#,
 2717 16e8 97000000 		call	__muldf3		#
 2717      E7800000 
 2718              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2719 16f0 97000000 		call	__truncdfsf2		#
 2719      E7800000 
 2720              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2721 16f8 B7A7FFFF 		li	a5,-24576		# tmp203,
 2722 16fc 93871700 		addi	a5,a5,1	#, tmp202, tmp203
 2723 1700 B307FC00 		add	a5,s8,a5	# tmp202, tmp201, prephitmp_203
 2724              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2725 1704 93960701 		slli	a3,a5,16	#, angle, tmp201
 2726              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2727 1708 13970701 		slli	a4,a5,16	#, _42, tmp201
 2728              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2729 170c 93D60641 		srai	a3,a3,16	#, angle, angle
 2730              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 2731 1710 930C0500 		mv	s9,a0	# sin_theta, tmp264
 2732              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 2733 1714 13570701 		srli	a4,a4,16	#, _42, _42
 2734              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2735 1718 63D00602 		bge	a3,zero,.L378	#, angle,,
 2736              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2737 171c B7270000 		li	a5,8192		# tmp206,
 2738 1720 93871700 		addi	a5,a5,1	#, tmp205, tmp206
 2739 1724 330CFC00 		add	s8,s8,a5	# tmp205, tmp204, prephitmp_203
 2740 1728 13170C01 		slli	a4,s8,16	#, _42, tmp204
 2741 172c 93160C01 		slli	a3,s8,16	#, angle, tmp204
 2742 1730 13570701 		srli	a4,a4,16	#, _42, _42
 2743 1734 93D60641 		srai	a3,a3,16	#, angle, angle
 2744              	.L378:
 2745              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 2746 1738 93D78640 		srai	a5,a3,8	#, v0, angle
 2747              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2748 173c 13960701 		slli	a2,a5,16	#, v0.41_84, v0
 2749              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2750 1740 93F50702 		andi	a1,a5,32	#, tmp210, v0
 2751              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2752 1744 13560601 		srli	a2,a2,16	#, v0.41_84, v0.41_84
 2753              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2754 1748 638A0500 		beq	a1,zero,.L379	#, tmp210,,
 2755              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2756 174c 93C6F6FF 		not	a3,a3	# tmp214, angle
 2757              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2758 1750 13970601 		slli	a4,a3,16	#, _42, tmp214
 2759              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2760 1754 93C7F7FF 		not	a5,a5	# v0, v0
 2761              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2762 1758 13570701 		srli	a4,a4,16	#, _42, _42
 2763              	.L379:
 2764              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2765 175c 93F7F701 		andi	a5,a5,31	#, _90, v0
 2766              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2767 1760 93861700 		addi	a3,a5,1	#, tmp222, _90
 2768 1764 93961600 		slli	a3,a3,1	#, tmp223, tmp222
 2769              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2770 1768 93971700 		slli	a5,a5,1	#, tmp218, _90
 2771 176c B387FB00 		add	a5,s7,a5	# tmp218, tmp219, tmp258
 2772              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2773 1770 B38BDB00 		add	s7,s7,a3	# tmp223, tmp224, tmp258
 2774              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2775 1774 83950700 		lh	a1,0(a5)		# _91, sin90[_90]
 2776              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2777 1778 83970B00 		lh	a5,0(s7)		# sin90[_93], sin90[_93]
 2778              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2779 177c 1377F70F 		andi	a4,a4,0xff	# tmp228, _42
 2780              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2781 1780 93760604 		andi	a3,a2,64	#, tmp236, v0.41_84
 2782              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2783 1784 B387B740 		sub	a5,a5,a1	# tmp226, sin90[_93], _91
 2784              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2785 1788 B387E702 		mul	a5,a5,a4	# tmp229, tmp226, tmp228
 2786              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2787 178c 93D78740 		srai	a5,a5,8	#, tmp230, tmp229
 2788              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2789 1790 B387B700 		add	a5,a5,a1	# _91, tmp233, tmp230
 2790 1794 93970701 		slli	a5,a5,16	#, _105, tmp233
 2791 1798 93D70701 		srli	a5,a5,16	#, _105, _105
 2792              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2793 179c 63880600 		beq	a3,zero,.L380	#, tmp236,,
 2794              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2795 17a0 B307F040 		neg	a5,a5	# tmp238, _105
 2796 17a4 93970701 		slli	a5,a5,16	#, _105, tmp238
 2797 17a8 93D70701 		srli	a5,a5,16	#, _105, _105
 2798              	.L380:
 2799              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 2800 17ac 13950701 		slli	a0,a5,16	#,, _105
 2801 17b0 13550541 		srai	a0,a0,16	#,,
 2802 17b4 97000000 		call	__floatsidf		#
 2802      E7800000 
 2803 17bc 03A60A00 		lw	a2,%lo(.LC3)(s5)		#,
 2804 17c0 83A64A00 		lw	a3,%lo(.LC3+4)(s5)		#,
 2805 17c4 97000000 		call	__muldf3		#
 2805      E7800000 
 2806              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 2807 17cc 97000000 		call	__truncdfsf2		#
 2807      E7800000 
 2808 17d4 930A0500 		mv	s5,a0	# tmp265,
 2809              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2810 17d8 13050900 		mv	a0,s2	#, _3
 2811 17dc 97000000 		call	__floatsisf		#
 2811      E7800000 
 2812 17e4 93070500 		mv	a5,a0	# tmp266,
 2813              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2814 17e8 13850400 		mv	a0,s1	#, _7
 2815              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2816 17ec 93840700 		mv	s1,a5	# _18, tmp266
 2817              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2818 17f0 97000000 		call	__floatsisf		#
 2818      E7800000 
 2819 17f8 13090500 		mv	s2,a0	# tmp267,
 2820              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2821 17fc 93850A00 		mv	a1,s5	#, tmp243
 2822 1800 13850400 		mv	a0,s1	#, _18
 2823 1804 97000000 		call	__mulsf3		#
 2823      E7800000 
 2824 180c 930B0500 		mv	s7,a0	# tmp244, tmp268
 2825              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2826 1810 93850C00 		mv	a1,s9	#, sin_theta
 2827 1814 13050900 		mv	a0,s2	#, _20
 2828 1818 97000000 		call	__mulsf3		#
 2828      E7800000 
 2829 1820 93050500 		mv	a1,a0	# tmp269,
 2830              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2831 1824 13850B00 		mv	a0,s7	#, tmp244
 2832 1828 97000000 		call	__addsf3		#
 2832      E7800000 
 2833 1830 930B0500 		mv	s7,a0	# tmp246, tmp270
 2834              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2835 1834 13050A00 		mv	a0,s4	#, _2
 2836 1838 97000000 		call	__floatsisf		#
 2836      E7800000 
 2837 1840 93050500 		mv	a1,a0	# tmp271,
 2838 1844 13850B00 		mv	a0,s7	#, tmp246
 2839 1848 97000000 		call	__addsf3		#
 2839      E7800000 
 2840              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2841 1850 97000000 		call	__fixsfsi		#
 2841      E7800000 
 2842              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 2843 1858 93850A00 		mv	a1,s5	#, tmp243
 2844              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 2845 185c 2320A400 		sw	a0,0(s0)	# tmp272, <retval>.x
 2846              	# gfx_lib_hdmi.h:288:   return transformed;
 2847 1860 23226401 		sw	s6,4(s0)	# _4, <retval>.y
 2848              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 2849 1864 13050900 		mv	a0,s2	#, _20
 2850 1868 97000000 		call	__mulsf3		#
 2850      E7800000 
 2851 1870 13090500 		mv	s2,a0	# tmp250, tmp273
 2852              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 2853 1874 93850C00 		mv	a1,s9	#, sin_theta
 2854 1878 13850400 		mv	a0,s1	#, _18
 2855 187c 97000000 		call	__mulsf3		#
 2855      E7800000 
 2856 1884 93050500 		mv	a1,a0	# tmp274,
 2857              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 2858 1888 13050900 		mv	a0,s2	#, tmp250
 2859 188c 97000000 		call	__subsf3		#
 2859      E7800000 
 2860 1894 93040500 		mv	s1,a0	# tmp252, tmp275
 2861              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 2862 1898 13850900 		mv	a0,s3	#, _6
 2863 189c 97000000 		call	__floatsisf		#
 2863      E7800000 
 2864 18a4 93050500 		mv	a1,a0	# tmp276,
 2865 18a8 13850400 		mv	a0,s1	#, tmp252
 2866 18ac 97000000 		call	__addsf3		#
 2866      E7800000 
 2867              	# gfx_lib_hdmi.h:286:   transformed.z = pivot->z + (shifted_point.z*cos_theta - shifted_point.x*sin
 2868 18b4 97000000 		call	__fixsfsi		#
 2868      E7800000 
 2869 18bc 2324A400 		sw	a0,8(s0)	# tmp277, <retval>.z
 2870              	# gfx_lib_hdmi.h:289: }
 2871 18c0 8320C102 		lw	ra,44(sp)		#,
 2872 18c4 13050400 		mv	a0,s0	#, .result_ptr
 2873 18c8 03248102 		lw	s0,40(sp)		#,
 2874 18cc 83244102 		lw	s1,36(sp)		#,
 2875 18d0 03290102 		lw	s2,32(sp)		#,
 2876 18d4 8329C101 		lw	s3,28(sp)		#,
 2877 18d8 032A8101 		lw	s4,24(sp)		#,
 2878 18dc 832A4101 		lw	s5,20(sp)		#,
 2879 18e0 032B0101 		lw	s6,16(sp)		#,
 2880 18e4 832BC100 		lw	s7,12(sp)		#,
 2881 18e8 032C8100 		lw	s8,8(sp)		#,
 2882 18ec 832C4100 		lw	s9,4(sp)		#,
 2883 18f0 13010103 		addi	sp,sp,48	#,,
 2884 18f4 67800000 		jr	ra		#
 2886              		.align	2
 2887              		.globl	rotateZ_pivot
 2889              	rotateZ_pivot:
 2890 18f8 130101FD 		addi	sp,sp,-48	#,,
 2891 18fc 23248102 		sw	s0,40(sp)	#,
 2892 1900 13040500 		mv	s0,a0	# tmp259, .result_ptr
 2893              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2894 1904 13850600 		mv	a0,a3	#, tmp262
 2895              	# gfx_lib_hdmi.h:291: point rotateZ_pivot(point *p, point *pivot, int angle) {
 2896 1908 23261102 		sw	ra,44(sp)	#,
 2897 190c 23229102 		sw	s1,36(sp)	#,
 2898 1910 23202103 		sw	s2,32(sp)	#,
 2899              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2900 1914 83A44500 		lw	s1,4(a1)		# p_32(D)->y, p_32(D)->y
 2901              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2902 1918 03A90500 		lw	s2,0(a1)		# p_32(D)->x, p_32(D)->x
 2903              	# gfx_lib_hdmi.h:291: point rotateZ_pivot(point *p, point *pivot, int angle) {
 2904 191c 232E3101 		sw	s3,28(sp)	#,
 2905 1920 232C4101 		sw	s4,24(sp)	#,
 2906              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2907 1924 83294600 		lw	s3,4(a2)		# _5, pivot_33(D)->y
 2908              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2909 1928 032A0600 		lw	s4,0(a2)		# _2, pivot_33(D)->x
 2910              	# gfx_lib_hdmi.h:291: point rotateZ_pivot(point *p, point *pivot, int angle) {
 2911 192c 23286101 		sw	s6,16(sp)	#,
 2912 1930 23248101 		sw	s8,8(sp)	#,
 2913              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2914 1934 03AB8500 		lw	s6,8(a1)		# _7, p_32(D)->z
 2915              	# gfx_lib_hdmi.h:291: point rotateZ_pivot(point *p, point *pivot, int angle) {
 2916 1938 232A5101 		sw	s5,20(sp)	#,
 2917 193c 23267101 		sw	s7,12(sp)	#,
 2918 1940 23229101 		sw	s9,4(sp)	#,
 2919              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2920 1944 97000000 		call	__floatsidf		#
 2920      E7800000 
 2921 194c B7070000 		lui	a5,%hi(.LC1)	# tmp156,
 2922 1950 03A60700 		lw	a2,%lo(.LC1)(a5)		#,
 2923 1954 83A64700 		lw	a3,%lo(.LC1+4)(a5)		#,
 2924              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2925 1958 33094941 		sub	s2,s2,s4	# _3, p_32(D)->x, _2
 2926              	# gfx_lib_hdmi.h:292:   point shifted_point = {p->x - pivot->x, p->y - pivot->y, p->z - pivot->z};
 2927 195c B3843441 		sub	s1,s1,s3	# _6, p_32(D)->y, _5
 2928              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2929 1960 97000000 		call	__muldf3		#
 2929      E7800000 
 2930 1968 B7070000 		lui	a5,%hi(.LC2)	# tmp158,
 2931 196c 03A60700 		lw	a2,%lo(.LC2)(a5)		#,
 2932 1970 83A64700 		lw	a3,%lo(.LC2+4)(a5)		#,
 2933 1974 97000000 		call	__divdf3		#
 2933      E7800000 
 2934 197c 97000000 		call	__fixdfsi		#
 2934      E7800000 
 2935 1984 13170501 		slli	a4,a0,16	#, angle, tmp263
 2936              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2937 1988 131C0501 		slli	s8,a0,16	#, prephitmp_203, tmp263
 2938              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 2939 198c 13570741 		srai	a4,a4,16	#, angle, angle
 2940              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2941 1990 135C0C01 		srli	s8,s8,16	#, prephitmp_203, prephitmp_203
 2942              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2943 1994 635A0700 		bge	a4,zero,.L394	#, angle,,
 2944              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 2945 1998 B7870000 		li	a5,32768		# tmp163,
 2946 199c 334CFC00 		xor	s8,s8,a5	# tmp163, prephitmp_203, prephitmp_203
 2947 19a0 13170C01 		slli	a4,s8,16	#, angle, prephitmp_203
 2948 19a4 13570741 		srai	a4,a4,16	#, angle, angle
 2949              	.L394:
 2950              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 2951 19a8 93578740 		srai	a5,a4,8	#, v0, angle
 2952              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2953 19ac 13960701 		slli	a2,a5,16	#, v0.41_53, v0
 2954              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2955 19b0 93F50702 		andi	a1,a5,32	#, tmp167, v0
 2956              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2957 19b4 13560601 		srli	a2,a2,16	#, v0.41_53, v0.41_53
 2958 19b8 93060C00 		mv	a3,s8	# _235, prephitmp_203
 2959              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2960 19bc 638A0500 		beq	a1,zero,.L395	#, tmp167,,
 2961              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2962 19c0 1347F7FF 		not	a4,a4	# tmp171, angle
 2963              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2964 19c4 93160701 		slli	a3,a4,16	#, _235, tmp171
 2965              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 2966 19c8 93C7F7FF 		not	a5,a5	# v0, v0
 2967              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2968 19cc 93D60601 		srli	a3,a3,16	#, _235, _235
 2969              	.L395:
 2970              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2971 19d0 93F7F701 		andi	a5,a5,31	#, _59, v0
 2972              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2973 19d4 13871700 		addi	a4,a5,1	#, tmp179, _59
 2974              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2975 19d8 B70B0000 		lui	s7,%hi(.LANCHOR1)	# tmp256,
 2976 19dc 938B0B00 		addi	s7,s7,%lo(.LANCHOR1)	# tmp258, tmp256,
 2977 19e0 93971700 		slli	a5,a5,1	#, tmp175, _59
 2978              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2979 19e4 13171700 		slli	a4,a4,1	#, tmp180, tmp179
 2980              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2981 19e8 B387FB00 		add	a5,s7,a5	# tmp175, tmp176, tmp258
 2982              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2983 19ec 3387EB00 		add	a4,s7,a4	# tmp180, tmp181, tmp258
 2984              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2985 19f0 83950700 		lh	a1,0(a5)		# _60, sin90[_59]
 2986              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2987 19f4 03150700 		lh	a0,0(a4)		# sin90[_62], sin90[_62]
 2988              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2989 19f8 93F6F60F 		andi	a3,a3,0xff	# tmp185, _235
 2990              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 2991 19fc 93770604 		andi	a5,a2,64	#, tmp193, v0.41_53
 2992              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2993 1a00 3305B540 		sub	a0,a0,a1	# tmp183, sin90[_62], _60
 2994              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2995 1a04 3305D502 		mul	a0,a0,a3	# tmp186, tmp183, tmp185
 2996              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2997 1a08 13558540 		srai	a0,a0,8	#, tmp187, tmp186
 2998              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 2999 1a0c 3305B500 		add	a0,a0,a1	# _60, tmp190, tmp187
 3000 1a10 13150501 		slli	a0,a0,16	#, _74, tmp190
 3001 1a14 13550501 		srli	a0,a0,16	#, _74, _74
 3002              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 3003 1a18 63880700 		beq	a5,zero,.L396	#, tmp193,,
 3004              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 3005 1a1c 3305A040 		neg	a0,a0	# tmp195, _74
 3006 1a20 13150501 		slli	a0,a0,16	#, _74, tmp195
 3007 1a24 13550501 		srli	a0,a0,16	#, _74, _74
 3008              	.L396:
 3009              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 3010 1a28 13150501 		slli	a0,a0,16	#,, _74
 3011 1a2c 13550541 		srai	a0,a0,16	#,,
 3012 1a30 97000000 		call	__floatsidf		#
 3012      E7800000 
 3013 1a38 B70A0000 		lui	s5,%hi(.LC3)	# tmp257,
 3014 1a3c 83A64A00 		lw	a3,%lo(.LC3+4)(s5)		#,
 3015 1a40 03A60A00 		lw	a2,%lo(.LC3)(s5)		#,
 3016 1a44 97000000 		call	__muldf3		#
 3016      E7800000 
 3017              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 3018 1a4c 97000000 		call	__truncdfsf2		#
 3018      E7800000 
 3019              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3020 1a54 B7A7FFFF 		li	a5,-24576		# tmp203,
 3021 1a58 93871700 		addi	a5,a5,1	#, tmp202, tmp203
 3022 1a5c B307FC00 		add	a5,s8,a5	# tmp202, tmp201, prephitmp_203
 3023              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3024 1a60 93960701 		slli	a3,a5,16	#, angle, tmp201
 3025              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3026 1a64 13970701 		slli	a4,a5,16	#, _42, tmp201
 3027              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3028 1a68 93D60641 		srai	a3,a3,16	#, angle, angle
 3029              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 3030 1a6c 930C0500 		mv	s9,a0	# sin_theta, tmp264
 3031              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3032 1a70 13570701 		srli	a4,a4,16	#, _42, _42
 3033              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 3034 1a74 63D00602 		bge	a3,zero,.L397	#, angle,,
 3035              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 3036 1a78 B7270000 		li	a5,8192		# tmp206,
 3037 1a7c 93871700 		addi	a5,a5,1	#, tmp205, tmp206
 3038 1a80 330CFC00 		add	s8,s8,a5	# tmp205, tmp204, prephitmp_203
 3039 1a84 13170C01 		slli	a4,s8,16	#, _42, tmp204
 3040 1a88 93160C01 		slli	a3,s8,16	#, angle, tmp204
 3041 1a8c 13570701 		srli	a4,a4,16	#, _42, _42
 3042 1a90 93D60641 		srai	a3,a3,16	#, angle, angle
 3043              	.L397:
 3044              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 3045 1a94 93D78640 		srai	a5,a3,8	#, v0, angle
 3046              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3047 1a98 13960701 		slli	a2,a5,16	#, v0.41_84, v0
 3048              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3049 1a9c 93F50702 		andi	a1,a5,32	#, tmp210, v0
 3050              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3051 1aa0 13560601 		srli	a2,a2,16	#, v0.41_84, v0.41_84
 3052              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3053 1aa4 638A0500 		beq	a1,zero,.L398	#, tmp210,,
 3054              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3055 1aa8 93C6F6FF 		not	a3,a3	# tmp214, angle
 3056              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3057 1aac 13970601 		slli	a4,a3,16	#, _42, tmp214
 3058              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3059 1ab0 93C7F7FF 		not	a5,a5	# v0, v0
 3060              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3061 1ab4 13570701 		srli	a4,a4,16	#, _42, _42
 3062              	.L398:
 3063              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3064 1ab8 93F7F701 		andi	a5,a5,31	#, _90, v0
 3065              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3066 1abc 93861700 		addi	a3,a5,1	#, tmp222, _90
 3067 1ac0 93961600 		slli	a3,a3,1	#, tmp223, tmp222
 3068              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3069 1ac4 93971700 		slli	a5,a5,1	#, tmp218, _90
 3070 1ac8 B387FB00 		add	a5,s7,a5	# tmp218, tmp219, tmp258
 3071              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3072 1acc B38BDB00 		add	s7,s7,a3	# tmp223, tmp224, tmp258
 3073              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3074 1ad0 83950700 		lh	a1,0(a5)		# _91, sin90[_90]
 3075              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3076 1ad4 83970B00 		lh	a5,0(s7)		# sin90[_93], sin90[_93]
 3077              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3078 1ad8 1377F70F 		andi	a4,a4,0xff	# tmp228, _42
 3079              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 3080 1adc 93760604 		andi	a3,a2,64	#, tmp236, v0.41_84
 3081              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3082 1ae0 B387B740 		sub	a5,a5,a1	# tmp226, sin90[_93], _91
 3083              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3084 1ae4 B387E702 		mul	a5,a5,a4	# tmp229, tmp226, tmp228
 3085              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3086 1ae8 93D78740 		srai	a5,a5,8	#, tmp230, tmp229
 3087              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3088 1aec B387B700 		add	a5,a5,a1	# _91, tmp233, tmp230
 3089 1af0 93970701 		slli	a5,a5,16	#, _105, tmp233
 3090 1af4 93D70701 		srli	a5,a5,16	#, _105, _105
 3091              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 3092 1af8 63880600 		beq	a3,zero,.L399	#, tmp236,,
 3093              	# gfx_lib_hdmi.h:92:   if((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;
 3094 1afc B307F040 		neg	a5,a5	# tmp238, _105
 3095 1b00 93970701 		slli	a5,a5,16	#, _105, tmp238
 3096 1b04 93D70701 		srli	a5,a5,16	#, _105, _105
 3097              	.L399:
 3098              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 3099 1b08 13950701 		slli	a0,a5,16	#,, _105
 3100 1b0c 13550541 		srai	a0,a0,16	#,,
 3101 1b10 97000000 		call	__floatsidf		#
 3101      E7800000 
 3102 1b18 03A60A00 		lw	a2,%lo(.LC3)(s5)		#,
 3103 1b1c 83A64A00 		lw	a3,%lo(.LC3+4)(s5)		#,
 3104 1b20 97000000 		call	__muldf3		#
 3104      E7800000 
 3105              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 3106 1b28 97000000 		call	__truncdfsf2		#
 3106      E7800000 
 3107 1b30 93070500 		mv	a5,a0	# tmp265,
 3108              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3109 1b34 13050900 		mv	a0,s2	#, _3
 3110              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 3111 1b38 13890700 		mv	s2,a5	# tmp243, tmp265
 3112              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3113 1b3c 97000000 		call	__floatsisf		#
 3113      E7800000 
 3114 1b44 930A0500 		mv	s5,a0	# tmp266,
 3115              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3116 1b48 13850400 		mv	a0,s1	#, _6
 3117 1b4c 97000000 		call	__floatsisf		#
 3117      E7800000 
 3118 1b54 93040500 		mv	s1,a0	# tmp267,
 3119              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3120 1b58 93050900 		mv	a1,s2	#, tmp243
 3121 1b5c 13850A00 		mv	a0,s5	#, _18
 3122 1b60 97000000 		call	__mulsf3		#
 3122      E7800000 
 3123 1b68 930B0500 		mv	s7,a0	# tmp244, tmp268
 3124              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3125 1b6c 93850C00 		mv	a1,s9	#, sin_theta
 3126 1b70 13850400 		mv	a0,s1	#, _20
 3127 1b74 97000000 		call	__mulsf3		#
 3127      E7800000 
 3128 1b7c 93050500 		mv	a1,a0	# tmp269,
 3129              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3130 1b80 13850B00 		mv	a0,s7	#, tmp244
 3131 1b84 97000000 		call	__subsf3		#
 3131      E7800000 
 3132 1b8c 930B0500 		mv	s7,a0	# tmp246, tmp270
 3133              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3134 1b90 13050A00 		mv	a0,s4	#, _2
 3135 1b94 97000000 		call	__floatsisf		#
 3135      E7800000 
 3136 1b9c 93050500 		mv	a1,a0	# tmp271,
 3137 1ba0 13850B00 		mv	a0,s7	#, tmp246
 3138 1ba4 97000000 		call	__addsf3		#
 3138      E7800000 
 3139              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3140 1bac 97000000 		call	__fixsfsi		#
 3140      E7800000 
 3141              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3142 1bb4 93850C00 		mv	a1,s9	#, sin_theta
 3143              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3144 1bb8 2320A400 		sw	a0,0(s0)	# tmp272, <retval>.x
 3145              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3146 1bbc 13850A00 		mv	a0,s5	#, _18
 3147 1bc0 97000000 		call	__mulsf3		#
 3147      E7800000 
 3148 1bc8 130A0500 		mv	s4,a0	# tmp250, tmp273
 3149              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3150 1bcc 93050900 		mv	a1,s2	#, tmp243
 3151 1bd0 13850400 		mv	a0,s1	#, _20
 3152 1bd4 97000000 		call	__mulsf3		#
 3152      E7800000 
 3153 1bdc 93050500 		mv	a1,a0	# tmp274,
 3154              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3155 1be0 13050A00 		mv	a0,s4	#, tmp250
 3156 1be4 97000000 		call	__addsf3		#
 3156      E7800000 
 3157 1bec 93040500 		mv	s1,a0	# tmp252, tmp275
 3158              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3159 1bf0 13850900 		mv	a0,s3	#, _5
 3160 1bf4 97000000 		call	__floatsisf		#
 3160      E7800000 
 3161 1bfc 93050500 		mv	a1,a0	# tmp276,
 3162 1c00 13850400 		mv	a0,s1	#, tmp252
 3163 1c04 97000000 		call	__addsf3		#
 3163      E7800000 
 3164              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3165 1c0c 97000000 		call	__fixsfsi		#
 3165      E7800000 
 3166 1c14 2322A400 		sw	a0,4(s0)	# tmp277, <retval>.y
 3167              	# gfx_lib_hdmi.h:303:   return transformed;
 3168 1c18 23246401 		sw	s6,8(s0)	# _7, <retval>.z
 3169              	# gfx_lib_hdmi.h:304: }
 3170 1c1c 8320C102 		lw	ra,44(sp)		#,
 3171 1c20 13050400 		mv	a0,s0	#, .result_ptr
 3172 1c24 03248102 		lw	s0,40(sp)		#,
 3173 1c28 83244102 		lw	s1,36(sp)		#,
 3174 1c2c 03290102 		lw	s2,32(sp)		#,
 3175 1c30 8329C101 		lw	s3,28(sp)		#,
 3176 1c34 032A8101 		lw	s4,24(sp)		#,
 3177 1c38 832A4101 		lw	s5,20(sp)		#,
 3178 1c3c 032B0101 		lw	s6,16(sp)		#,
 3179 1c40 832BC100 		lw	s7,12(sp)		#,
 3180 1c44 032C8100 		lw	s8,8(sp)		#,
 3181 1c48 832C4100 		lw	s9,4(sp)		#,
 3182 1c4c 13010103 		addi	sp,sp,48	#,,
 3183 1c50 67800000 		jr	ra		#
 3185              		.align	2
 3186              		.globl	render_lines
 3188              	render_lines:
 3189 1c54 130101F8 		addi	sp,sp,-128	#,,
 3190              	# main_sphere3d_hdmi.c:20:   for (int i = 0; i < s - 1; i = i + 1) {
 3191 1c58 1386F5FF 		addi	a2,a1,-1	#, _50, s
 3192              	# main_sphere3d_hdmi.c:18: void render_lines(point points [], size_t s, float angle_x, float angle_
 3193 1c5c 232E1106 		sw	ra,124(sp)	#,
 3194 1c60 232C8106 		sw	s0,120(sp)	#,
 3195 1c64 232A9106 		sw	s1,116(sp)	#,
 3196 1c68 23282107 		sw	s2,112(sp)	#,
 3197 1c6c 23263107 		sw	s3,108(sp)	#,
 3198 1c70 23244107 		sw	s4,104(sp)	#,
 3199 1c74 23225107 		sw	s5,100(sp)	#,
 3200 1c78 23206107 		sw	s6,96(sp)	#,
 3201 1c7c 232E7105 		sw	s7,92(sp)	#,
 3202 1c80 232C8105 		sw	s8,88(sp)	#,
 3203 1c84 232A9105 		sw	s9,84(sp)	#,
 3204 1c88 2328A105 		sw	s10,80(sp)	#,
 3205 1c8c 2326B105 		sw	s11,76(sp)	#,
 3206              	# main_sphere3d_hdmi.c:20:   for (int i = 0; i < s - 1; i = i + 1) {
 3207 1c90 2326C100 		sw	a2,12(sp)	# _50, %sfp
 3208              	# main_sphere3d_hdmi.c:18: void render_lines(point points [], size_t s, float angle_x, float angle_
 3209 1c94 2324A100 		sw	a0,8(sp)	# tmp573, %sfp
 3210              	# main_sphere3d_hdmi.c:20:   for (int i = 0; i < s - 1; i = i + 1) {
 3211 1c98 63060666 		beq	a2,zero,.L412	#, _50,,
 3212 1c9c 13890700 		mv	s2,a5	# scalef, tmp577
 3213              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 3214 1ca0 B7070000 		lui	a5,%hi(.LC4)	# tmp286,
 3215 1ca4 138A0500 		mv	s4,a1	# s, tmp574
 3216 1ca8 83A50700 		lw	a1,%lo(.LC4)(a5)		#,
 3217 1cac 13050900 		mv	a0,s2	#, scalef
 3218 1cb0 13840600 		mv	s0,a3	# angle_y, tmp575
 3219 1cb4 93040700 		mv	s1,a4	# angle_z, tmp576
 3220 1cb8 97000000 		call	__mulsf3		#
 3220      E7800000 
 3221              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 3222 1cc0 B7070000 		lui	a5,%hi(.LC5)	# tmp288,
 3223              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 3224 1cc4 93050500 		mv	a1,a0	# tmp578,
 3225              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 3226 1cc8 03A50700 		lw	a0,%lo(.LC5)(a5)		#,
 3227              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 3228 1ccc B70C0000 		lui	s9,%hi(.LC1)	# tmp534,
 3229 1cd0 370C0000 		lui	s8,%hi(.LC2)	# tmp535,
 3230              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 3231 1cd4 97000000 		call	__subsf3		#
 3231      E7800000 
 3232              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 3233 1cdc 97000000 		call	__fixsfsi		#
 3233      E7800000 
 3234 1ce4 930D0500 		mv	s11,a0	# tmp579,
 3235              	# main_sphere3d_hdmi.c:33:     p0 = rotateY_pivot(&p0, &pivot, angle_y);
 3236 1ce8 13050400 		mv	a0,s0	#, angle_y
 3237 1cec 97000000 		call	__fixsfsi		#
 3237      E7800000 
 3238              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 3239 1cf4 97000000 		call	__floatsidf		#
 3239      E7800000 
 3240 1cfc 03A60C00 		lw	a2,%lo(.LC1)(s9)		#,
 3241 1d00 83A64C00 		lw	a3,%lo(.LC1+4)(s9)		#,
 3242              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 3243 1d04 3784FFFF 		li	s0,-32768		# tmp298,
 3244              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 3245 1d08 97000000 		call	__muldf3		#
 3245      E7800000 
 3246 1d10 03260C00 		lw	a2,%lo(.LC2)(s8)		#,
 3247 1d14 83264C00 		lw	a3,%lo(.LC2+4)(s8)		#,
 3248 1d18 97000000 		call	__divdf3		#
 3248      E7800000 
 3249 1d20 97000000 		call	__fixdfsi		#
 3249      E7800000 
 3250 1d28 13150501 		slli	a0,a0,16	#, _101, tmp580
 3251 1d2c 13550541 		srai	a0,a0,16	#, _101, _101
 3252 1d30 33048500 		add	s0,a0,s0	# tmp298, _101, _101
 3253 1d34 63440500 		blt	a0,zero,.L415	#, _101,,
 3254 1d38 13040500 		mv	s0,a0	# _101, _101
 3255              	.L415:
 3256 1d3c 931A0401 		slli	s5,s0,16	#, angle, _101
 3257 1d40 93DA0A41 		srai	s5,s5,16	#, angle, angle
 3258              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 3259 1d44 93D78A40 		srai	a5,s5,8	#, v0, angle
 3260              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3261 1d48 13970701 		slli	a4,a5,16	#, v0.41_136, v0
 3262              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3263 1d4c 1344F4FF 		not	s0,s0	# tmp307, _101
 3264              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3265 1d50 13570701 		srli	a4,a4,16	#, v0.41_136, v0.41_136
 3266              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3267 1d54 13140401 		slli	s0,s0,16	#, v1, tmp307
 3268 1d58 93FB0702 		andi	s7,a5,32	#, _137, v0
 3269              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3270 1d5c 2328E100 		sw	a4,16(sp)	# v0.41_136, %sfp
 3271              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3272 1d60 13540441 		srai	s0,s0,16	#, v1, v1
 3273 1d64 93C9F7FF 		not	s3,a5	# v0, v0
 3274 1d68 63880B62 		beq	s7,zero,.L462	#, _137,,
 3275              	.L417:
 3276              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3277 1d6c 93970A01 		slli	a5,s5,16	#, angle.46_110, angle
 3278 1d70 B7A6FFFF 		li	a3,-24576		# tmp312,
 3279 1d74 93D70701 		srli	a5,a5,16	#, angle.46_110, angle.46_110
 3280 1d78 93861600 		addi	a3,a3,1	#, tmp311, tmp312
 3281 1d7c B386D700 		add	a3,a5,a3	# tmp311, tmp310, angle.46_110
 3282              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3283 1d80 93960601 		slli	a3,a3,16	#, _112, tmp310
 3284 1d84 37270000 		li	a4,8192		# tmp315,
 3285 1d88 13071700 		addi	a4,a4,1	#, tmp314, tmp315
 3286 1d8c 93D60641 		srai	a3,a3,16	#, _112, _112
 3287              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3288 1d90 93F9F901 		andi	s3,s3,31	#, _142, v0
 3289 1d94 B387E700 		add	a5,a5,a4	# tmp314, _112, angle.46_110
 3290 1d98 63C40600 		blt	a3,zero,.L419	#, _112,,
 3291 1d9c 93870600 		mv	a5,a3	# _112, _112
 3292              	.L419:
 3293 1da0 139D0701 		slli	s10,a5,16	#, angle, _112
 3294 1da4 135D0D41 		srai	s10,s10,16	#, angle, angle
 3295              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 3296 1da8 13578D40 		srai	a4,s10,8	#, v0, angle
 3297              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3298 1dac 93C7F7FF 		not	a5,a5	# tmp322, _112
 3299              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3300 1db0 93160701 		slli	a3,a4,16	#, v0.41_167, v0
 3301              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3302 1db4 93970701 		slli	a5,a5,16	#, v1, tmp322
 3303 1db8 93D70741 		srai	a5,a5,16	#, v1, v1
 3304              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3305 1dbc 93D60601 		srli	a3,a3,16	#, v0.41_167, v0.41_167
 3306              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3307 1dc0 232CF100 		sw	a5,24(sp)	# v1, %sfp
 3308 1dc4 137B0702 		andi	s6,a4,32	#, _168, v0
 3309              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3310 1dc8 232AD100 		sw	a3,20(sp)	# v0.41_167, %sfp
 3311 1dcc 9347F7FF 		not	a5,a4	# v0, v0
 3312 1dd0 63000B5C 		beq	s6,zero,.L463	#, _168,,
 3313              	.L421:
 3314              	# main_sphere3d_hdmi.c:35:     p0 = rotateZ_pivot(&p0, &pivot, angle_z);
 3315 1dd4 13850400 		mv	a0,s1	#, angle_z
 3316              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3317 1dd8 93F4F701 		andi	s1,a5,31	#, _173, v0
 3318              	# main_sphere3d_hdmi.c:35:     p0 = rotateZ_pivot(&p0, &pivot, angle_z);
 3319 1ddc 97000000 		call	__fixsfsi		#
 3319      E7800000 
 3320              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 3321 1de4 97000000 		call	__floatsidf		#
 3321      E7800000 
 3322 1dec 03A60C00 		lw	a2,%lo(.LC1)(s9)		#,
 3323 1df0 83A64C00 		lw	a3,%lo(.LC1+4)(s9)		#,
 3324 1df4 97000000 		call	__muldf3		#
 3324      E7800000 
 3325 1dfc 03260C00 		lw	a2,%lo(.LC2)(s8)		#,
 3326 1e00 83264C00 		lw	a3,%lo(.LC2+4)(s8)		#,
 3327 1e04 97000000 		call	__divdf3		#
 3327      E7800000 
 3328 1e0c 97000000 		call	__fixdfsi		#
 3328      E7800000 
 3329 1e14 13150501 		slli	a0,a0,16	#, _61, tmp581
 3330 1e18 13550541 		srai	a0,a0,16	#, _61, _61
 3331              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 3332 1e1c 3787FFFF 		li	a4,-32768		# tmp333,
 3333 1e20 3307E500 		add	a4,a0,a4	# tmp333, _61, _61
 3334 1e24 63440500 		blt	a0,zero,.L423	#, _61,,
 3335 1e28 13070500 		mv	a4,a0	# _61, _61
 3336              	.L423:
 3337 1e2c 93150701 		slli	a1,a4,16	#, angle, _61
 3338 1e30 93D50541 		srai	a1,a1,16	#, angle, angle
 3339              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 3340 1e34 93D78540 		srai	a5,a1,8	#, v0, angle
 3341              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3342 1e38 1347F7FF 		not	a4,a4	# tmp342, _61
 3343              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3344 1e3c 939C0701 		slli	s9,a5,16	#, v0.41_198, v0
 3345              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3346 1e40 13170701 		slli	a4,a4,16	#, v1, tmp342
 3347 1e44 13F80702 		andi	a6,a5,32	#, _199, v0
 3348              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3349 1e48 93DC0C01 		srli	s9,s9,16	#, v0.41_198, v0.41_198
 3350              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3351 1e4c 13570741 		srai	a4,a4,16	#, v1, v1
 3352 1e50 13CEF7FF 		not	t3,a5	# v0, v0
 3353 1e54 630A0852 		beq	a6,zero,.L464	#, _199,,
 3354              	.L425:
 3355              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3356 1e58 93970501 		slli	a5,a1,16	#, angle.46_70, angle
 3357 1e5c B7A6FFFF 		li	a3,-24576		# tmp347,
 3358 1e60 93D70701 		srli	a5,a5,16	#, angle.46_70, angle.46_70
 3359 1e64 93861600 		addi	a3,a3,1	#, tmp346, tmp347
 3360 1e68 B386D700 		add	a3,a5,a3	# tmp346, tmp345, angle.46_70
 3361              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 3362 1e6c 93960601 		slli	a3,a3,16	#, _72, tmp345
 3363 1e70 37260000 		li	a2,8192		# tmp350,
 3364 1e74 13061600 		addi	a2,a2,1	#, tmp349, tmp350
 3365 1e78 93D60641 		srai	a3,a3,16	#, _72, _72
 3366              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3367 1e7c 137EFE01 		andi	t3,t3,31	#, _204, v0
 3368 1e80 B387C700 		add	a5,a5,a2	# tmp349, _72, angle.46_70
 3369 1e84 63C40600 		blt	a3,zero,.L427	#, _72,,
 3370 1e88 93870600 		mv	a5,a3	# _72, _72
 3371              	.L427:
 3372 1e8c 93980701 		slli	a7,a5,16	#, angle, _72
 3373 1e90 93D80841 		srai	a7,a7,16	#, angle, angle
 3374              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 3375 1e94 93D68840 		srai	a3,a7,8	#, v0, angle
 3376              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3377 1e98 13960601 		slli	a2,a3,16	#, v0.41_229, v0
 3378 1e9c 13560601 		srli	a2,a2,16	#, v0.41_229, v0.41_229
 3379              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3380 1ea0 93C7F7FF 		not	a5,a5	# tmp357, _72
 3381              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3382 1ea4 232EC100 		sw	a2,28(sp)	# v0.41_229, %sfp
 3383              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 3384 1ea8 139C0701 		slli	s8,a5,16	#, v1, tmp357
 3385 1eac 13F30602 		andi	t1,a3,32	#, _230, v0
 3386 1eb0 135C0C41 		srai	s8,s8,16	#, v1, v1
 3387 1eb4 13C6F6FF 		not	a2,a3	# v0, v0
 3388 1eb8 6304034C 		beq	t1,zero,.L465	#, _230,,
 3389              	.L429:
 3390              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3391 1ebc 1376F601 		andi	a2,a2,31	#, _235, v0
 3392              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3393 1ec0 13850D00 		mv	a0,s11	#, _5
 3394 1ec4 232E6102 		sw	t1,60(sp)	# _230, %sfp
 3395 1ec8 232C1103 		sw	a7,56(sp)	# angle, %sfp
 3396 1ecc 232AC103 		sw	t3,52(sp)	# _204, %sfp
 3397 1ed0 2328E102 		sw	a4,48(sp)	# v1, %sfp
 3398 1ed4 23260103 		sw	a6,44(sp)	# _199, %sfp
 3399 1ed8 2324B102 		sw	a1,40(sp)	# angle, %sfp
 3400              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3401 1edc 2322C102 		sw	a2,36(sp)	# _235, %sfp
 3402              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3403 1ee0 97000000 		call	__floatsisf		#
 3403      E7800000 
 3404              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3405 1ee8 93861900 		addi	a3,s3,1	#, tmp367, _142
 3406              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3407 1eec B7070000 		lui	a5,%hi(.LANCHOR1)	# tmp538,
 3408 1ef0 93870700 		addi	a5,a5,%lo(.LANCHOR1)	# tmp539, tmp538,
 3409 1ef4 93991900 		slli	s3,s3,1	#, tmp363, _142
 3410              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3411 1ef8 93961600 		slli	a3,a3,1	#, tmp368, tmp367
 3412              	# main_sphere3d_hdmi.c:39:   col++;
 3413 1efc 37070000 		lui	a4,%hi(col.0)	# tmp630,
 3414 1f00 03570700 		lhu	a4,%lo(col.0)(a4)	# pretmp_314, col
 3415              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3416 1f04 B3893701 		add	s3,a5,s3	# tmp363, tmp364, tmp539
 3417              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3418 1f08 B386D700 		add	a3,a5,a3	# tmp368, tmp369, tmp539
 3419              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3420 1f0c 039F0900 		lh	t5,0(s3)		# pretmp_316, sin90[_142]
 3421              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3422 1f10 83960600 		lh	a3,0(a3)		# sin90[_145], sin90[_145]
 3423              	# main_sphere3d_hdmi.c:39:   col++;
 3424 1f14 2320E102 		sw	a4,32(sp)	# pretmp_314, %sfp
 3425              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3426 1f18 2322A100 		sw	a0,4(sp)	# tmp582, %sfp
 3427              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3428 1f1c 03264102 		lw	a2,36(sp)		# _235, %sfp
 3429 1f20 83258102 		lw	a1,40(sp)		# angle, %sfp
 3430 1f24 0328C102 		lw	a6,44(sp)		# _199, %sfp
 3431 1f28 03270103 		lw	a4,48(sp)		# v1, %sfp
 3432 1f2c 032E4103 		lw	t3,52(sp)		# _204, %sfp
 3433 1f30 83288103 		lw	a7,56(sp)		# angle, %sfp
 3434 1f34 0323C103 		lw	t1,60(sp)		# _230, %sfp
 3435              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3436 1f38 B386E641 		sub	a3,a3,t5	# tmp371, sin90[_145], pretmp_316
 3437              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3438 1f3c 638E0B42 		beq	s7,zero,.L466	#, _137,,
 3439              	.L431:
 3440 1f40 1374F40F 		andi	s0,s0,0xff	# tmp374, v1
 3441              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3442 1f44 B3868602 		mul	a3,a3,s0	# tmp375, tmp371, tmp374
 3443              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3444 1f48 13851400 		addi	a0,s1,1	#, tmp386, _173
 3445 1f4c 13151500 		slli	a0,a0,1	#, tmp387, tmp386
 3446              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3447 1f50 93941400 		slli	s1,s1,1	#, tmp382, _173
 3448              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3449 1f54 3385A700 		add	a0,a5,a0	# tmp387, tmp388, tmp539
 3450              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3451 1f58 B3849700 		add	s1,a5,s1	# tmp382, tmp383, tmp539
 3452              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3453 1f5c 831A0500 		lh	s5,0(a0)		# sin90[_176], sin90[_176]
 3454              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3455 1f60 839E0400 		lh	t4,0(s1)		# pretmp_328, sin90[_173]
 3456              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3457 1f64 03558101 		lhu	a0,24(sp)	#, %sfp
 3458              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3459 1f68 93D68640 		srai	a3,a3,8	#, tmp376, tmp375
 3460              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3461 1f6c B386E601 		add	a3,a3,t5	# pretmp_316, tmp379, tmp376
 3462 1f70 93960601 		slli	a3,a3,16	#, _327, tmp379
 3463 1f74 93D60601 		srli	a3,a3,16	#, _327, _327
 3464              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3465 1f78 B38ADA41 		sub	s5,s5,t4	# tmp390, sin90[_176], pretmp_328
 3466              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3467 1f7c 630A0B3E 		beq	s6,zero,.L467	#, _168,,
 3468              	.L433:
 3469 1f80 1375F50F 		andi	a0,a0,0xff	# tmp393, v1
 3470              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3471 1f84 B38AAA02 		mul	s5,s5,a0	# tmp394, tmp390, tmp393
 3472              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3473 1f88 130F1E00 		addi	t5,t3,1	#, tmp405, _204
 3474 1f8c 131F1F00 		slli	t5,t5,1	#, tmp406, tmp405
 3475              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3476 1f90 131E1E00 		slli	t3,t3,1	#, tmp401, _204
 3477 1f94 338EC701 		add	t3,a5,t3	# tmp401, tmp402, tmp539
 3478              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3479 1f98 338FE701 		add	t5,a5,t5	# tmp406, tmp407, tmp539
 3480              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3481 1f9c 03150E00 		lh	a0,0(t3)		# pretmp_340, sin90[_204]
 3482              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3483 1fa0 83190F00 		lh	s3,0(t5)		# sin90[_207], sin90[_207]
 3484              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3485 1fa4 93DA8A40 		srai	s5,s5,8	#, tmp395, tmp394
 3486              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3487 1fa8 B38ADA01 		add	s5,s5,t4	# pretmp_328, tmp398, tmp395
 3488 1fac 939A0A01 		slli	s5,s5,16	#, _339, tmp398
 3489 1fb0 93DA0A01 		srli	s5,s5,16	#, _339, _339
 3490              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3491 1fb4 B389A940 		sub	s3,s3,a0	# tmp409, sin90[_207], pretmp_340
 3492              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3493 1fb8 6308083A 		beq	a6,zero,.L468	#, _199,,
 3494              	.L435:
 3495 1fbc 1377F70F 		andi	a4,a4,0xff	# tmp412, v1
 3496              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3497 1fc0 B389E902 		mul	s3,s3,a4	# tmp413, tmp409, tmp412
 3498              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3499 1fc4 13071600 		addi	a4,a2,1	#, tmp424, _235
 3500 1fc8 13171700 		slli	a4,a4,1	#, tmp425, tmp424
 3501              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3502 1fcc 13161600 		slli	a2,a2,1	#, tmp420, _235
 3503 1fd0 3386C700 		add	a2,a5,a2	# tmp420, tmp421, tmp539
 3504              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3505 1fd4 B387E700 		add	a5,a5,a4	# tmp425, tmp426, tmp539
 3506 1fd8 83940700 		lh	s1,0(a5)		# sin90[_238], sin90[_238]
 3507              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3508 1fdc 03170600 		lh	a4,0(a2)		# pretmp_352, sin90[_235]
 3509              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3510 1fe0 93D98940 		srai	s3,s3,8	#, tmp414, tmp413
 3511              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3512 1fe4 B389A900 		add	s3,s3,a0	# pretmp_340, tmp417, tmp414
 3513 1fe8 93990901 		slli	s3,s3,16	#, _351, tmp417
 3514 1fec 93D90901 		srli	s3,s3,16	#, _351, _351
 3515              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3516 1ff0 B384E440 		sub	s1,s1,a4	# tmp428, sin90[_238], pretmp_352
 3517              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3518 1ff4 63060336 		beq	t1,zero,.L469	#, _230,,
 3519              	.L437:
 3520 1ff8 137CFC0F 		andi	s8,s8,0xff	# tmp431, v1
 3521              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3522 1ffc B3848403 		mul	s1,s1,s8	# tmp432, tmp428, tmp431
 3523 2000 03248100 		lw	s0,8(sp)		# ivtmp.452, %sfp
 3524              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 3525 2004 03260101 		lw	a2,16(sp)		# v0.41_136, %sfp
 3526 2008 93171A00 		slli	a5,s4,1	#, tmp439, s
 3527 200c B3874701 		add	a5,a5,s4	# s, tmp440, tmp439
 3528 2010 130B44FF 		addi	s6,s0,-12	#, tmp437, ivtmp.452
 3529 2014 93972700 		slli	a5,a5,2	#, tmp441, tmp440
 3530 2018 13760604 		andi	a2,a2,64	#, tmp445, v0.41_136
 3531 201c 330BFB00 		add	s6,s6,a5	# tmp441, _35, tmp437
 3532 2020 13850600 		mv	a0,a3	# v1, _327
 3533              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3534 2024 93D48440 		srai	s1,s1,8	#, tmp433, tmp432
 3535              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3536 2028 B384E400 		add	s1,s1,a4	# pretmp_352, tmp436, tmp433
 3537 202c 93940401 		slli	s1,s1,16	#, _363, tmp436
 3538 2030 93D40401 		srli	s1,s1,16	#, _363, _363
 3539              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 3540 2034 63120632 		bne	a2,zero,.L470	#, tmp445,,
 3541              	.L439:
 3542 2038 13150501 		slli	a0,a0,16	#,, v1
 3543 203c 13550541 		srai	a0,a0,16	#,,
 3544 2040 97000000 		call	__floatsidf		#
 3544      E7800000 
 3545 2048 370A0000 		lui	s4,%hi(.LC3)	# tmp536,
 3546 204c 03260A00 		lw	a2,%lo(.LC3)(s4)		#,
 3547 2050 83264A00 		lw	a3,%lo(.LC3+4)(s4)		#,
 3548 2054 97000000 		call	__muldf3		#
 3548      E7800000 
 3549              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 3550 205c 97000000 		call	__truncdfsf2		#
 3550      E7800000 
 3551              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 3552 2064 83274101 		lw	a5,20(sp)		# v0.41_167, %sfp
 3553              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 3554 2068 930B0500 		mv	s7,a0	# sin_theta, tmp583
 3555              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 3556 206c 13850A00 		mv	a0,s5	# v1, _339
 3557 2070 93F70704 		andi	a5,a5,64	#, tmp456, v0.41_167
 3558 2074 639E072C 		bne	a5,zero,.L471	#, tmp456,,
 3559              	.L441:
 3560 2078 13150501 		slli	a0,a0,16	#,, v1
 3561 207c 13550541 		srai	a0,a0,16	#,,
 3562 2080 97000000 		call	__floatsidf		#
 3562      E7800000 
 3563 2088 03260A00 		lw	a2,%lo(.LC3)(s4)		#,
 3564 208c 83264A00 		lw	a3,%lo(.LC3+4)(s4)		#,
 3565              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 3566 2090 93FC0C04 		andi	s9,s9,64	#, tmp467, v0.41_198
 3567              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 3568 2094 97000000 		call	__muldf3		#
 3568      E7800000 
 3569              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 3570 209c 97000000 		call	__truncdfsf2		#
 3570      E7800000 
 3571 20a4 130C0500 		mv	s8,a0	# cos_theta, tmp584
 3572              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 3573 20a8 13850900 		mv	a0,s3	# v1, _351
 3574 20ac 639E0C28 		bne	s9,zero,.L472	#, tmp467,,
 3575              	.L443:
 3576 20b0 13150501 		slli	a0,a0,16	#,, v1
 3577 20b4 13550541 		srai	a0,a0,16	#,,
 3578 20b8 97000000 		call	__floatsidf		#
 3578      E7800000 
 3579 20c0 03260A00 		lw	a2,%lo(.LC3)(s4)		#,
 3580 20c4 83264A00 		lw	a3,%lo(.LC3+4)(s4)		#,
 3581 20c8 97000000 		call	__muldf3		#
 3581      E7800000 
 3582              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 3583 20d0 97000000 		call	__truncdfsf2		#
 3583      E7800000 
 3584              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 3585 20d8 8327C101 		lw	a5,28(sp)		# v0.41_229, %sfp
 3586              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 3587 20dc 93090500 		mv	s3,a0	# sin_theta, tmp585
 3588              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 3589 20e0 13850400 		mv	a0,s1	# v1, _363
 3590 20e4 93F70704 		andi	a5,a5,64	#, tmp478, v0.41_229
 3591 20e8 639C0724 		bne	a5,zero,.L473	#, tmp478,,
 3592              	.L445:
 3593 20ec 13150501 		slli	a0,a0,16	#,, v1
 3594 20f0 13550541 		srai	a0,a0,16	#,,
 3595 20f4 97000000 		call	__floatsidf		#
 3595      E7800000 
 3596 20fc 03260A00 		lw	a2,%lo(.LC3)(s4)		#,
 3597 2100 83264A00 		lw	a3,%lo(.LC3+4)(s4)		#,
 3598              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3599 2104 370D0000 		lui	s10,%hi(framebuffer)	# tmp570,
 3600              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 3601 2108 97000000 		call	__muldf3		#
 3601      E7800000 
 3602              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 3603 2110 97000000 		call	__truncdfsf2		#
 3603      E7800000 
 3604 2118 B7070000 		lui	a5,%hi(.LC6)	# tmp537,
 3605              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 3606 211c 03AA0700 		lw	s4,%lo(.LC6)(a5)		# tmp567,
 3607              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3608 2120 93070D00 		addi	a5,s10,%lo(framebuffer)	# tmp571, tmp570,
 3609              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 3610 2124 930A0500 		mv	s5,a0	# cos_theta, tmp586
 3611              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3612 2128 2324F100 		sw	a5,8(sp)	# tmp571, %sfp
 3613              	.L447:
 3614              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 3615 212c 03250400 		lw	a0,0(s0)		#, MEM[(int *)_47]
 3616 2130 97000000 		call	__floatsisf		#
 3616      E7800000 
 3617 2138 93050900 		mv	a1,s2	#, scalef
 3618 213c 97000000 		call	__mulsf3		#
 3618      E7800000 
 3619              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 3620 2144 97000000 		call	__fixsfsi		#
 3620      E7800000 
 3621              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 3622 214c 130525FE 		addi	a0,a0,-30	#,, tmp587
 3623 2150 97000000 		call	__floatsisf		#
 3623      E7800000 
 3624 2158 93050C00 		mv	a1,s8	#, cos_theta
 3625 215c 97000000 		call	__mulsf3		#
 3625      E7800000 
 3626 2164 930C0500 		mv	s9,a0	# tmp588,
 3627              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 3628 2168 03258400 		lw	a0,8(s0)		#, MEM[(int *)_47 + 8B]
 3629 216c 97000000 		call	__floatsisf		#
 3629      E7800000 
 3630 2174 93050900 		mv	a1,s2	#, scalef
 3631 2178 97000000 		call	__mulsf3		#
 3631      E7800000 
 3632              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 3633 2180 97000000 		call	__fixsfsi		#
 3633      E7800000 
 3634              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 3635 2188 97000000 		call	__floatsisf		#
 3635      E7800000 
 3636 2190 93850B00 		mv	a1,s7	#, sin_theta
 3637 2194 97000000 		call	__mulsf3		#
 3637      E7800000 
 3638 219c 93050500 		mv	a1,a0	# tmp589,
 3639              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 3640 21a0 13850C00 		mv	a0,s9	#, tmp491
 3641 21a4 97000000 		call	__addsf3		#
 3641      E7800000 
 3642              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 3643 21ac 93050A00 		mv	a1,s4	#, tmp567
 3644 21b0 97000000 		call	__addsf3		#
 3644      E7800000 
 3645              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 3646 21b8 97000000 		call	__fixsfsi		#
 3646      E7800000 
 3647              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3648 21c0 130585FD 		addi	a0,a0,-40	#,, tmp590
 3649 21c4 97000000 		call	__floatsisf		#
 3649      E7800000 
 3650 21cc 930C0500 		mv	s9,a0	# tmp591,
 3651              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 3652 21d0 03254400 		lw	a0,4(s0)		#, MEM[(int *)_47 + 4B]
 3653 21d4 97000000 		call	__floatsisf		#
 3653      E7800000 
 3654 21dc 93050900 		mv	a1,s2	#, scalef
 3655 21e0 97000000 		call	__mulsf3		#
 3655      E7800000 
 3656              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 3657 21e8 97000000 		call	__fixsfsi		#
 3657      E7800000 
 3658              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 3659 21f0 1305E501 		addi	a0,a0,30	#, tmp505, tmp592
 3660              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3661 21f4 3305B541 		sub	a0,a0,s11	#, tmp505, _5
 3662 21f8 97000000 		call	__floatsisf		#
 3662      E7800000 
 3663 2200 130D0500 		mv	s10,a0	# tmp593,
 3664              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3665 2204 93850A00 		mv	a1,s5	#, cos_theta
 3666 2208 13850C00 		mv	a0,s9	#, _306
 3667 220c 97000000 		call	__mulsf3		#
 3667      E7800000 
 3668 2214 93040500 		mv	s1,a0	# tmp507, tmp594
 3669              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3670 2218 93050D00 		mv	a1,s10	#, _304
 3671 221c 13850900 		mv	a0,s3	#, sin_theta
 3672 2220 97000000 		call	__mulsf3		#
 3672      E7800000 
 3673 2228 93050500 		mv	a1,a0	# tmp595,
 3674              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3675 222c 13850400 		mv	a0,s1	#, tmp507
 3676 2230 97000000 		call	__subsf3		#
 3676      E7800000 
 3677              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3678 2238 93050A00 		mv	a1,s4	#, tmp567
 3679 223c 97000000 		call	__addsf3		#
 3679      E7800000 
 3680              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3681 2244 97000000 		call	__fixsfsi		#
 3681      E7800000 
 3682 224c 93070500 		mv	a5,a0	# tmp596,
 3683              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3684 2250 93850C00 		mv	a1,s9	#, _306
 3685              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 3686 2254 938C0700 		mv	s9,a5	# _300, tmp596
 3687              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3688 2258 9307F004 		li	a5,79		# tmp636,
 3689              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3690 225c 13850900 		mv	a0,s3	#, sin_theta
 3691              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 3692 2260 63E89707 		bgtu	s9,a5,.L449	#, _300, tmp636,
 3693              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3694 2264 97000000 		call	__mulsf3		#
 3694      E7800000 
 3695 226c 93040500 		mv	s1,a0	# tmp523, tmp597
 3696              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3697 2270 93850A00 		mv	a1,s5	#, cos_theta
 3698 2274 13050D00 		mv	a0,s10	#, _304
 3699 2278 97000000 		call	__mulsf3		#
 3699      E7800000 
 3700 2280 93050500 		mv	a1,a0	# tmp598,
 3701              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3702 2284 13850400 		mv	a0,s1	#, tmp523
 3703 2288 97000000 		call	__addsf3		#
 3703      E7800000 
 3704              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3705 2290 83254100 		lw	a1,4(sp)		#, %sfp
 3706 2294 97000000 		call	__addsf3		#
 3706      E7800000 
 3707              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 3708 229c 97000000 		call	__fixsfsi		#
 3708      E7800000 
 3709              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3710 22a4 93172500 		slli	a5,a0,2	#, tmp514, _261
 3711 22a8 B387A700 		add	a5,a5,a0	# _261, tmp515, tmp514
 3712              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3713 22ac 03278100 		lw	a4,8(sp)		# tmp571, %sfp
 3714              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3715 22b0 93974700 		slli	a5,a5,4	#, tmp516, tmp515
 3716 22b4 B3879701 		add	a5,a5,s9	# _300, tmp517, tmp516
 3717              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3718 22b8 93972700 		slli	a5,a5,2	#, tmp518, tmp517
 3719 22bc B387E700 		add	a5,a5,a4	# tmp571, tmp519, tmp518
 3720              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 3721 22c0 1307B003 		li	a4,59		# tmp639,
 3722 22c4 6366A700 		bgtu	a0,a4,.L449	#, _261, tmp639,
 3723              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 3724 22c8 1307F0FF 		li	a4,-1		# tmp637,
 3725 22cc 23A0E700 		sw	a4,0(a5)	# tmp637, *_313
 3726              	.L449:
 3727              	# main_sphere3d_hdmi.c:20:   for (int i = 0; i < s - 1; i = i + 1) {
 3728 22d0 1304C400 		addi	s0,s0,12	#, ivtmp.452, ivtmp.452
 3729 22d4 E31C8BE4 		bne	s6,s0,.L447	#, _35, ivtmp.452,
 3730 22d8 03270102 		lw	a4,32(sp)		# pretmp_314, %sfp
 3731 22dc 0326C100 		lw	a2,12(sp)		# _50, %sfp
 3732              	# main_sphere3d_hdmi.c:20:   for (int i = 0; i < s - 1; i = i + 1) {
 3733 22e0 93070000 		li	a5,0		# i,
 3734 22e4 93061700 		addi	a3,a4,1	#, tmp540, pretmp_314
 3735              	.L451:
 3736 22e8 3387F600 		add	a4,a3,a5	# i, tmp531, tmp540
 3737 22ec 13170701 		slli	a4,a4,16	#, _256, tmp531
 3738              	# main_sphere3d_hdmi.c:20:   for (int i = 0; i < s - 1; i = i + 1) {
 3739 22f0 93871700 		addi	a5,a5,1	#, i, i
 3740 22f4 13570701 		srli	a4,a4,16	#, _256, _256
 3741              	# main_sphere3d_hdmi.c:20:   for (int i = 0; i < s - 1; i = i + 1) {
 3742 22f8 E398C7FE 		bne	a5,a2,.L451	#, i, _50,
 3743 22fc B7070000 		lui	a5,%hi(col.0)	# tmp641,
 3744 2300 2390E700 		sh	a4,%lo(col.0)(a5)	# _256, col
 3745              	.L412:
 3746              	# main_sphere3d_hdmi.c:41: }
 3747 2304 8320C107 		lw	ra,124(sp)		#,
 3748 2308 03248107 		lw	s0,120(sp)		#,
 3749 230c 83244107 		lw	s1,116(sp)		#,
 3750 2310 03290107 		lw	s2,112(sp)		#,
 3751 2314 8329C106 		lw	s3,108(sp)		#,
 3752 2318 032A8106 		lw	s4,104(sp)		#,
 3753 231c 832A4106 		lw	s5,100(sp)		#,
 3754 2320 032B0106 		lw	s6,96(sp)		#,
 3755 2324 832BC105 		lw	s7,92(sp)		#,
 3756 2328 032C8105 		lw	s8,88(sp)		#,
 3757 232c 832C4105 		lw	s9,84(sp)		#,
 3758 2330 032D0105 		lw	s10,80(sp)		#,
 3759 2334 832DC104 		lw	s11,76(sp)		#,
 3760 2338 13010108 		addi	sp,sp,128	#,,
 3761 233c 67800000 		jr	ra		#
 3762              	.L473:
 3763              	# gfx_lib_hdmi.h:297:   float cos_theta = COS_FAST(angle);
 3764 2340 33059040 		neg	a0,s1	# v1, _363
 3765 2344 6FF09FDA 		j	.L445		#
 3766              	.L472:
 3767              	# gfx_lib_hdmi.h:296:   float sin_theta = SIN_FAST(angle);
 3768 2348 33053041 		neg	a0,s3	# v1, _351
 3769 234c 6FF05FD6 		j	.L443		#
 3770              	.L471:
 3771              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 3772 2350 33055041 		neg	a0,s5	# v1, _339
 3773 2354 6FF05FD2 		j	.L441		#
 3774              	.L470:
 3775              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 3776 2358 3305D040 		neg	a0,a3	# v1, _327
 3777 235c 6FF0DFCD 		j	.L439		#
 3778              	.L469:
 3779              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 3780 2360 138C0800 		mv	s8,a7	# v1, angle
 3781 2364 6FF05FC9 		j	.L437		#
 3782              	.L468:
 3783 2368 13870500 		mv	a4,a1	# v1, angle
 3784 236c 6FF01FC5 		j	.L435		#
 3785              	.L467:
 3786 2370 13050D00 		mv	a0,s10	# v1, angle
 3787 2374 6FF0DFC0 		j	.L433		#
 3788              	.L466:
 3789 2378 13840A00 		mv	s0,s5	# v1, angle
 3790 237c 6FF05FBC 		j	.L431		#
 3791              	.L465:
 3792 2380 13860600 		mv	a2,a3	# v0, v0
 3793 2384 6FF09FB3 		j	.L429		#
 3794              	.L464:
 3795 2388 138E0700 		mv	t3,a5	# v0, v0
 3796 238c 6FF0DFAC 		j	.L425		#
 3797              	.L463:
 3798 2390 93070700 		mv	a5,a4	# v0, v0
 3799 2394 6FF01FA4 		j	.L421		#
 3800              	.L462:
 3801 2398 93890700 		mv	s3,a5	# v0, v0
 3802 239c 6FF01F9D 		j	.L417		#
 3804              		.section	.rodata.str1.4
 3805 0011 000000   		.align	2
 3806              	.LC9:
 3807 0014 796F0A00 		.string	"yo\n"
 3808              		.globl	__gesf2
 3809              		.globl	__lesf2
 3810              		.section	.text.startup,"ax",@progbits
 3811              		.align	2
 3812              		.globl	main
 3814              	main:
 3815 0000 130101F5 		addi	sp,sp,-176	#,,
 3816 0004 232EB107 		sw	s11,124(sp)	#,
 3817              	# gfx_lib_hdmi.h:231:   dma_action((uint32_t) framebuffer, rgb, VRES*HRES, DMA_MEMSET);
 3818 0008 B70D0000 		lui	s11,%hi(framebuffer)	# tmp494,
 3819 000c 13870D00 		addi	a4,s11,%lo(framebuffer)	# tmp500, tmp494,
 3820              	# main_sphere3d_hdmi.c:45: void main() {
 3821 0010 2324810A 		sw	s0,168(sp)	#,
 3822 0014 2322910A 		sw	s1,164(sp)	#,
 3823 0018 2320210B 		sw	s2,160(sp)	#,
 3824 001c 232E3109 		sw	s3,156(sp)	#,
 3825 0020 23286109 		sw	s6,144(sp)	#,
 3826 0024 23248109 		sw	s8,136(sp)	#,
 3827              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
 3828 0028 B7070030 		li	a5,805306368		# tmp251,
 3829              	# gfx_lib_hdmi.h:231:   dma_action((uint32_t) framebuffer, rgb, VRES*HRES, DMA_MEMSET);
 3830 002c 2324E100 		sw	a4,8(sp)	# tmp500, %sfp
 3831              	# main_sphere3d_hdmi.c:45: void main() {
 3832 0030 2326110A 		sw	ra,172(sp)	#,
 3833 0034 232C4109 		sw	s4,152(sp)	#,
 3834 0038 232A5109 		sw	s5,148(sp)	#,
 3835 003c 23267109 		sw	s7,140(sp)	#,
 3836 0040 23229109 		sw	s9,132(sp)	#,
 3837 0044 2320A109 		sw	s10,128(sp)	#,
 3838              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
 3839 0048 23A6E702 		sw	a4,44(a5)	# tmp500, MEM[(volatile uint32_t *)805306412B]
 3840              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 3841 004c 37170000 		li	a4,4096		# tmp257,
 3842              	# kianv_stdlib.h:52:   *( (volatile uint32_t*) DMA_DST  ) = dst;
 3843 0050 23A80702 		sw	zero,48(a5)	#, MEM[(volatile uint32_t *)805306416B]
 3844              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 3845 0054 1307072C 		addi	a4,a4,704	#, tmp256, tmp257
 3846 0058 23AAE702 		sw	a4,52(a5)	# tmp256, MEM[(volatile uint32_t *)805306420B]
 3847              	# main_sphere3d_hdmi.c:55:     printf("yo\n");
 3848 005c 37050000 		lui	a0,%hi(.LC9)	# tmp261,
 3849              	# kianv_stdlib.h:54:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
 3850 0060 13072000 		li	a4,2		# tmp260,
 3851 0064 23ACE702 		sw	a4,56(a5)	# tmp260, MEM[(volatile uint32_t *)805306424B]
 3852              	# main_sphere3d_hdmi.c:55:     printf("yo\n");
 3853 0068 13050500 		addi	a0,a0,%lo(.LC9)	#, tmp261,
 3854 006c 97000000 		call	printf		#
 3854      E7800000 
 3855              	# main_sphere3d_hdmi.c:66:       stars[index].x = sinf(u*M_PI/180.0)*cosf(t*M_PI/180.0) * 35;
 3856 0074 B7070000 		lui	a5,%hi(.LC10)	# tmp495,
 3857 0078 03A90700 		lw	s2,%lo(.LC10)(a5)		# tmp545,
 3858 007c 83A94700 		lw	s3,%lo(.LC10+4)(a5)		#,
 3859              	# main_sphere3d_hdmi.c:66:       stars[index].x = sinf(u*M_PI/180.0)*cosf(t*M_PI/180.0) * 35;
 3860 0080 B7070000 		lui	a5,%hi(.LC11)	# tmp496,
 3861 0084 03A40700 		lw	s0,%lo(.LC11)(a5)		# tmp546,
 3862 0088 83A44700 		lw	s1,%lo(.LC11+4)(a5)		#,
 3863              	# main_sphere3d_hdmi.c:66:       stars[index].x = sinf(u*M_PI/180.0)*cosf(t*M_PI/180.0) * 35;
 3864 008c B7070000 		lui	a5,%hi(.LC12)	# tmp497,
 3865 0090 03AB0700 		lw	s6,%lo(.LC12)(a5)		# tmp549,
 3866 0094 B7070000 		lui	a5,%hi(stars)	# tmp502,
 3867 0098 93870700 		addi	a5,a5,%lo(stars)	# ivtmp.473, tmp502,
 3868              	# main_sphere3d_hdmi.c:63:   int index = 0;
 3869 009c 130C0000 		li	s8,0		# index,
 3870 00a0 2324F104 		sw	a5,72(sp)	# ivtmp.473, %sfp
 3871              	# main_sphere3d_hdmi.c:45: void main() {
 3872 00a4 232E0100 		sw	zero,28(sp)	#, %sfp
 3873              	# main_sphere3d_hdmi.c:70:       if (index >= N) break;
 3874 00a8 930D7016 		li	s11,359		# tmp283,
 3875 00ac 93070C00 		mv	a5,s8	# index, index
 3876              	.L475:
 3877 00b0 03278104 		lw	a4,72(sp)		# ivtmp.473, %sfp
 3878 00b4 139A1700 		slli	s4,a5,1	#, tmp287, index
 3879 00b8 330AFA00 		add	s4,s4,a5	# index, tmp288, tmp287
 3880 00bc 131A2A00 		slli	s4,s4,2	#, tmp289, tmp288
 3881 00c0 330AEA00 		add	s4,s4,a4	# ivtmp.473, ivtmp.488, tmp289
 3882              	# main_sphere3d_hdmi.c:65:     for (int u = 0; u < 360/2; u += STEP) {
 3883 00c4 930C0000 		li	s9,0		# u,
 3884              	.L477:
 3885              	# main_sphere3d_hdmi.c:66:       stars[index].x = sinf(u*M_PI/180.0)*cosf(t*M_PI/180.0) * 35;
 3886 00c8 13850C00 		mv	a0,s9	#, u
 3887 00cc 2326F100 		sw	a5,12(sp)	# index, %sfp
 3888 00d0 97000000 		call	__floatsidf		#
 3888      E7800000 
 3889 00d8 13060900 		mv	a2,s2	#, tmp545
 3890 00dc 93860900 		mv	a3,s3	#,
 3891 00e0 97000000 		call	__muldf3		#
 3891      E7800000 
 3892              	# main_sphere3d_hdmi.c:66:       stars[index].x = sinf(u*M_PI/180.0)*cosf(t*M_PI/180.0) * 35;
 3893 00e8 13060400 		mv	a2,s0	#, tmp546
 3894 00ec 93860400 		mv	a3,s1	#,
 3895 00f0 97000000 		call	__divdf3		#
 3895      E7800000 
 3896              	# main_sphere3d_hdmi.c:66:       stars[index].x = sinf(u*M_PI/180.0)*cosf(t*M_PI/180.0) * 35;
 3897 00f8 97000000 		call	__truncdfsf2		#
 3897      E7800000 
 3898 0100 930A0500 		mv	s5,a0	# _4, tmp552
 3899 0104 97000000 		call	sinf		#
 3899      E7800000 
 3900 010c 130D0500 		mv	s10,a0	# tmp553,
 3901              	# main_sphere3d_hdmi.c:66:       stars[index].x = sinf(u*M_PI/180.0)*cosf(t*M_PI/180.0) * 35;
 3902 0110 13050C00 		mv	a0,s8	#, t
 3903 0114 97000000 		call	__floatsidf		#
 3903      E7800000 
 3904 011c 13060900 		mv	a2,s2	#, tmp545
 3905 0120 93860900 		mv	a3,s3	#,
 3906 0124 97000000 		call	__muldf3		#
 3906      E7800000 
 3907              	# main_sphere3d_hdmi.c:66:       stars[index].x = sinf(u*M_PI/180.0)*cosf(t*M_PI/180.0) * 35;
 3908 012c 13060400 		mv	a2,s0	#, tmp546
 3909 0130 93860400 		mv	a3,s1	#,
 3910 0134 97000000 		call	__divdf3		#
 3910      E7800000 
 3911              	# main_sphere3d_hdmi.c:66:       stars[index].x = sinf(u*M_PI/180.0)*cosf(t*M_PI/180.0) * 35;
 3912 013c 97000000 		call	__truncdfsf2		#
 3912      E7800000 
 3913 0144 930B0500 		mv	s7,a0	# tmp554,
 3914 0148 97000000 		call	cosf		#
 3914      E7800000 
 3915 0150 93050500 		mv	a1,a0	# tmp555,
 3916              	# main_sphere3d_hdmi.c:66:       stars[index].x = sinf(u*M_PI/180.0)*cosf(t*M_PI/180.0) * 35;
 3917 0154 13050D00 		mv	a0,s10	#, _5
 3918 0158 97000000 		call	__mulsf3		#
 3918      E7800000 
 3919              	# main_sphere3d_hdmi.c:66:       stars[index].x = sinf(u*M_PI/180.0)*cosf(t*M_PI/180.0) * 35;
 3920 0160 93050B00 		mv	a1,s6	#, tmp549
 3921 0164 97000000 		call	__mulsf3		#
 3921      E7800000 
 3922              	# main_sphere3d_hdmi.c:66:       stars[index].x = sinf(u*M_PI/180.0)*cosf(t*M_PI/180.0) * 35;
 3923 016c 97000000 		call	__fixsfsi		#
 3923      E7800000 
 3924 0174 13070500 		mv	a4,a0	# tmp556,
 3925 0178 2320EA00 		sw	a4,0(s4)	# tmp556, MEM[(int *)_150]
 3926              	# main_sphere3d_hdmi.c:67:       stars[index].y = sinf(u*M_PI/180.0)*sinf(t*M_PI/180.0) * 35;
 3927 017c 13850A00 		mv	a0,s5	#, _4
 3928 0180 97000000 		call	sinf		#
 3928      E7800000 
 3929 0188 130D0500 		mv	s10,a0	# _14, tmp557
 3930              	# main_sphere3d_hdmi.c:67:       stars[index].y = sinf(u*M_PI/180.0)*sinf(t*M_PI/180.0) * 35;
 3931 018c 13850B00 		mv	a0,s7	#, _9
 3932 0190 97000000 		call	sinf		#
 3932      E7800000 
 3933 0198 93050500 		mv	a1,a0	# tmp558,
 3934              	# main_sphere3d_hdmi.c:67:       stars[index].y = sinf(u*M_PI/180.0)*sinf(t*M_PI/180.0) * 35;
 3935 019c 13050D00 		mv	a0,s10	#, _14
 3936 01a0 97000000 		call	__mulsf3		#
 3936      E7800000 
 3937              	# main_sphere3d_hdmi.c:67:       stars[index].y = sinf(u*M_PI/180.0)*sinf(t*M_PI/180.0) * 35;
 3938 01a8 93050B00 		mv	a1,s6	#, tmp549
 3939 01ac 97000000 		call	__mulsf3		#
 3939      E7800000 
 3940              	# main_sphere3d_hdmi.c:67:       stars[index].y = sinf(u*M_PI/180.0)*sinf(t*M_PI/180.0) * 35;
 3941 01b4 97000000 		call	__fixsfsi		#
 3941      E7800000 
 3942 01bc 13070500 		mv	a4,a0	# tmp559,
 3943 01c0 2322EA00 		sw	a4,4(s4)	# tmp559, MEM[(int *)_150 + 4B]
 3944              	# main_sphere3d_hdmi.c:68:       stars[index].z = cosf(u*M_PI/180.0) * 35;
 3945 01c4 13850A00 		mv	a0,s5	#, _4
 3946 01c8 97000000 		call	cosf		#
 3946      E7800000 
 3947              	# main_sphere3d_hdmi.c:68:       stars[index].z = cosf(u*M_PI/180.0) * 35;
 3948 01d0 93050B00 		mv	a1,s6	#, tmp549
 3949 01d4 97000000 		call	__mulsf3		#
 3949      E7800000 
 3950              	# main_sphere3d_hdmi.c:68:       stars[index].z = cosf(u*M_PI/180.0) * 35;
 3951 01dc 97000000 		call	__fixsfsi		#
 3951      E7800000 
 3952              	# main_sphere3d_hdmi.c:69:       index++;
 3953 01e4 8327C100 		lw	a5,12(sp)		# index, %sfp
 3954              	# main_sphere3d_hdmi.c:68:       stars[index].z = cosf(u*M_PI/180.0) * 35;
 3955 01e8 2324AA00 		sw	a0,8(s4)	# tmp560, MEM[(int *)_150 + 8B]
 3956              	# main_sphere3d_hdmi.c:65:     for (int u = 0; u < 360/2; u += STEP) {
 3957 01ec 938C4C01 		addi	s9,s9,20	#, u, u
 3958              	# main_sphere3d_hdmi.c:69:       index++;
 3959 01f0 93871700 		addi	a5,a5,1	#, index, index
 3960              	# main_sphere3d_hdmi.c:65:     for (int u = 0; u < 360/2; u += STEP) {
 3961 01f4 1307400B 		li	a4,180		# tmp284,
 3962              	# main_sphere3d_hdmi.c:70:       if (index >= N) break;
 3963 01f8 63C6FD00 		bgt	a5,s11,.L476	#, index, tmp283,
 3964              	# main_sphere3d_hdmi.c:65:     for (int u = 0; u < 360/2; u += STEP) {
 3965 01fc 130ACA00 		addi	s4,s4,12	#, ivtmp.488, ivtmp.488
 3966 0200 E394ECEC 		bne	s9,a4,.L477	#, u, tmp284,
 3967              	.L476:
 3968              	# main_sphere3d_hdmi.c:64:   for (int t = 0; t < 360; t += STEP) {
 3969 0204 130C4C01 		addi	s8,s8,20	#, t, t
 3970              	# main_sphere3d_hdmi.c:64:   for (int t = 0; t < 360; t += STEP) {
 3971 0208 13078016 		li	a4,360		# tmp285,
 3972 020c E312ECEA 		bne	s8,a4,.L475	#, t, tmp285,
 3973              	# main_sphere3d_hdmi.c:74:   *fb_ctrl = 0;
 3974 0210 B7070000 		lui	a5,%hi(fb_ctrl)	# tmp292,
 3975 0214 03A70700 		lw	a4,%lo(fb_ctrl)(a5)		# fb_ctrl.58_22, fb_ctrl
 3976              	# main_sphere3d_hdmi.c:53:   float delta_scale = 0.06;//0.8; /* speedup scale */
 3977 0218 B7070000 		lui	a5,%hi(.LC7)	# tmp247,
 3978 021c 83A70700 		lw	a5,%lo(.LC7)(a5)		# delta_scale,
 3979              	# main_sphere3d_hdmi.c:74:   *fb_ctrl = 0;
 3980 0220 232CE100 		sw	a4,24(sp)	# fb_ctrl.58_22, %sfp
 3981              	# main_sphere3d_hdmi.c:74:   *fb_ctrl = 0;
 3982 0224 23200700 		sw	zero,0(a4)	#, *fb_ctrl.58_22
 3983              	# main_sphere3d_hdmi.c:53:   float delta_scale = 0.06;//0.8; /* speedup scale */
 3984 0228 232AF100 		sw	a5,20(sp)	# delta_scale, %sfp
 3985              	# main_sphere3d_hdmi.c:52:   float s = 1;
 3986 022c B7070000 		lui	a5,%hi(.LC8)	# tmp248,
 3987 0230 03A90700 		lw	s2,%lo(.LC8)(a5)		# s,
 3988              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 3989 0234 B7070000 		lui	a5,%hi(.LC4)	# tmp491,
 3990 0238 83A70700 		lw	a5,%lo(.LC4)(a5)		# tmp534,
 3991              	# main_sphere3d_hdmi.c:76:   IO_OUT(GPIO_DIR, ~0);
 3992 023c 1307F0FF 		li	a4,-1		# tmp295,
 3993 0240 B71C0000 		lui	s9,%hi(stars+4308)	# tmp507,
 3994              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 3995 0244 232CF104 		sw	a5,88(sp)	# tmp534, %sfp
 3996              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 3997 0248 B7070000 		lui	a5,%hi(.LC5)	# tmp492,
 3998 024c 83A70700 		lw	a5,%lo(.LC5)(a5)		# tmp535,
 3999 0250 938C4C0D 		addi	s9,s9,%lo(stars+4308)	# _159, tmp507,
 4000              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
 4001 0254 B70B0030 		li	s7,805306368		# tmp444,
 4002              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 4003 0258 232EF104 		sw	a5,92(sp)	# tmp535, %sfp
 4004              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 4005 025c B7070000 		lui	a5,%hi(.LC1)	# tmp488,
 4006 0260 03A84700 		lw	a6,%lo(.LC1+4)(a5)		#,
 4007 0264 83A70700 		lw	a5,%lo(.LC1)(a5)		# tmp536,
 4008 0268 23220107 		sw	a6,100(sp)	#, %sfp
 4009 026c 2320F106 		sw	a5,96(sp)	# tmp536, %sfp
 4010 0270 B7070000 		lui	a5,%hi(.LC2)	# tmp489,
 4011 0274 03A84700 		lw	a6,%lo(.LC2+4)(a5)		#,
 4012 0278 83A70700 		lw	a5,%lo(.LC2)(a5)		# tmp537,
 4013 027c 23260107 		sw	a6,108(sp)	#, %sfp
 4014 0280 2324F106 		sw	a5,104(sp)	# tmp537, %sfp
 4015 0284 B7070000 		lui	a5,%hi(.LC3)	# tmp490,
 4016 0288 03A84700 		lw	a6,%lo(.LC3+4)(a5)		#,
 4017 028c 83A70700 		lw	a5,%lo(.LC3)(a5)		# tmp538,
 4018 0290 23260103 		sw	a6,44(sp)	#, %sfp
 4019 0294 2324F102 		sw	a5,40(sp)	# tmp538, %sfp
 4020              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 4021 0298 B7070000 		lui	a5,%hi(.LC6)	# tmp493,
 4022 029c 83AA0700 		lw	s5,%lo(.LC6)(a5)		# tmp530,
 4023              	# main_sphere3d_hdmi.c:87:     if (s >= 2) delta_scale = -delta_scale;
 4024 02a0 B7070000 		lui	a5,%hi(.LC13)	# tmp498,
 4025 02a4 83A70700 		lw	a5,%lo(.LC13)(a5)		# tmp456,
 4026 02a8 232AF104 		sw	a5,84(sp)	# tmp456, %sfp
 4027              	# main_sphere3d_hdmi.c:76:   IO_OUT(GPIO_DIR, ~0);
 4028 02ac B7070030 		li	a5,805306368		# tmp294,
 4029 02b0 23AAE700 		sw	a4,20(a5)	# tmp295, MEM[(volatile uint32_t *)805306388B]
 4030              	# main_sphere3d_hdmi.c:50:   int delta_angle = 2; /* speedup rotation, - for left rotation */
 4031 02b4 93072000 		li	a5,2		# delta_angle,
 4032 02b8 2328F100 		sw	a5,16(sp)	# delta_angle, %sfp
 4033 02bc B7070000 		lui	a5,%hi(.LANCHOR1)	# tmp499,
 4034 02c0 93870700 		addi	a5,a5,%lo(.LANCHOR1)	# tmp503, tmp499,
 4035 02c4 2322F102 		sw	a5,36(sp)	# tmp503, %sfp
 4036              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 4037 02c8 B7A7FFFF 		li	a5,-24576		# tmp323,
 4038 02cc 93871700 		addi	a5,a5,1	#, tmp322, tmp323
 4039 02d0 2326F104 		sw	a5,76(sp)	# tmp322, %sfp
 4040              	# gfx_lib_hdmi.h:87:   if(angle < 0) { angle += INT16_MAX; angle += 1; }
 4041 02d4 B7270000 		li	a5,8192		# tmp326,
 4042 02d8 93871700 		addi	a5,a5,1	#, tmp325, tmp326
 4043 02dc 2328F104 		sw	a5,80(sp)	# tmp325, %sfp
 4044              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 4045 02e0 B7170000 		li	a5,4096		# tmp450,
 4046 02e4 9387072C 		addi	a5,a5,704	#, tmp449, tmp450
 4047              	# main_sphere3d_hdmi.c:49:   int angle = 0;
 4048 02e8 23260100 		sw	zero,12(sp)	#, %sfp
 4049              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 4050 02ec 2320F102 		sw	a5,32(sp)	# tmp449, %sfp
 4051              	.L505:
 4052              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 4053 02f0 83258105 		lw	a1,88(sp)		#, %sfp
 4054 02f4 13050900 		mv	a0,s2	#, s
 4055 02f8 97000000 		call	__mulsf3		#
 4055      E7800000 
 4056 0300 93050500 		mv	a1,a0	# tmp561,
 4057              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 4058 0304 0325C105 		lw	a0,92(sp)		#, %sfp
 4059 0308 97000000 		call	__subsf3		#
 4059      E7800000 
 4060              	# main_sphere3d_hdmi.c:31:     point pivot = {HRES/2, VRES/2 -15*scalef, 0};
 4061 0310 97000000 		call	__fixsfsi		#
 4061      E7800000 
 4062 0318 130B0500 		mv	s6,a0	# tmp562,
 4063              	# main_sphere3d_hdmi.c:79:     render_lines(stars, SIZEOF(stars), angle, angle, angle, s);
 4064 031c 0325C100 		lw	a0,12(sp)		#, %sfp
 4065 0320 97000000 		call	__floatsisf		#
 4065      E7800000 
 4066              	# main_sphere3d_hdmi.c:33:     p0 = rotateY_pivot(&p0, &pivot, angle_y);
 4067 0328 97000000 		call	__fixsfsi		#
 4067      E7800000 
 4068              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 4069 0330 97000000 		call	__floatsidf		#
 4069      E7800000 
 4070 0338 03260106 		lw	a2,96(sp)		#, %sfp
 4071 033c 83264106 		lw	a3,100(sp)		#, %sfp
 4072 0340 97000000 		call	__muldf3		#
 4072      E7800000 
 4073 0348 03268106 		lw	a2,104(sp)		#, %sfp
 4074 034c 8326C106 		lw	a3,108(sp)		#, %sfp
 4075 0350 97000000 		call	__divdf3		#
 4075      E7800000 
 4076 0358 97000000 		call	__fixdfsi		#
 4076      E7800000 
 4077 0360 13150501 		slli	a0,a0,16	#, _170, tmp563
 4078 0364 13550541 		srai	a0,a0,16	#, _170, _170
 4079 0368 B787FFFF 		li	a5,-32768		# tmp632,
 4080 036c 3304F500 		add	s0,a0,a5	# tmp632, _170, _170
 4081 0370 63440500 		blt	a0,zero,.L480	#, _170,,
 4082 0374 13040500 		mv	s0,a0	# _170, _170
 4083              	.L480:
 4084 0378 13180401 		slli	a6,s0,16	#, angle, _170
 4085 037c 13580841 		srai	a6,a6,16	#, angle, angle
 4086              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 4087 0380 93578840 		srai	a5,a6,8	#, v0, angle
 4088              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 4089 0384 1344F4FF 		not	s0,s0	# tmp318, _170
 4090              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 4091 0388 13970701 		slli	a4,a5,16	#, v0.41_205, v0
 4092              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 4093 038c 13140401 		slli	s0,s0,16	#, v1, tmp318
 4094 0390 93F80702 		andi	a7,a5,32	#, _206, v0
 4095              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 4096 0394 13570701 		srli	a4,a4,16	#, v0.41_205, v0.41_205
 4097              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 4098 0398 13540441 		srai	s0,s0,16	#, v1, v1
 4099 039c 13CAF7FF 		not	s4,a5	# v0, v0
 4100 03a0 63940800 		bne	a7,zero,.L482	#, _206,,
 4101 03a4 138A0700 		mv	s4,a5	# v0, v0
 4102              	.L482:
 4103              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 4104 03a8 8326C104 		lw	a3,76(sp)		# tmp322, %sfp
 4105 03ac 93170801 		slli	a5,a6,16	#, angle.46_179, angle
 4106 03b0 93D70701 		srli	a5,a5,16	#, angle.46_179, angle.46_179
 4107 03b4 B386D700 		add	a3,a5,a3	# tmp322, tmp321, angle.46_179
 4108 03b8 03260105 		lw	a2,80(sp)		# tmp325, %sfp
 4109              	# gfx_lib_hdmi.h:109:   return sin1(angle - (int16_t)(((int32_t)INT16_MAX * 270) / 360));
 4110 03bc 93960601 		slli	a3,a3,16	#, _181, tmp321
 4111 03c0 93D60641 		srai	a3,a3,16	#, _181, _181
 4112              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4113 03c4 137AFA01 		andi	s4,s4,31	#, _211, v0
 4114 03c8 B387C700 		add	a5,a5,a2	# tmp325, _181, angle.46_179
 4115 03cc 63C40600 		blt	a3,zero,.L484	#, _181,,
 4116 03d0 93870600 		mv	a5,a3	# _181, _181
 4117              	.L484:
 4118 03d4 93960701 		slli	a3,a5,16	#, angle, _181
 4119 03d8 93D60641 		srai	a3,a3,16	#, angle, angle
 4120              	# gfx_lib_hdmi.h:88:   v0 = (angle >> INTERP_BITS);
 4121 03dc 13D58640 		srai	a0,a3,8	#, v0, angle
 4122              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 4123 03e0 93C7F7FF 		not	a5,a5	# tmp333, _181
 4124              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 4125 03e4 93140501 		slli	s1,a0,16	#, v0.41_236, v0
 4126              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 4127 03e8 93950701 		slli	a1,a5,16	#, v1, tmp333
 4128 03ec 13760502 		andi	a2,a0,32	#, _237, v0
 4129              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 4130 03f0 93D40401 		srli	s1,s1,16	#, v0.41_236, v0.41_236
 4131              	# gfx_lib_hdmi.h:89:   if(v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
 4132 03f4 93D50541 		srai	a1,a1,16	#, v1, v1
 4133 03f8 9349F5FF 		not	s3,a0	# v0, v0
 4134 03fc 63140600 		bne	a2,zero,.L486	#, _237,,
 4135 0400 93090500 		mv	s3,a0	# v0, v0
 4136              	.L486:
 4137              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 4138 0404 13050B00 		mv	a0,s6	#, _110
 4139 0408 2320B104 		sw	a1,64(sp)	# v1, %sfp
 4140 040c 232EC102 		sw	a2,60(sp)	# _237, %sfp
 4141 0410 232CD102 		sw	a3,56(sp)	# angle, %sfp
 4142 0414 232A1103 		sw	a7,52(sp)	# _206, %sfp
 4143 0418 2328E102 		sw	a4,48(sp)	# v0.41_205, %sfp
 4144 041c 23220105 		sw	a6,68(sp)	# angle, %sfp
 4145 0420 97000000 		call	__floatsisf		#
 4145      E7800000 
 4146              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4147 0428 03274102 		lw	a4,36(sp)		# tmp503, %sfp
 4148              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4149 042c 93071A00 		addi	a5,s4,1	#, tmp342, _211
 4150 0430 93971700 		slli	a5,a5,1	#, tmp343, tmp342
 4151              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4152 0434 131A1A00 		slli	s4,s4,1	#, tmp338, _211
 4153 0438 330A4701 		add	s4,a4,s4	# tmp338, tmp339, tmp503
 4154              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4155 043c B307F700 		add	a5,a4,a5	# tmp343, tmp344, tmp503
 4156              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4157 0440 03130A00 		lh	t1,0(s4)		# pretmp_127, sin90[_211]
 4158              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4159 0444 83970700 		lh	a5,0(a5)		# sin90[_214], sin90[_214]
 4160              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4161 0448 83284103 		lw	a7,52(sp)		# _206, %sfp
 4162 044c 03270103 		lw	a4,48(sp)		# v0.41_205, %sfp
 4163 0450 83268103 		lw	a3,56(sp)		# angle, %sfp
 4164 0454 0326C103 		lw	a2,60(sp)		# _237, %sfp
 4165 0458 83250104 		lw	a1,64(sp)		# v1, %sfp
 4166              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4167 045c 93F9F901 		andi	s3,s3,31	#, _242, v0
 4168              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 4169 0460 130C0500 		mv	s8,a0	# _154, tmp564
 4170              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4171 0464 B3876740 		sub	a5,a5,t1	# tmp346, sin90[_214], pretmp_127
 4172              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4173 0468 63960800 		bne	a7,zero,.L488	#, _206,,
 4174 046c 03284104 		lw	a6,68(sp)		# angle, %sfp
 4175 0470 13040800 		mv	s0,a6	# v1, angle
 4176              	.L488:
 4177 0474 1374F40F 		andi	s0,s0,0xff	# tmp349, v1
 4178              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4179 0478 B3878702 		mul	a5,a5,s0	# tmp350, tmp346, tmp349
 4180              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4181 047c 03284102 		lw	a6,36(sp)		# tmp503, %sfp
 4182              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4183 0480 13851900 		addi	a0,s3,1	#, tmp361, _242
 4184 0484 13151500 		slli	a0,a0,1	#, tmp362, tmp361
 4185              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4186 0488 93991900 		slli	s3,s3,1	#, tmp357, _242
 4187              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4188 048c 3305A800 		add	a0,a6,a0	# tmp362, tmp363, tmp503
 4189              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4190 0490 B3093801 		add	s3,a6,s3	# tmp357, tmp358, tmp503
 4191 0494 03980900 		lh	a6,0(s3)		# pretmp_317, sin90[_242]
 4192              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4193 0498 031A0500 		lh	s4,0(a0)		# sin90[_245], sin90[_245]
 4194              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4195 049c 93D78740 		srai	a5,a5,8	#, tmp351, tmp350
 4196              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4197 04a0 B3876700 		add	a5,a5,t1	# pretmp_127, tmp354, tmp351
 4198 04a4 93970701 		slli	a5,a5,16	#, _316, tmp354
 4199 04a8 93D70701 		srli	a5,a5,16	#, _316, _316
 4200              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4201 04ac 330A0A41 		sub	s4,s4,a6	# tmp365, sin90[_245], pretmp_317
 4202              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4203 04b0 63140600 		bne	a2,zero,.L490	#, _237,,
 4204 04b4 93850600 		mv	a1,a3	# v1, angle
 4205              	.L490:
 4206 04b8 93F5F50F 		andi	a1,a1,0xff	# tmp368, v1
 4207              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4208 04bc 330ABA02 		mul	s4,s4,a1	# tmp369, tmp365, tmp368
 4209              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 4210 04c0 13770704 		andi	a4,a4,64	#, tmp380, v0.41_205
 4211 04c4 03248104 		lw	s0,72(sp)		# ivtmp.473, %sfp
 4212 04c8 13850700 		mv	a0,a5	# v1, _316
 4213              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4214 04cc 135A8A40 		srai	s4,s4,8	#, tmp370, tmp369
 4215              	# gfx_lib_hdmi.h:91:   v1 = sin90[v0] + (int16_t) (((int32_t) (sin90[v0+1]-sin90[v0]) * (v1 & INTER
 4216 04d0 330A0A01 		add	s4,s4,a6	# pretmp_317, tmp373, tmp370
 4217 04d4 131A0A01 		slli	s4,s4,16	#, _114, tmp373
 4218 04d8 135A0A01 		srli	s4,s4,16	#, _114, _114
 4219              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 4220 04dc 63040700 		beq	a4,zero,.L492	#, tmp380,,
 4221 04e0 3305F040 		neg	a0,a5	# v1, _316
 4222              	.L492:
 4223 04e4 13150501 		slli	a0,a0,16	#,, v1
 4224 04e8 13550541 		srai	a0,a0,16	#,,
 4225 04ec 97000000 		call	__floatsidf		#
 4225      E7800000 
 4226 04f4 03268102 		lw	a2,40(sp)		#, %sfp
 4227 04f8 8326C102 		lw	a3,44(sp)		#, %sfp
 4228              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 4229 04fc 93F40404 		andi	s1,s1,64	#, tmp391, v0.41_236
 4230              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 4231 0500 97000000 		call	__muldf3		#
 4231      E7800000 
 4232              	# gfx_lib_hdmi.h:281:   float sin_theta = SIN_FAST(angle);
 4233 0508 97000000 		call	__truncdfsf2		#
 4233      E7800000 
 4234 0510 93090500 		mv	s3,a0	# sin_theta, tmp565
 4235              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 4236 0514 33054041 		neg	a0,s4	# v1, _114
 4237 0518 63940400 		bne	s1,zero,.L494	#, tmp391,,
 4238 051c 13050A00 		mv	a0,s4	# v1, _114
 4239              	.L494:
 4240 0520 13150501 		slli	a0,a0,16	#,, v1
 4241 0524 13550541 		srai	a0,a0,16	#,,
 4242 0528 97000000 		call	__floatsidf		#
 4242      E7800000 
 4243 0530 03268102 		lw	a2,40(sp)		#, %sfp
 4244 0534 8326C102 		lw	a3,44(sp)		#, %sfp
 4245 0538 97000000 		call	__muldf3		#
 4245      E7800000 
 4246              	# gfx_lib_hdmi.h:282:   float cos_theta = COS_FAST(angle);
 4247 0540 97000000 		call	__truncdfsf2		#
 4247      E7800000 
 4248 0548 130A0500 		mv	s4,a0	# cos_theta, tmp566
 4249              	.L496:
 4250              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 4251 054c 03250400 		lw	a0,0(s0)		#, MEM[(int *)_91]
 4252 0550 97000000 		call	__floatsisf		#
 4252      E7800000 
 4253 0558 93050900 		mv	a1,s2	#, s
 4254 055c 97000000 		call	__mulsf3		#
 4254      E7800000 
 4255              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 4256 0564 97000000 		call	__fixsfsi		#
 4256      E7800000 
 4257              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 4258 056c 130525FE 		addi	a0,a0,-30	#,, tmp567
 4259 0570 97000000 		call	__floatsisf		#
 4259      E7800000 
 4260 0578 93050A00 		mv	a1,s4	#, cos_theta
 4261 057c 97000000 		call	__mulsf3		#
 4261      E7800000 
 4262 0584 93040500 		mv	s1,a0	# tmp568,
 4263              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 4264 0588 03258400 		lw	a0,8(s0)		#, MEM[(int *)_91 + 8B]
 4265 058c 97000000 		call	__floatsisf		#
 4265      E7800000 
 4266 0594 93050900 		mv	a1,s2	#, s
 4267 0598 97000000 		call	__mulsf3		#
 4267      E7800000 
 4268              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 4269 05a0 97000000 		call	__fixsfsi		#
 4269      E7800000 
 4270              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 4271 05a8 97000000 		call	__floatsisf		#
 4271      E7800000 
 4272 05b0 93850900 		mv	a1,s3	#, sin_theta
 4273 05b4 97000000 		call	__mulsf3		#
 4273      E7800000 
 4274 05bc 93050500 		mv	a1,a0	# tmp569,
 4275              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 4276 05c0 13850400 		mv	a0,s1	#, tmp404
 4277 05c4 97000000 		call	__addsf3		#
 4277      E7800000 
 4278              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 4279 05cc 93850A00 		mv	a1,s5	#, tmp530
 4280 05d0 97000000 		call	__addsf3		#
 4280      E7800000 
 4281              	# gfx_lib_hdmi.h:284:   transformed.x = pivot->x + (shifted_point.x*cos_theta + shifted_point.z*sin
 4282 05d8 97000000 		call	__fixsfsi		#
 4282      E7800000 
 4283              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 4284 05e0 130585FD 		addi	a0,a0,-40	#,, tmp570
 4285 05e4 97000000 		call	__floatsisf		#
 4285      E7800000 
 4286 05ec 93040500 		mv	s1,a0	# tmp571,
 4287              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 4288 05f0 03254400 		lw	a0,4(s0)		#, MEM[(int *)_91 + 4B]
 4289 05f4 97000000 		call	__floatsisf		#
 4289      E7800000 
 4290 05fc 93050900 		mv	a1,s2	#, s
 4291 0600 97000000 		call	__mulsf3		#
 4291      E7800000 
 4292              	# gfx_lib_hdmi.h:251:   point transformed = {p->x*sx, p->y*sy, p->z*sz};
 4293 0608 97000000 		call	__fixsfsi		#
 4293      E7800000 
 4294              	# gfx_lib_hdmi.h:256:   point transformed = {p->x + tx, p->y + ty, p->z + tz};
 4295 0610 1305E501 		addi	a0,a0,30	#, tmp418, tmp572
 4296              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 4297 0614 33056541 		sub	a0,a0,s6	#, tmp418, _110
 4298 0618 97000000 		call	__floatsisf		#
 4298      E7800000 
 4299 0620 130D0500 		mv	s10,a0	# tmp573,
 4300              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 4301 0624 93050A00 		mv	a1,s4	#, cos_theta
 4302 0628 13850400 		mv	a0,s1	#, _295
 4303 062c 97000000 		call	__mulsf3		#
 4303      E7800000 
 4304 0634 930D0500 		mv	s11,a0	# tmp420, tmp574
 4305              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 4306 0638 93050D00 		mv	a1,s10	#, _293
 4307 063c 13850900 		mv	a0,s3	#, sin_theta
 4308 0640 97000000 		call	__mulsf3		#
 4308      E7800000 
 4309 0648 93050500 		mv	a1,a0	# tmp575,
 4310              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 4311 064c 13850D00 		mv	a0,s11	#, tmp420
 4312 0650 97000000 		call	__subsf3		#
 4312      E7800000 
 4313              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 4314 0658 93850A00 		mv	a1,s5	#, tmp530
 4315 065c 97000000 		call	__addsf3		#
 4315      E7800000 
 4316              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 4317 0664 97000000 		call	__fixsfsi		#
 4317      E7800000 
 4318 066c 93070500 		mv	a5,a0	# tmp576,
 4319              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 4320 0670 93850400 		mv	a1,s1	#, _295
 4321              	# gfx_lib_hdmi.h:299:   transformed.x = pivot->x + (shifted_point.x*cos_theta - shifted_point.y*sin
 4322 0674 93840700 		mv	s1,a5	# _289, tmp576
 4323              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 4324 0678 9307F004 		li	a5,79		# tmp639,
 4325              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 4326 067c 13850900 		mv	a0,s3	#, sin_theta
 4327              	# gfx_lib_hdmi.h:202:   if  ( x > (HRES-1) ) return;
 4328 0680 63E89706 		bgtu	s1,a5,.L498	#, _289, tmp639,
 4329              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 4330 0684 97000000 		call	__mulsf3		#
 4330      E7800000 
 4331 068c 930D0500 		mv	s11,a0	# tmp426, tmp577
 4332              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 4333 0690 93050A00 		mv	a1,s4	#, cos_theta
 4334 0694 13050D00 		mv	a0,s10	#, _293
 4335 0698 97000000 		call	__mulsf3		#
 4335      E7800000 
 4336 06a0 93050500 		mv	a1,a0	# tmp578,
 4337              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 4338 06a4 13850D00 		mv	a0,s11	#, tmp426
 4339 06a8 97000000 		call	__addsf3		#
 4339      E7800000 
 4340              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 4341 06b0 93050C00 		mv	a1,s8	#, _154
 4342 06b4 97000000 		call	__addsf3		#
 4342      E7800000 
 4343              	# gfx_lib_hdmi.h:300:   transformed.y = pivot->y + (shifted_point.x*sin_theta + shifted_point.y*cos
 4344 06bc 97000000 		call	__fixsfsi		#
 4344      E7800000 
 4345              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4346 06c4 93172500 		slli	a5,a0,2	#, tmp432, _350
 4347 06c8 B387A700 		add	a5,a5,a0	# _350, tmp433, tmp432
 4348              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4349 06cc 03278100 		lw	a4,8(sp)		# tmp500, %sfp
 4350              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4351 06d0 93974700 		slli	a5,a5,4	#, tmp434, tmp433
 4352 06d4 B3879700 		add	a5,a5,s1	# _289, tmp435, tmp434
 4353              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4354 06d8 93972700 		slli	a5,a5,2	#, tmp436, tmp435
 4355 06dc B307F700 		add	a5,a4,a5	# tmp436, tmp437, tmp500
 4356              	# gfx_lib_hdmi.h:203:   if  ( y > (VRES-1) ) return;
 4357 06e0 1307B003 		li	a4,59		# tmp641,
 4358 06e4 6366A700 		bgtu	a0,a4,.L498	#, _350, tmp641,
 4359              	# gfx_lib_hdmi.h:206:   fb[x + y*HRES] = color;
 4360 06e8 1307F0FF 		li	a4,-1		# tmp642,
 4361 06ec 23A0E700 		sw	a4,0(a5)	# tmp642, *_344
 4362              	.L498:
 4363              	# main_sphere3d_hdmi.c:20:   for (int i = 0; i < s - 1; i = i + 1) {
 4364 06f0 1304C400 		addi	s0,s0,12	#, ivtmp.473, ivtmp.473
 4365 06f4 E39C8CE4 		bne	s9,s0,.L496	#, _159, ivtmp.473,
 4366              	# main_sphere3d_hdmi.c:81:     oled_show_fb_8or16(framebuffer, 0x10000000 + ((*fb_ctrl & 1) ? 0 : (
 4367 06f8 83278101 		lw	a5,24(sp)		# fb_ctrl.58_22, %sfp
 4368 06fc 37070010 		li	a4,268435456		# prephitmp_381,
 4369 0700 83A70700 		lw	a5,0(a5)		# *fb_ctrl.58_22, *fb_ctrl.58_22
 4370 0704 93F71700 		andi	a5,a5,1	#, tmp441, *fb_ctrl.58_22
 4371              	# main_sphere3d_hdmi.c:81:     oled_show_fb_8or16(framebuffer, 0x10000000 + ((*fb_ctrl & 1) ? 0 : (
 4372 0708 63940700 		bne	a5,zero,.L499	#, tmp441,,
 4373 070c 37870010 		li	a4,268468224		# prephitmp_381,
 4374              	.L499:
 4375              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
 4376 0710 83278100 		lw	a5,8(sp)		# tmp500, %sfp
 4377              	# main_sphere3d_hdmi.c:87:     if (s >= 2) delta_scale = -delta_scale;
 4378 0714 83254105 		lw	a1,84(sp)		#, %sfp
 4379 0718 13050900 		mv	a0,s2	#, s
 4380              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
 4381 071c 23A6FB02 		sw	a5,44(s7)	# tmp500, MEM[(volatile uint32_t *)805306412B]
 4382              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 4383 0720 83270102 		lw	a5,32(sp)		# tmp449, %sfp
 4384              	# kianv_stdlib.h:52:   *( (volatile uint32_t*) DMA_DST  ) = dst;
 4385 0724 23A8EB02 		sw	a4,48(s7)	# prephitmp_381, MEM[(volatile uint32_t *)805306416B]
 4386              	# main_sphere3d_hdmi.c:82:     *fb_ctrl ^= 1;
 4387 0728 03278101 		lw	a4,24(sp)		# fb_ctrl.58_22, %sfp
 4388              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 4389 072c 23AAFB02 		sw	a5,52(s7)	# tmp449, MEM[(volatile uint32_t *)805306420B]
 4390              	# kianv_stdlib.h:54:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
 4391 0730 93071000 		li	a5,1		# tmp646,
 4392 0734 23ACFB02 		sw	a5,56(s7)	# tmp646, MEM[(volatile uint32_t *)805306424B]
 4393              	# main_sphere3d_hdmi.c:82:     *fb_ctrl ^= 1;
 4394 0738 83270700 		lw	a5,0(a4)		# *fb_ctrl.58_22, *fb_ctrl.58_22
 4395 073c 93C71700 		xori	a5,a5,1	#, tmp454, *fb_ctrl.58_22
 4396 0740 2320F700 		sw	a5,0(a4)	# tmp454, *fb_ctrl.58_22
 4397              	# main_sphere3d_hdmi.c:87:     if (s >= 2) delta_scale = -delta_scale;
 4398 0744 97000000 		call	__gesf2		#
 4398      E7800000 
 4399              	# main_sphere3d_hdmi.c:85:     angle += delta_angle;
 4400 074c 8327C100 		lw	a5,12(sp)		# angle, %sfp
 4401 0750 03270101 		lw	a4,16(sp)		# delta_angle, %sfp
 4402 0754 B387E700 		add	a5,a5,a4	# delta_angle, angle, angle
 4403 0758 2326F100 		sw	a5,12(sp)	# angle, %sfp
 4404              	# main_sphere3d_hdmi.c:87:     if (s >= 2) delta_scale = -delta_scale;
 4405 075c 634A0500 		blt	a0,zero,.L500	#, tmp580,,
 4406              	# main_sphere3d_hdmi.c:87:     if (s >= 2) delta_scale = -delta_scale;
 4407 0760 03274101 		lw	a4,20(sp)		# tmp654, %sfp
 4408 0764 B7070080 		li	a5,-2147483648		# tmp653,
 4409 0768 B3C7E700 		xor	a5,a5,a4	# tmp654, tmp652, tmp653
 4410 076c 232AF100 		sw	a5,20(sp)	# tmp652, %sfp
 4411              	.L500:
 4412              	# main_sphere3d_hdmi.c:88:     if (s <= 0) delta_scale = -delta_scale;
 4413 0770 93050000 		mv	a1,zero	#,
 4414 0774 13050900 		mv	a0,s2	#, s
 4415 0778 97000000 		call	__lesf2		#
 4415      E7800000 
 4416 0780 634AA000 		bgt	a0,zero,.L502	#, tmp581,,
 4417              	# main_sphere3d_hdmi.c:88:     if (s <= 0) delta_scale = -delta_scale;
 4418 0784 03274101 		lw	a4,20(sp)		# tmp657, %sfp
 4419 0788 B7070080 		li	a5,-2147483648		# tmp656,
 4420 078c B3C7E700 		xor	a5,a5,a4	# tmp657, tmp655, tmp656
 4421 0790 232AF100 		sw	a5,20(sp)	# tmp655, %sfp
 4422              	.L502:
 4423              	# main_sphere3d_hdmi.c:90:     if (angle <= 0) delta_angle = -delta_angle;
 4424 0794 8327C100 		lw	a5,12(sp)		# angle, %sfp
 4425              	# main_sphere3d_hdmi.c:89:     if (angle >= 359) delta_angle = -delta_angle;
 4426 0798 83260101 		lw	a3,16(sp)		# delta_angle, %sfp
 4427              	# main_sphere3d_hdmi.c:90:     if (angle <= 0) delta_angle = -delta_angle;
 4428 079c 13075016 		li	a4,357		# tmp465,
 4429 07a0 9387F7FF 		addi	a5,a5,-1	#, tmp464, angle
 4430              	# main_sphere3d_hdmi.c:89:     if (angle >= 359) delta_angle = -delta_angle;
 4431 07a4 3304D040 		neg	s0,a3	# delta_angle, delta_angle
 4432              	# main_sphere3d_hdmi.c:90:     if (angle <= 0) delta_angle = -delta_angle;
 4433 07a8 6372F706 		bleu	a5,a4,.L514	#, tmp464, tmp465,
 4434              	.L504:
 4435              	# main_sphere3d_hdmi.c:91:     s += delta_scale;
 4436 07ac 83254101 		lw	a1,20(sp)		#, %sfp
 4437 07b0 13050900 		mv	a0,s2	#, s
 4438 07b4 97000000 		call	__addsf3		#
 4438      E7800000 
 4439              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
 4440 07bc 83278100 		lw	a5,8(sp)		# tmp500, %sfp
 4441              	# main_sphere3d_hdmi.c:91:     s += delta_scale;
 4442 07c0 13090500 		mv	s2,a0	# s, tmp582
 4443              	# kianv_stdlib.h:51:   *( (volatile uint32_t*) DMA_SRC  ) = src;
 4444 07c4 23A6FB02 		sw	a5,44(s7)	# tmp500, MEM[(volatile uint32_t *)805306412B]
 4445              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 4446 07c8 83270102 		lw	a5,32(sp)		# tmp449, %sfp
 4447              	# kianv_stdlib.h:52:   *( (volatile uint32_t*) DMA_DST  ) = dst;
 4448 07cc 23A80B02 		sw	zero,48(s7)	#, MEM[(volatile uint32_t *)805306416B]
 4449              	# kianv_stdlib.h:53:   *( (volatile uint32_t*) DMA_LEN  ) = len;
 4450 07d0 23AAFB02 		sw	a5,52(s7)	# tmp449, MEM[(volatile uint32_t *)805306420B]
 4451              	# kianv_stdlib.h:54:   *( (volatile uint32_t*) DMA_CTRL ) = ctrl;
 4452 07d4 93072000 		li	a5,2		# tmp477,
 4453 07d8 23ACFB02 		sw	a5,56(s7)	# tmp477, MEM[(volatile uint32_t *)805306424B]
 4454              	# main_sphere3d_hdmi.c:96:     led &= 7;
 4455 07dc 8327C101 		lw	a5,28(sp)		# led, %sfp
 4456              	# main_sphere3d_hdmi.c:95:     IO_OUT(GPIO_OUTPUT, 0);
 4457 07e0 23AE0B00 		sw	zero,28(s7)	#, MEM[(volatile uint32_t *)805306396B]
 4458              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 4459 07e4 83A6CB01 		lw	a3,28(s7)		# _330, MEM[(volatile uint32_t *)805306396B]
 4460              	# main_sphere3d_hdmi.c:96:     led &= 7;
 4461 07e8 13F77700 		andi	a4,a5,7	#, led, led
 4462              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 4463 07ec 93071000 		li	a5,1		# tmp663,
 4464 07f0 B397E700 		sll	a5,a5,a4	# led, tmp484, tmp663
 4465              	# main_sphere3d_hdmi.c:97:     gpio_set_value(led++, 1);
 4466 07f4 13071700 		addi	a4,a4,1	#, led, led
 4467              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 4468 07f8 B3E7D700 		or	a5,a5,a3	# _330, _334, tmp484
 4469              	# main_sphere3d_hdmi.c:97:     gpio_set_value(led++, 1);
 4470 07fc 232EE100 		sw	a4,28(sp)	# led, %sfp
 4471              	# kianv_stdlib.h:125:       *p |=  (0x01 << (gpio & 0x1f));
 4472 0800 23AEFB00 		sw	a5,28(s7)	# _334, MEM[(volatile uint32_t *)805306396B]
 4473 0804 23288100 		sw	s0,16(sp)	# delta_angle, %sfp
 4474 0808 6FF09FAE 		j	.L505		#
 4475              	.L514:
 4476              	# main_sphere3d_hdmi.c:90:     if (angle <= 0) delta_angle = -delta_angle;
 4477 080c 13840600 		mv	s0,a3	# delta_angle, delta_angle
 4478 0810 6FF0DFF9 		j	.L504		#
 4480              		.globl	fb_ctrl
 4481              		.globl	stars
 4482              		.globl	oled_8bit_init_seq
 4483              		.globl	framebuffer
 4484              		.globl	heap_memory_used
 4485              		.globl	heap_memory
 4486              		.section	.srodata.cst8,"aM",@progbits,8
 4487              		.align	3
 4488              	.LC1:
 4489 0000 00000000 		.word	0
 4490 0004 0000E040 		.word	1088421888
 4491              		.align	3
 4492              	.LC2:
 4493 0008 00000000 		.word	0
 4494 000c 00807640 		.word	1081507840
 4495              		.align	3
 4496              	.LC3:
 4497 0010 80004000 		.word	4194432
 4498 0014 2000003F 		.word	1056964640
 4499              		.section	.srodata.cst4,"aM",@progbits,4
 4500              		.align	2
 4501              	.LC4:
 4502 0000 00007041 		.word	1097859072
 4503              		.align	2
 4504              	.LC5:
 4505 0004 0000F041 		.word	1106247680
 4506              		.align	2
 4507              	.LC6:
 4508 0008 00002042 		.word	1109393408
 4509              		.align	2
 4510              	.LC7:
 4511 000c 8FC2753D 		.word	1031127695
 4512              		.align	2
 4513              	.LC8:
 4514 0010 0000803F 		.word	1065353216
 4515              		.section	.srodata.cst8
 4516              		.align	3
 4517              	.LC10:
 4518 0018 182D4454 		.word	1413754136
 4519 001c FB210940 		.word	1074340347
 4520              		.align	3
 4521              	.LC11:
 4522 0020 00000000 		.word	0
 4523 0024 00806640 		.word	1080459264
 4524              		.section	.srodata.cst4
 4525              		.align	2
 4526              	.LC12:
 4527 0014 00000C42 		.word	1108082688
 4528              		.align	2
 4529              	.LC13:
 4530 0018 00000040 		.word	1073741824
 4531              		.section	.rodata
 4532              		.align	2
 4533              		.set	.LANCHOR1,. + 0
 4536              	sin90:
 4537 0000 0000     		.half	0
 4538 0002 4706     		.half	1607
 4539 0004 8B0C     		.half	3211
 4540 0006 C712     		.half	4807
 4541 0008 F818     		.half	6392
 4542 000a 191F     		.half	7961
 4543 000c 2725     		.half	9511
 4544 000e 1E2B     		.half	11038
 4545 0010 FB30     		.half	12539
 4546 0012 B936     		.half	14009
 4547 0014 563C     		.half	15446
 4548 0016 CD41     		.half	16845
 4549 0018 1C47     		.half	18204
 4550 001a 3F4C     		.half	19519
 4551 001c 3351     		.half	20787
 4552 001e F455     		.half	22004
 4553 0020 815A     		.half	23169
 4554 0022 D65E     		.half	24278
 4555 0024 F162     		.half	25329
 4556 0026 CE66     		.half	26318
 4557 0028 6C6A     		.half	27244
 4558 002a C96D     		.half	28105
 4559 002c E170     		.half	28897
 4560 002e B573     		.half	29621
 4561 0030 4076     		.half	30272
 4562 0032 8378     		.half	30851
 4563 0034 7C7A     		.half	31356
 4564 0036 297C     		.half	31785
 4565 0038 897D     		.half	32137
 4566 003a 9C7E     		.half	32412
 4567 003c 617F     		.half	32609
 4568 003e D77F     		.half	32727
 4569 0040 FF7F     		.half	32767
 4570              		.data
 4571              		.align	2
 4572              		.set	.LANCHOR2,. + 0
 4575              	oled_8bit_init_seq:
 4576 0000 AEA032A1 		.string	"\256\2402\241"
 4576      00
 4577 0005 A200     		.string	"\242"
 4578 0007 A4A83FAD 		.ascii	"\244\250?\255\216\260\013\2611\263\360\212d\213x\214d\273:\276"
 4578      8EB00BB1 
 4578      31B3F08A 
 4578      648B788C 
 4578      64BB3ABE 
 4579 001b 3E870681 		.ascii	">\207\006\201\221\202P\203}\257"
 4579      91825083 
 4579      7DAF
 4580              		.bss
 4581              		.align	2
 4582              		.set	.LANCHOR0,. + 0
 4585              	heap_memory:
 4586 0000 00000000 		.zero	1024
 4586      00000000 
 4586      00000000 
 4586      00000000 
 4586      00000000 
 4589              	stars:
 4590 0400 00000000 		.zero	4320
 4590      00000000 
 4590      00000000 
 4590      00000000 
 4590      00000000 
 4593              	framebuffer:
 4594 14e0 00000000 		.zero	19200
 4594      00000000 
 4594      00000000 
 4594      00000000 
 4594      00000000 
 4595              		.section	.sbss,"aw",@nobits
 4596              		.align	2
 4599              	col.0:
 4600 0000 0000     		.zero	2
 4601 0002 0000     		.zero	2
 4604              	heap_memory_used:
 4605 0004 00000000 		.zero	4
 4606              		.section	.sdata,"aw"
 4607              		.align	2
 4610              	fb_ctrl:
 4611 0000 24000030 		.word	805306404
 4612              		.ident	"GCC: (GNU) 11.1.0"
