!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACMD41	kernel/sdcard.c	35;"	d	file:
BACKSPACE	kernel/console.c	25;"	d	file:
C	kernel/console.c	26;"	d	file:
CMD0	kernel/sdcard.c	28;"	d	file:
CMD16	kernel/sdcard.c	30;"	d	file:
CMD17	kernel/sdcard.c	31;"	d	file:
CMD24	kernel/sdcard.c	32;"	d	file:
CMD55	kernel/sdcard.c	33;"	d	file:
CMD58	kernel/sdcard.c	34;"	d	file:
CMD8	kernel/sdcard.c	29;"	d	file:
CS_DISABLE	kernel/sdcard.c	/^void CS_DISABLE() {$/;"	f
CS_ENABLE	kernel/sdcard.c	/^void CS_ENABLE() {$/;"	f
CTR	kernel/sdcard.c	23;"	d	file:
FCR	kernel/uart.c	27;"	d	file:
FCR_FIFO_CLEAR	kernel/uart.c	29;"	d	file:
FCR_FIFO_ENABLE	kernel/uart.c	28;"	d	file:
IER	kernel/uart.c	24;"	d	file:
IER_RX_ENABLE	kernel/uart.c	25;"	d	file:
IER_TX_ENABLE	kernel/uart.c	26;"	d	file:
INPUT_BUF_SIZE	kernel/console.c	48;"	d	file:
ISR	kernel/uart.c	30;"	d	file:
LCR	kernel/uart.c	31;"	d	file:
LCR_BAUD_LATCH	kernel/uart.c	33;"	d	file:
LCR_EIGHT_BITS	kernel/uart.c	32;"	d	file:
LSR	kernel/uart.c	34;"	d	file:
LSR_RX_READY	kernel/uart.c	35;"	d	file:
LSR_TX_IDLE	kernel/uart.c	36;"	d	file:
PIPESIZE	kernel/pipe.c	11;"	d	file:
R	kernel/virtio_disk.c	20;"	d	file:
RHR	kernel/uart.c	22;"	d	file:
RW	kernel/sdcard.c	22;"	d	file:
ReadReg	kernel/sdcard.c	/^unsigned char ReadReg(char reg) {$/;"	f
ReadReg	kernel/uart.c	38;"	d	file:
Reg	kernel/sdcard.c	19;"	d	file:
Reg	kernel/uart.c	16;"	d	file:
SCK	kernel/sdcard.c	25;"	d	file:
SPI_BUSY_BIT	kernel/sdcard.c	21;"	d	file:
SPI_transfer	kernel/sdcard.c	/^unsigned char SPI_transfer(unsigned char tx) {$/;"	f
SS	kernel/sdcard.c	24;"	d	file:
THR	kernel/uart.c	23;"	d	file:
UART_TX_BUF_SIZE	kernel/uart.c	43;"	d	file:
WriteReg	kernel/sdcard.c	/^void WriteReg(unsigned char reg, unsigned char value) {$/;"	f
WriteReg	kernel/uart.c	39;"	d	file:
_entry	kernel/entry32.S	/^_entry:$/;"	l
acquire	kernel/spinlock.c	/^acquire(struct spinlock *lk)$/;"	f
acquiresleep	kernel/sleeplock.c	/^acquiresleep(struct sleeplock *lk)$/;"	f
alloc3_desc	kernel/virtio_disk.c	/^alloc3_desc(int *idx)$/;"	f	file:
alloc_desc	kernel/virtio_disk.c	/^alloc_desc()$/;"	f	file:
allocpid	kernel/proc.c	/^allocpid()$/;"	f
allocproc	kernel/proc.c	/^allocproc(void)$/;"	f	file:
argaddr	kernel/syscall.c	/^argaddr(int n, uint32 *ip)$/;"	f
argfd	kernel/sysfile.c	/^argfd(int n, int *pfd, struct file **pf)$/;"	f	file:
argint	kernel/syscall.c	/^argint(int n, int *ip)$/;"	f
argraw	kernel/syscall.c	/^argraw(int n)$/;"	f	file:
argstr	kernel/syscall.c	/^argstr(int n, char *buf, int max)$/;"	f
avail	kernel/virtio_disk.c	/^  struct virtq_avail *avail;$/;"	m	struct:disk	typeref:struct:disk::virtq_avail	file:
b	kernel/virtio_disk.c	/^    struct buf *b;$/;"	m	struct:disk::__anon7	typeref:struct:disk::__anon7::buf	file:
balloc	kernel/fs.c	/^balloc(uint dev)$/;"	f	file:
bcache	kernel/bio.c	/^} bcache;$/;"	v	typeref:struct:__anon1
begin_op	kernel/log.c	/^begin_op(void)$/;"	f
bfree	kernel/fs.c	/^bfree(int dev, uint b)$/;"	f	file:
bget	kernel/bio.c	/^bget(uint dev, uint blockno)$/;"	f	file:
binit	kernel/bio.c	/^binit(void)$/;"	f
block	kernel/log.c	/^  int block[LOGSIZE];$/;"	m	struct:logheader	file:
bmap	kernel/fs.c	/^bmap(struct inode *ip, uint bn)$/;"	f	file:
bpin	kernel/bio.c	/^bpin(struct buf *b) {$/;"	f
bread	kernel/bio.c	/^bread(uint dev, uint blockno)$/;"	f
brelse	kernel/bio.c	/^brelse(struct buf *b)$/;"	f
buf	kernel/bio.c	/^  struct buf buf[NBUF];$/;"	m	struct:__anon1	typeref:struct:__anon1::buf	file:
buf	kernel/console.c	/^  char buf[INPUT_BUF_SIZE];$/;"	m	struct:__anon2	file:
bunpin	kernel/bio.c	/^bunpin(struct buf *b) {$/;"	f
bwrite	kernel/bio.c	/^bwrite(struct buf *b)$/;"	f
bzero	kernel/fs.c	/^bzero(int dev, int bno)$/;"	f	file:
clockintr	kernel/trap.c	/^clockintr()$/;"	f
commit	kernel/log.c	/^commit()$/;"	f	file:
committing	kernel/log.c	/^  int committing;  \/\/ in commit(), please wait.$/;"	m	struct:log	file:
cons	kernel/console.c	/^} cons;$/;"	v	typeref:struct:__anon2
consoleinit	kernel/console.c	/^consoleinit(void)$/;"	f
consoleintr	kernel/console.c	/^consoleintr(int c)$/;"	f
consoleread	kernel/console.c	/^consoleread(int user_dst, uint32 dst, int n)$/;"	f
consolewrite	kernel/console.c	/^consolewrite(int user_src, uint32 src, int n)$/;"	f
consputc	kernel/console.c	/^consputc(int c)$/;"	f
copyin	kernel/vm.c	/^copyin(pagetable_t pagetable, char *dst, uint32 srcva, uint32 len)$/;"	f
copyinstr	kernel/vm.c	/^copyinstr(pagetable_t pagetable, char *dst, uint32 srcva, uint32 max)$/;"	f
copyout	kernel/vm.c	/^copyout(pagetable_t pagetable, uint32 dstva, char *src, uint32 len)$/;"	f
cpuid	kernel/proc.c	/^cpuid()$/;"	f
cpus	kernel/proc.c	/^struct cpu cpus[NCPU];$/;"	v	typeref:struct:cpu
create	kernel/sysfile.c	/^create(char *path, short type, short major, short minor)$/;"	f	file:
ctrl	kernel/sdcard.c	/^  volatile uint32 *ctrl;$/;"	m	struct:spi_regs	file:
data	kernel/pipe.c	/^  char data[PIPESIZE];$/;"	m	struct:pipe	file:
data	kernel/sdcard.c	/^  volatile uint32 *data;$/;"	m	struct:spi_regs	file:
desc	kernel/virtio_disk.c	/^  struct virtq_desc *desc;$/;"	m	struct:disk	typeref:struct:disk::virtq_desc	file:
dev	kernel/log.c	/^  int dev;$/;"	m	struct:log	file:
devintr	kernel/trap.c	/^devintr()$/;"	f
devsw	kernel/file.c	/^struct devsw devsw[NDEV];$/;"	v	typeref:struct:devsw
digits	kernel/printf.c	/^static char digits[] = "0123456789abcdef";$/;"	v	file:
dirlink	kernel/fs.c	/^dirlink(struct inode *dp, char *name, uint inum)$/;"	f
dirlookup	kernel/fs.c	/^dirlookup(struct inode *dp, char *name, uint *poff)$/;"	f
disk	kernel/virtio_disk.c	/^static struct disk {$/;"	s	file:
disk	kernel/virtio_disk.c	/^} disk;$/;"	v	typeref:struct:disk	file:
e	kernel/console.c	/^  uint e;  \/\/ Edit index$/;"	m	struct:__anon2	file:
either_copyin	kernel/proc.c	/^either_copyin(void *dst, int user_src, uint32 src, uint32 len)$/;"	f
either_copyout	kernel/proc.c	/^either_copyout(int user_dst, uint32 dst, void *src, uint32 len)$/;"	f
end_op	kernel/log.c	/^end_op(void)$/;"	f
exec	kernel/exec.c	/^exec(char *path, char **argv)$/;"	f
exit	kernel/proc.c	/^exit(int status)$/;"	f
fdalloc	kernel/sysfile.c	/^fdalloc(struct file *f)$/;"	f	file:
fetchaddr	kernel/syscall.c	/^fetchaddr(uint32 addr, uint32 *ip)$/;"	f
fetchstr	kernel/syscall.c	/^fetchstr(uint32 addr, char *buf, int max)$/;"	f
file	kernel/file.c	/^  struct file file[NFILE];$/;"	m	struct:__anon3	typeref:struct:__anon3::file	file:
filealloc	kernel/file.c	/^filealloc(void)$/;"	f
fileclose	kernel/file.c	/^fileclose(struct file *f)$/;"	f
filedup	kernel/file.c	/^filedup(struct file *f)$/;"	f
fileinit	kernel/file.c	/^fileinit(void)$/;"	f
fileread	kernel/file.c	/^fileread(struct file *f, uint32 addr, int n)$/;"	f
filestat	kernel/file.c	/^filestat(struct file *f, uint32 addr)$/;"	f
filewrite	kernel/file.c	/^filewrite(struct file *f, uint32 addr, int n)$/;"	f
flags2perm	kernel/exec.c	/^int flags2perm(int flags)$/;"	f
fork	kernel/proc.c	/^fork(void)$/;"	f
forkret	kernel/proc.c	/^forkret(void)$/;"	f
free	kernel/virtio_disk.c	/^  char free[NUM];  \/\/ is a descriptor free?$/;"	m	struct:disk	file:
free_chain	kernel/virtio_disk.c	/^free_chain(int i)$/;"	f	file:
free_desc	kernel/virtio_disk.c	/^free_desc(int i)$/;"	f	file:
freelist	kernel/kalloc.c	/^  struct run *freelist;$/;"	m	struct:__anon5	typeref:struct:__anon5::run	file:
freeproc	kernel/proc.c	/^freeproc(struct proc *p)$/;"	f	file:
freerange	kernel/kalloc.c	/^freerange(void *pa_start, void *pa_end)$/;"	f
freewalk	kernel/vm.c	/^freewalk(pagetable_t pagetable)$/;"	f
fsinit	kernel/fs.c	/^fsinit(int dev) {$/;"	f
ftable	kernel/file.c	/^} ftable;$/;"	v	typeref:struct:__anon3
getCRC16	kernel/sdcard.c	/^int getCRC16(unsigned char message[], int length) {$/;"	f
growproc	kernel/proc.c	/^growproc(int n)$/;"	f
head	kernel/bio.c	/^  struct buf head;$/;"	m	struct:__anon1	typeref:struct:__anon1::buf	file:
holding	kernel/spinlock.c	/^holding(struct spinlock *lk)$/;"	f
holdingsleep	kernel/sleeplock.c	/^holdingsleep(struct sleeplock *lk)$/;"	f
ialloc	kernel/fs.c	/^ialloc(uint dev, short type)$/;"	f
idup	kernel/fs.c	/^idup(struct inode *ip)$/;"	f
iget	kernel/fs.c	/^iget(uint dev, uint inum)$/;"	f	file:
iinit	kernel/fs.c	/^iinit()$/;"	f
ilock	kernel/fs.c	/^ilock(struct inode *ip)$/;"	f
info	kernel/virtio_disk.c	/^  } info[NUM];$/;"	m	struct:disk	typeref:struct:disk::__anon7	file:
initcode	kernel/proc.c	/^uchar initcode[] = {$/;"	v
initlock	kernel/spinlock.c	/^initlock(struct spinlock *lk, char *name)$/;"	f
initlog	kernel/log.c	/^initlog(int dev, struct superblock *sb)$/;"	f
initproc	kernel/proc.c	/^struct proc *initproc;$/;"	v	typeref:struct:proc
initsleeplock	kernel/sleeplock.c	/^initsleeplock(struct sleeplock *lk, char *name)$/;"	f
inode	kernel/fs.c	/^  struct inode inode[NINODE];$/;"	m	struct:__anon4	typeref:struct:__anon4::inode	file:
install_trans	kernel/log.c	/^install_trans(int recovering)$/;"	f	file:
iput	kernel/fs.c	/^iput(struct inode *ip)$/;"	f
isdirempty	kernel/sysfile.c	/^isdirempty(struct inode *dp)$/;"	f	file:
itable	kernel/fs.c	/^} itable;$/;"	v	typeref:struct:__anon4
itrunc	kernel/fs.c	/^itrunc(struct inode *ip)$/;"	f
iunlock	kernel/fs.c	/^iunlock(struct inode *ip)$/;"	f
iunlockput	kernel/fs.c	/^iunlockput(struct inode *ip)$/;"	f
iupdate	kernel/fs.c	/^iupdate(struct inode *ip)$/;"	f
kalloc	kernel/kalloc.c	/^kalloc(void)$/;"	f
kernel_pagetable	kernel/vm.c	/^pagetable_t kernel_pagetable;$/;"	v
kerneltrap	kernel/trap.c	/^kerneltrap()$/;"	f
kernelvec	kernel/kernelvec32.S	/^kernelvec:$/;"	l
kfree	kernel/kalloc.c	/^kfree(void *pa)$/;"	f
kill	kernel/proc.c	/^kill(int pid)$/;"	f
killed	kernel/proc.c	/^killed(struct proc *p)$/;"	f
kinit	kernel/kalloc.c	/^kinit()$/;"	f
kmem	kernel/kalloc.c	/^} kmem;$/;"	v	typeref:struct:__anon5
ksys_freemem	kernel/kalloc.c	/^ksys_freemem(void)$/;"	f
kvminit	kernel/vm.c	/^kvminit(void)$/;"	f
kvminithart	kernel/vm.c	/^kvminithart()$/;"	f
kvmmake	kernel/vm.c	/^kvmmake(void)$/;"	f
kvmmap	kernel/vm.c	/^kvmmap(pagetable_t kpgtbl, uint32 va, uint32 pa, uint32 sz, int perm)$/;"	f
lh	kernel/log.c	/^  struct logheader lh;$/;"	m	struct:log	typeref:struct:log::logheader	file:
loadseg	kernel/exec.c	/^loadseg(pagetable_t pagetable, uint32 va, struct inode *ip, uint offset, uint sz)$/;"	f	file:
lock	kernel/bio.c	/^  struct spinlock lock;$/;"	m	struct:__anon1	typeref:struct:__anon1::spinlock	file:
lock	kernel/console.c	/^  struct spinlock lock;$/;"	m	struct:__anon2	typeref:struct:__anon2::spinlock	file:
lock	kernel/file.c	/^  struct spinlock lock;$/;"	m	struct:__anon3	typeref:struct:__anon3::spinlock	file:
lock	kernel/fs.c	/^  struct spinlock lock;$/;"	m	struct:__anon4	typeref:struct:__anon4::spinlock	file:
lock	kernel/kalloc.c	/^  struct spinlock lock;$/;"	m	struct:__anon5	typeref:struct:__anon5::spinlock	file:
lock	kernel/log.c	/^  struct spinlock lock;$/;"	m	struct:log	typeref:struct:log::spinlock	file:
lock	kernel/pipe.c	/^  struct spinlock lock;$/;"	m	struct:pipe	typeref:struct:pipe::spinlock	file:
lock	kernel/printf.c	/^  struct spinlock lock;$/;"	m	struct:__anon6	typeref:struct:__anon6::spinlock	file:
locking	kernel/printf.c	/^  int locking;$/;"	m	struct:__anon6	file:
log	kernel/log.c	/^struct log log;$/;"	v	typeref:struct:log
log	kernel/log.c	/^struct log {$/;"	s	file:
log_write	kernel/log.c	/^log_write(struct buf *b)$/;"	f
logheader	kernel/log.c	/^struct logheader {$/;"	s	file:
main	kernel/main.c	/^main()$/;"	f
mappages	kernel/vm.c	/^mappages(pagetable_t pagetable, uint32 va, uint32 size, uint32 pa, int perm)$/;"	f
memcmp	kernel/string.c	/^memcmp(const void *v1, const void *v2, uint n)$/;"	f
memcpy	kernel/string.c	/^memcpy(void *dst, const void *src, uint n)$/;"	f
memmove	kernel/string.c	/^memmove(void *dst, const void *src, uint n)$/;"	f
memset	kernel/string.c	/^memset(void *dst, int c, uint n)$/;"	f
min	kernel/fs.c	24;"	d	file:
msleep	kernel/sdcard.c	/^void msleep(unsigned int dt){$/;"	f
mtime	kernel/sdcard.c	/^unsigned long long mtime(){$/;"	f
mycpu	kernel/proc.c	/^mycpu(void)$/;"	f
myproc	kernel/proc.c	/^myproc(void)$/;"	f
n	kernel/log.c	/^  int n;$/;"	m	struct:logheader	file:
namecmp	kernel/fs.c	/^namecmp(const char *s, const char *t)$/;"	f
namei	kernel/fs.c	/^namei(char *path)$/;"	f
nameiparent	kernel/fs.c	/^nameiparent(char *path, char *name)$/;"	f
namex	kernel/fs.c	/^namex(char *path, int nameiparent, char *name)$/;"	f	file:
next	kernel/kalloc.c	/^  struct run *next;$/;"	m	struct:run	typeref:struct:run::run	file:
nextpid	kernel/proc.c	/^int nextpid = 1;$/;"	v
nread	kernel/pipe.c	/^  uint nread;     \/\/ number of bytes read$/;"	m	struct:pipe	file:
nwrite	kernel/pipe.c	/^  uint nwrite;    \/\/ number of bytes written$/;"	m	struct:pipe	file:
ops	kernel/virtio_disk.c	/^  struct virtio_blk_req ops[NUM];$/;"	m	struct:disk	typeref:struct:disk::virtio_blk_req	file:
outstanding	kernel/log.c	/^  int outstanding; \/\/ how many FS sys calls are executing.$/;"	m	struct:log	file:
panic	kernel/printf.c	/^panic(char *s)$/;"	f
panicked	kernel/printf.c	/^volatile int panicked = 0;$/;"	v
pid_lock	kernel/proc.c	/^struct spinlock pid_lock;$/;"	v	typeref:struct:spinlock
pipe	kernel/pipe.c	/^struct pipe {$/;"	s	file:
pipealloc	kernel/pipe.c	/^pipealloc(struct file **f0, struct file **f1)$/;"	f
pipeclose	kernel/pipe.c	/^pipeclose(struct pipe *pi, int writable)$/;"	f
piperead	kernel/pipe.c	/^piperead(struct pipe *pi, uint32 addr, int n)$/;"	f
pipewrite	kernel/pipe.c	/^pipewrite(struct pipe *pi, uint32 addr, int n)$/;"	f
plic_claim	kernel/plic.c	/^plic_claim(void)$/;"	f
plic_complete	kernel/plic.c	/^plic_complete(int irq)$/;"	f
plicinit	kernel/plic.c	/^plicinit(void)$/;"	f
plicinithart	kernel/plic.c	/^plicinithart(void)$/;"	f
pop_off	kernel/spinlock.c	/^pop_off(void)$/;"	f
pr	kernel/printf.c	/^} pr;$/;"	v	typeref:struct:__anon6	file:
printf	kernel/printf.c	/^printf(char *fmt, ...)$/;"	f
printfinit	kernel/printf.c	/^printfinit(void)$/;"	f
printint	kernel/printf.c	/^printint(long xx, int base, int sign)$/;"	f	file:
printptr	kernel/printf.c	/^printptr(uint32 x)$/;"	f	file:
proc	kernel/proc.c	/^struct proc proc[NPROC];$/;"	v	typeref:struct:proc
proc_freepagetable	kernel/proc.c	/^proc_freepagetable(pagetable_t pagetable, uint32 sz)$/;"	f
proc_mapstacks	kernel/proc.c	/^proc_mapstacks(pagetable_t kpgtbl)$/;"	f
proc_pagetable	kernel/proc.c	/^proc_pagetable(struct proc *p)$/;"	f
procdump	kernel/proc.c	/^procdump(void)$/;"	f
procinit	kernel/proc.c	/^procinit(void)$/;"	f
push_off	kernel/spinlock.c	/^push_off(void)$/;"	f
r	kernel/console.c	/^  uint r;  \/\/ Read index$/;"	m	struct:__anon2	file:
ramdiskinit	kernel/ramdisk.c	/^ramdiskinit(void)$/;"	f
ramdiskrw	kernel/ramdisk.c	/^ramdiskrw(struct buf *b)$/;"	f
read_head	kernel/log.c	/^read_head(void)$/;"	f	file:
readi	kernel/fs.c	/^readi(struct inode *ip, int user_dst, uint32 dst, uint off, uint n)$/;"	f
readopen	kernel/pipe.c	/^  int readopen;   \/\/ read fd is still open$/;"	m	struct:pipe	file:
readsb	kernel/fs.c	/^readsb(int dev, struct superblock *sb)$/;"	f	file:
recover_from_log	kernel/log.c	/^recover_from_log(void)$/;"	f	file:
release	kernel/spinlock.c	/^release(struct spinlock *lk)$/;"	f
releasesleep	kernel/sleeplock.c	/^releasesleep(struct sleeplock *lk)$/;"	f
reparent	kernel/proc.c	/^reparent(struct proc *p)$/;"	f
run	kernel/kalloc.c	/^struct run {$/;"	s	file:
rx	kernel/sdcard.c	/^char rx = 0;$/;"	v
safestrcpy	kernel/string.c	/^safestrcpy(char *s, const char *t, int n)$/;"	f
sb	kernel/fs.c	/^struct superblock sb; $/;"	v	typeref:struct:superblock
sched	kernel/proc.c	/^sched(void)$/;"	f
scheduler	kernel/proc.c	/^scheduler(void)$/;"	f
sdlock	kernel/sdcard.c	/^struct spinlock sdlock;$/;"	v	typeref:struct:spinlock
setkilled	kernel/proc.c	/^setkilled(struct proc *p)$/;"	f
size	kernel/log.c	/^  int size;$/;"	m	struct:log	file:
skipelem	kernel/fs.c	/^skipelem(char *path, char *name)$/;"	f	file:
sleep	kernel/proc.c	/^sleep(void *chan, struct spinlock *lk)$/;"	f
spi	kernel/sdcard.c	/^struct spi_regs spi = {(volatile uint32 *)0x10500000,$/;"	v	typeref:struct:spi_regs
spi_cmd	kernel/sdcard.c	/^char spi_cmd(char cmd, char arg0, char arg1, char arg2, char arg3, char crc) {$/;"	f
spi_init	kernel/sdcard.c	/^int spi_init() {$/;"	f
spi_r	kernel/sdcard.c	/^unsigned int spi_r() {$/;"	f
spi_rb	kernel/sdcard.c	/^void spi_rb(unsigned int block, unsigned char* buf) {$/;"	f
spi_regs	kernel/sdcard.c	/^struct spi_regs {$/;"	s	file:
spi_rw	kernel/sdcard.c	/^unsigned char spi_rw(unsigned char c) {$/;"	f
spi_set_cs	kernel/sdcard.c	/^static void spi_set_cs(int cs_n) {$/;"	f	file:
spi_wb	kernel/sdcard.c	/^void spi_wb(unsigned int block, unsigned char* buf) {$/;"	f
spi_xfer	kernel/sdcard.c	/^static unsigned char spi_xfer(unsigned char *tx, unsigned char *rx) {$/;"	f	file:
spin	kernel/entry32.S	/^spin:$/;"	l
stack0	kernel/start.c	/^__attribute__ ((aligned (16))) char stack0[4096 * NCPU];$/;"	v
start	kernel/log.c	/^  int start;$/;"	m	struct:log	file:
start	kernel/start.c	/^start()$/;"	f
started	kernel/main.c	/^volatile static int started = 0;$/;"	v	file:
stati	kernel/fs.c	/^stati(struct inode *ip, struct stat *st)$/;"	f
status	kernel/virtio_disk.c	/^    char status;$/;"	m	struct:disk::__anon7	file:
strlen	kernel/string.c	/^strlen(const char *s)$/;"	f
strncmp	kernel/string.c	/^strncmp(const char *p, const char *q, uint n)$/;"	f
strncpy	kernel/string.c	/^strncpy(char *s, const char *t, int n)$/;"	f
swtch	kernel/swtch32.S	/^swtch:$/;"	l
sys_chdir	kernel/sysfile.c	/^sys_chdir(void)$/;"	f
sys_close	kernel/sysfile.c	/^sys_close(void)$/;"	f
sys_dup	kernel/sysfile.c	/^sys_dup(void)$/;"	f
sys_exec	kernel/sysfile.c	/^sys_exec(void)$/;"	f
sys_exit	kernel/sysproc.c	/^sys_exit(void)$/;"	f
sys_fork	kernel/sysproc.c	/^sys_fork(void)$/;"	f
sys_freemem	kernel/sysproc.c	/^sys_freemem(void)$/;"	f
sys_fstat	kernel/sysfile.c	/^sys_fstat(void)$/;"	f
sys_getpid	kernel/sysproc.c	/^sys_getpid(void)$/;"	f
sys_kill	kernel/sysproc.c	/^sys_kill(void)$/;"	f
sys_link	kernel/sysfile.c	/^sys_link(void)$/;"	f
sys_mkdir	kernel/sysfile.c	/^sys_mkdir(void)$/;"	f
sys_mknod	kernel/sysfile.c	/^sys_mknod(void)$/;"	f
sys_open	kernel/sysfile.c	/^sys_open(void)$/;"	f
sys_pipe	kernel/sysfile.c	/^sys_pipe(void)$/;"	f
sys_read	kernel/sysfile.c	/^sys_read(void)$/;"	f
sys_sbrk	kernel/sysproc.c	/^sys_sbrk(void)$/;"	f
sys_sleep	kernel/sysproc.c	/^sys_sleep(void)$/;"	f
sys_unlink	kernel/sysfile.c	/^sys_unlink(void)$/;"	f
sys_uptime	kernel/sysproc.c	/^sys_uptime(void)$/;"	f
sys_wait	kernel/sysproc.c	/^sys_wait(void)$/;"	f
sys_write	kernel/sysfile.c	/^sys_write(void)$/;"	f
syscall	kernel/syscall.c	/^syscall(void)$/;"	f
syscalls	kernel/syscall.c	/^static uint32 (*syscalls[])(void) = {$/;"	v	file:
ticks	kernel/trap.c	/^uint ticks;$/;"	v
tickslock	kernel/trap.c	/^struct spinlock tickslock;$/;"	v	typeref:struct:spinlock
timerinit	kernel/start.c	/^timerinit()$/;"	f
trampoline	kernel/trampoline32.S	/^trampoline:$/;"	l
trapinit	kernel/trap.c	/^trapinit(void)$/;"	f
trapinithart	kernel/trap.c	/^trapinithart(void)$/;"	f
uart_tx_buf	kernel/uart.c	/^char uart_tx_buf[UART_TX_BUF_SIZE];$/;"	v
uart_tx_lock	kernel/uart.c	/^struct spinlock uart_tx_lock;$/;"	v	typeref:struct:spinlock
uart_tx_r	kernel/uart.c	/^uint32 uart_tx_r; \/\/ read next from uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE]$/;"	v
uart_tx_w	kernel/uart.c	/^uint32 uart_tx_w; \/\/ write next to uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE]$/;"	v
uartgetc	kernel/uart.c	/^uartgetc(void)$/;"	f
uartinit	kernel/uart.c	/^uartinit(void)$/;"	f
uartintr	kernel/uart.c	/^uartintr(void)$/;"	f
uartputc	kernel/uart.c	/^uartputc(int c)$/;"	f
uartputc_sync	kernel/uart.c	/^uartputc_sync(int c)$/;"	f
uartstart	kernel/uart.c	/^uartstart()$/;"	f
used	kernel/virtio_disk.c	/^  struct virtq_used *used;$/;"	m	struct:disk	typeref:struct:disk::virtq_used	file:
used_idx	kernel/virtio_disk.c	/^  uint16 used_idx; \/\/ we've looked this far in used[2..NUM].$/;"	m	struct:disk	file:
userinit	kernel/proc.c	/^userinit(void)$/;"	f
userret	kernel/trampoline32.S	/^userret:$/;"	l
usertrap	kernel/trap.c	/^usertrap(void)$/;"	f
usertrapret	kernel/trap.c	/^usertrapret(void)$/;"	f
uservec	kernel/trampoline32.S	/^uservec:$/;"	l
uvmalloc	kernel/vm.c	/^uvmalloc(pagetable_t pagetable, uint32 oldsz, uint32 newsz, int xperm)$/;"	f
uvmclear	kernel/vm.c	/^uvmclear(pagetable_t pagetable, uint32 va)$/;"	f
uvmcopy	kernel/vm.c	/^uvmcopy(pagetable_t old, pagetable_t new, uint32 sz)$/;"	f
uvmcreate	kernel/vm.c	/^uvmcreate()$/;"	f
uvmdealloc	kernel/vm.c	/^uvmdealloc(pagetable_t pagetable, uint32 oldsz, uint32 newsz)$/;"	f
uvmfirst	kernel/vm.c	/^uvmfirst(pagetable_t pagetable, uchar *src, uint sz)$/;"	f
uvmfree	kernel/vm.c	/^uvmfree(pagetable_t pagetable, uint32 sz)$/;"	f
uvmunmap	kernel/vm.c	/^uvmunmap(pagetable_t pagetable, uint32 va, uint32 npages, int do_free)$/;"	f
vdisk_lock	kernel/virtio_disk.c	/^  struct spinlock vdisk_lock;$/;"	m	struct:disk	typeref:struct:disk::spinlock	file:
virtio_disk_init	kernel/virtio_disk.c	/^virtio_disk_init(void)$/;"	f
virtio_disk_intr	kernel/virtio_disk.c	/^virtio_disk_intr()$/;"	f
virtio_disk_rw	kernel/virtio_disk.c	/^virtio_disk_rw(struct buf *b, int write)$/;"	f
w	kernel/console.c	/^  uint w;  \/\/ Write index$/;"	m	struct:__anon2	file:
wait	kernel/proc.c	/^wait(uint32 addr)$/;"	f
wait_lock	kernel/proc.c	/^struct spinlock wait_lock;$/;"	v	typeref:struct:spinlock
wakeup	kernel/proc.c	/^wakeup(void *chan)$/;"	f
walk	kernel/vm.c	/^walk(pagetable_t pagetable, uint32 va, int alloc)$/;"	f
walkaddr	kernel/vm.c	/^walkaddr(pagetable_t pagetable, uint32 va)$/;"	f
write_head	kernel/log.c	/^write_head(void)$/;"	f	file:
write_log	kernel/log.c	/^write_log(void)$/;"	f	file:
writei	kernel/fs.c	/^writei(struct inode *ip, int user_src, uint32 src, uint off, uint n)$/;"	f
writeopen	kernel/pipe.c	/^  int writeopen;  \/\/ write fd is still open$/;"	m	struct:pipe	file:
yield	kernel/proc.c	/^yield(void)$/;"	f
